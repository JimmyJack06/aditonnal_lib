#include "VisLine.h"
#include <vector>
#include <list>
#include <assert.h>
#include <ipp.h>
#include <mkl.h>
#include <VisAlignHtmlLog.h>
#include "VisAlignGeneral.h"
#include <io.h>
#include <direct.h>
#include <fstream>
#include <iostream>
using namespace std;

//#include <VisAlign.h>
//#define PI (3.1415926535898)
extern std::timed_mutex g_logIndexLock;
IMG_ULWORD g_MasterLineLogIndex;
thread_local IMG_ULWORD g_LineLogIndex = 0;
thread_local IMG_CHAR g_logpathname[FILENAME_MAX_LENGTH];
IMG_VVOID check_heap(char *s, int i);
bool compare_edge_val(EdgePointLine &e1, EdgePointLine &e2)
{
	if (fabs(e1.xyDecimal.x - e2.xyDecimal.x) < 1e-6)
	{
		return e1.xyDecimal.y < e2.xyDecimal.y;
	}
	else
	{
		return e1.xyDecimal.x < e2.xyDecimal.x;
	}
}
bool compare_edge_ref(EdgePointLine *e1, EdgePointLine *e2)
{
	if (fabs(e1->xyDecimal.x - e2->xyDecimal.x) < 1e-6)
	{
		return e1->xyDecimal.y < e2->xyDecimal.y;
	}
	else
	{
		return e1->xyDecimal.x < e2->xyDecimal.x;
	}
}
static IMG_VVOID QuickSort_edge(vector<EdgePointLine>&edges, IMG_INT low, IMG_INT high)
{
	if (low < high)
	{
		int i, j;
		i = low - 1;
		j = low;
		while (j < high)
		{
			if (fabs(edges[j].xyDecimal.x - edges[high].xyDecimal.x) < 1e-6)
			{
				if (edges[j].xyDecimal.y < edges[high].xyDecimal.y)
					swap(edges[++i], edges[j]);
			}
			else if (edges[j].xyDecimal.x < edges[high].xyDecimal.x)
				swap(edges[++i], edges[j]);
			j++;


		}
		swap(edges[++i], edges[high]);
		int index = i;

		if(low < index-1)
			QuickSort_edge(edges, low, index - 1);
		if(index+1<high)
			QuickSort_edge(edges, index + 1, high);
	}
}

CVisLine::CVisLine()
{
	 m_lineOutInfo_Gen = nullptr;
	 m_lineOutInfo_Int = nullptr;
	 m_LineNum = 0;
	 m_paraLine = nullptr;
	 m_paraLineNum = 0;

	 m_SrcEdgePoints = nullptr;
	 m_ptNums = 0;
	 m_LineInputPara.pSrc = nullptr;
	 m_LineInputPara.pMask = nullptr;
	 m_LineInputPara.NormalVari = 0.0f;
	 m_searchType = SEARCH_TYPE::SOBEL_IPP;
	 m_fStep = 1;
	 m_sobelSize = SOBELMSKSIZE::kerSize3x3;
	 m_edgeDir = EDGETYPE::ANY;
	 m_gradLevel = GRADLEVEL_LINE::DARK;
	 m_GaussFilterPara.GaussKerHeight = 0; m_GaussFilterPara.GaussKerWidth = 0; m_GaussFilterPara.GaussSigmaHeight = 0; m_GaussFilterPara.GaussSigmaWidth = 0;
	 m_scanDir = RECTSCANDIR::LEFTHAND;
	 m_fOffset = 0.f;

	 m_selPtStart = { -1.f,-1.f };
	 m_selPtEnd = { -1.f,-1.f };

	 m_bDelNoise = false;
	 m_fDelEdgeDis = 3;
	 m_iDelEdgeNums = 5.f;

	 m_LineAngleRange = 180;
	 m_AcceptanceScore = -1;

	 m_pHtmlLog = nullptr;
	 m_uwDebug = 0;
	 m_strDebugPath[0] = '\0';
	 memset(&m_ROI, 0, sizeof(m_ROI));
	 m_MaxBlackWhiteCenterWidth = -1.0f;
	 m_MinLineLengthPercentOfROI = -1.0f;
	 m_FixAngle = 0;
	 m_HoughLinePara.HoughAcceptScore = 20;
	 m_HoughLinePara.HoughAngleTol = 20;
	 m_HoughLinePara.HoughInterceptResolution = 1;
	 m_HoughLinePara.HoughAngleResolution = 2;
	 m_HoughLinePara.HoughKernelSize = 3;
}
CVisLine::~CVisLine()
{
	if (m_lineOutInfo_Gen != nullptr)
	{
		delete[]m_lineOutInfo_Gen;
		m_lineOutInfo_Gen = nullptr;
	}
	if (m_lineOutInfo_Int != nullptr)
	{
		delete[]m_lineOutInfo_Int;
		m_lineOutInfo_Int = nullptr;
	}
	if (m_SrcEdgePoints)
	{
		delete[]m_SrcEdgePoints;
		m_SrcEdgePoints = nullptr;
	}
	if (m_paraLine != NULL)
	{
		delete[]m_paraLine;
		m_paraLine = NULL;
	}
}

IMG_VVOID CVisLine::SetDebug(const IMG_WORD debugflag, const IMG_CHAR *debugpath)
{
	strncpy(m_strDebugPath, debugpath, sizeof(m_strDebugPath));
	m_uwDebug = debugflag;
}


//#pragma CVisLine::set()/get()
 IMG_VVOID CVisLine::ChoiceMethod(SEARCH_TYPE searchType, GradMethod gradMethod, IMG_INT gradKernal, IMG_REAL step)
 {
	 m_searchType = searchType;
	 m_cEdge.SetGradMethod(gradMethod);
	 m_cEdge.SetGradKernal(gradKernal);
	 m_fStep = step;
 }
 IMG_VVOID CVisLine::ChoiceMethod(SEARCH_TYPE searchType, GradMethod gradMethod, IMG_INT gradKernal, IMG_INT step)
 {
	 ChoiceMethod(searchType, gradMethod, gradKernal, (IMG_REAL)step);
 }

IMG_VVOID  CVisLine::SetGaussFilterPara(IMG_REAL GaussSigmaWidth, IMG_REAL GaussSigmaHeight, IMG_UINT GaussKerWidth, IMG_UINT GaussKerHeight)
{
	m_GaussFilterPara.GaussKerHeight = GaussKerHeight;
	m_GaussFilterPara.GaussKerWidth = GaussKerWidth;
	m_GaussFilterPara.GaussSigmaWidth = GaussSigmaWidth;
	m_GaussFilterPara.GaussSigmaHeight = GaussSigmaHeight;
}

IMG_VVOID  CVisLine::SetHoughLinePara(IMG_REAL HoughAcceptScore, IMG_REAL HoughAngleTol)
{
	m_HoughLinePara.HoughAcceptScore = HoughAcceptScore;
	m_HoughLinePara.HoughAngleTol = HoughAngleTol;
}
IMG_VVOID  CVisLine::SetHoughLinePara(IMG_REAL HoughAcceptScore, IMG_REAL HoughAngleTol, IMG_REAL HoughAngleResolution, IMG_REAL HoughInterceptResolution, IMG_UINT HoughKernelSize)
{
	m_HoughLinePara.HoughAcceptScore = HoughAcceptScore;
	m_HoughLinePara.HoughAngleTol = HoughAngleTol;
	m_HoughLinePara.HoughAngleResolution = HoughAngleResolution;
	m_HoughLinePara.HoughInterceptResolution = HoughInterceptResolution;
	m_HoughLinePara.HoughKernelSize = HoughKernelSize;
}
IMG_VVOID  CVisLine::SetLineFittingPara(IMG_REAL LineFittingSigma, IMG_UINT IteMaxTimes, IMG_REAL ItePrecision)
{
	m_LineFittingPara.IteMaxTimes = IteMaxTimes;
	m_LineFittingPara.ItePrecision = ItePrecision;
	m_LineFittingPara.LineFittingSigma = LineFittingSigma;
}

IMG_VVOID  CVisLine::SetScanDir(RECTSCANDIR sacnDir)
{
	m_scanDir = sacnDir;
}

IMG_VVOID  CVisLine::SetSelectionMode(SELECTIONMODE selectionmode, IMG_RCOORD startPt, IMG_RCOORD endPt)
{
	m_SelectionMode = selectionmode;
	m_selPtStart = startPt;
	m_selPtEnd = endPt;
}

IMG_VVOID  CVisLine::SetScoreAcceptDistance(IMG_REAL score, IMG_REAL dis)
{
	m_ScoreAcceptDistance = dis;
	m_fScore = score;
}

IMG_VVOID CVisLine::SetPixelOffset(const IMG_REAL &offset)
{
	m_fOffset = offset;
}

IMG_VVOID CVisLine::SetDelNoise(bool isDel, IMG_REAL dis, IMG_INT edgeNums)
{
	m_bDelNoise = isDel;
	m_fDelEdgeDis = dis;
	m_iDelEdgeNums = edgeNums;
}

IMG_VVOID  CVisLine::SetLineInputPara(IMG_UBBUF *pubSrc, const IMG_RCOORD &PointStart, const IMG_RCOORD &PointEnd, IMG_REAL NormalVari, IMG_UBBUF *pubMask)
{
	m_LineInputPara.pSrc = pubSrc;
	m_LineInputPara.pMask = pubMask;
	m_LineInputPara.PointStart = PointStart;
	m_LineInputPara.PointEnd = PointEnd;
	m_LineInputPara.NormalVari = NormalVari;
}
IMG_VVOID  CVisLine::SetLineInputPara(const IMG_RCOORD &PointStart, const IMG_RCOORD &PointEnd, IMG_REAL NormalVari)
{
	m_LineInputPara.PointStart = PointStart;
	m_LineInputPara.PointEnd = PointEnd;
	m_LineInputPara.NormalVari = NormalVari;
	m_ROI.coWindowOff = { 0,0 };
	m_ROI.szWindowSize = { 0,0 };
}
IMG_VVOID  CVisLine::SetImage(IMG_UBBUF *pubSrc, IMG_UBBUF *pubMask)
{
	m_LineInputPara.pSrc = pubSrc;
	m_LineInputPara.pMask = pubMask;
}

IMG_VVOID CVisLine::SetLineRectPara(IMG_UBBUF *pubSrc, const IMG_RCOORD &center, const IMG_REAL &width, const IMG_REAL &height, const IMG_REAL &angle, IMG_UBBUF *pubMask)
{
	m_LineInputPara.pSrc = pubSrc;
	m_LineInputPara.pMask = pubMask;
	m_LineInputPara.PointStart.x = center.x - (width - 1) / 2 * (sin(angle*PI / 180.f));
	m_LineInputPara.PointStart.y = center.y - (width - 1) / 2 * (cos(angle*PI / 180.f));
	m_LineInputPara.PointEnd.x = center.x + (width - 1) / 2 * (sin(angle*PI / 180.f));
	m_LineInputPara.PointEnd.y = center.y + (width - 1) / 2 * (cos(angle*PI / 180.f));
	m_LineInputPara.NormalVari = (height - 1) / 2;
}

IMG_VVOID CVisLine::SetEdgeDir(const EDGETYPE &edgeDir)
{
	m_edgeDir = edgeDir;
}

IMG_VVOID CVisLine::SetSobelSize(SOBELMSKSIZE sobelSize)
{
	m_sobelSize = sobelSize;
}

IMG_VVOID CVisLine::SetGradLevel(const GRADLEVEL_LINE &gradLevel, IMG_INT minGrad)
{
	m_gradLevel = gradLevel;
	m_iMinGrad = minGrad;
}


//IMG_VVOID  CVisLine::SetParallelLineCheck(bool IsParLine)
//{
//	m_IsGetAllPoint = IsParLine;
//}

IMG_VVOID CVisLine::SetMustOutput(bool bMust)
{
	m_bMustOutput = bMust;

}
IMG_UINT CVisLine::GetSrcEdgePointsNum(IMG_VVOID)
{
	return (IMG_UINT)m_ptNums;
}
IMG_VVOID CVisLine::GetSrcEdgePoints(IMG_RCOORD *Points)
{
	for (int i = 0; i < m_ptNums; i++)
	{
		Points[i] = m_SrcEdgePoints[i];
	}
}
IMG_VVOID  CVisLine::GetSrcEdgePoints(IMG_RCOORD *&Points, IMG_INT &ptNums)
{
	ptNums = m_ptNums;
	if (Points == nullptr && m_ptNums > 0)
	{
		Points = new IMG_RCOORD[ptNums];
	}
	for (int i = 0; i < ptNums; i++)
	{
		Points[i] = m_SrcEdgePoints[i];
	}
}
IMG_UINT  CVisLine::GetResultNum(IMG_VVOID)
{
	return (IMG_UINT)m_LineNum;
}
IMG_VVOID  CVisLine::GetResult(IMG_LINE *lineResult)
{
	for (int i = 0; i < m_LineNum; i++)
	{
		lineResult[i].a = m_lineOutInfo_Gen[i].a;
		lineResult[i].b = m_lineOutInfo_Gen[i].b;
		lineResult[i].c = m_lineOutInfo_Gen[i].c;
		lineResult[i].endPt = m_lineOutInfo_Gen[i].endPt;
		lineResult[i].startPt = m_lineOutInfo_Gen[i].startPt;
		lineResult[i].edgeType = m_lineOutInfo_Gen[i].edgeType;
	}
}
IMG_VVOID  CVisLine::GetResult(IMG_LINE *&lineResult, IMG_INT &lineNums)
{
	lineNums = m_LineNum;
	if (lineResult == nullptr && m_LineNum > 0)
	{
		lineResult = new IMG_LINE[lineNums];
	}
	for (int i = 0; i < m_LineNum; i++)
	{

		lineResult[i].a = m_lineOutInfo_Gen[i].a;
		lineResult[i].b = m_lineOutInfo_Gen[i].b;
		lineResult[i].c = m_lineOutInfo_Gen[i].c;
		lineResult[i].endPt = m_lineOutInfo_Gen[i].endPt;
		lineResult[i].startPt = m_lineOutInfo_Gen[i].startPt;
		lineResult[i].edgeType = m_lineOutInfo_Gen[i].edgeType;
	}
}

void CVisLine::logInit(char *filename)
{
	m_pHtmlLog = (HTMLLOGGING *)CVisMemPool::PMalloc(sizeof(HTMLLOGGING));
	VALIDATE_MALLOC(m_pHtmlLog);
	if (m_pHtmlLog == nullptr)return;
	HL_Create(filename, "Bomming Line Search Log", m_pHtmlLog);
}
void CVisLine::logfinish(void)
{
	HL_Close(m_pHtmlLog);
	if (m_pHtmlLog == nullptr)return;
	CVisMemPool::PFree(m_pHtmlLog);
}


void CVisLine::writeLog(char *msg, ...)
{
	if (m_pHtmlLog == nullptr)return;

	va_list argp;
	va_start(argp, msg);
	IMG_CHAR  buf[512];
	vsprintf((char *)buf, (char *)msg, argp);
	HL_PutLine(m_pHtmlLog, buf);
	va_end(argp);
}
void CVisLine::SaveOptionToHTMLLog(struct _HTMLLOGGING *pstLog)
{
	if (pstLog == nullptr)return;
	IMG_CHAR value[1000];
	IMG_CHAR *heading[2] = { "Key", "Value" };
	HTMLLOGGING_TABLE_DATA stTable;
	HL_InitTableData(&stTable);
	stTable.title = "Search Input option";
	stTable.tablelinewidth = 0;
	stTable.column = 2;
	stTable.fontweight = FW_Medium;
	stTable.tablealign = TX_CENTER;
	stTable.tablewidth = 50;
	stTable.tablelinewidth = 1;
	stTable.bgColorOddLine = 0xbfffbf;
	stTable.formatstring = "%.6f";
	stTable.datatype = DT_REAL;
	stTable.heading = heading;
	HL_CreateTableHeader(pstLog, &stTable);

	_snprintf(value, sizeof(value), "%d", m_uwDebug);
	HL_CreateTableRow(pstLog, &stTable, "uwDebug(0/1/5/512)", value);
	switch(m_searchType)
	{
		case SEARCH_TYPE::SOBEL_IPP:
				_snprintf(value, sizeof(value), "SOBEL_IPP");
				break;
		case SEARCH_TYPE::GAUGE:
				_snprintf(value, sizeof(value), "GAUGE");
				break;
		default:
			_snprintf(value, sizeof(value), "%d", (IMG_INT)m_searchType);
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "m_searchType", value);
	switch(m_cEdge.GetGradMethod())
	{
		case GradMethod::EDGE_QUADRATIC:
			_snprintf(value, sizeof(value), "EDGE_QUADRATIC");
			break;
		case GradMethod::EDGE_GAUSS:
			_snprintf(value, sizeof(value), "EDGE_GAUSS");
			break;
		case GradMethod::EDGE_SIGMOID:
			_snprintf(value, sizeof(value), "EDGE_SIGMOID");
			break;
		case GradMethod::EDGE_RISING:
			_snprintf(value, sizeof(value), "EDGE_RISING");
			break;
		default:
			_snprintf(value, sizeof(value), "%d", m_cEdge.GetGradMethod());
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "gradMethod", value);
	_snprintf(value, sizeof(value), "%d", m_cEdge.GetGradKernal());
	HL_CreateTableRow(pstLog, &stTable, "gradKernal", value);
	_snprintf(value, sizeof(value), "%f", m_fStep);
	HL_CreateTableRow(pstLog, &stTable, "m_fStep", value);
	_snprintf(value, sizeof(value), "%d", m_GaussFilterPara.GaussKerWidth);
	HL_CreateTableRow(pstLog, &stTable, "GaussKerWidth", value);
	_snprintf(value, sizeof(value), "%d", m_GaussFilterPara.GaussKerHeight);
	HL_CreateTableRow(pstLog, &stTable, "GaussKerHeight", value);
	_snprintf(value, sizeof(value), "%f", m_GaussFilterPara.GaussSigmaWidth);
	HL_CreateTableRow(pstLog, &stTable, "GaussSigmaWidth", value);
	_snprintf(value, sizeof(value), "%f", m_GaussFilterPara.GaussSigmaHeight);
	HL_CreateTableRow(pstLog, &stTable, "GaussSigmaHeight", value);
	_snprintf(value, sizeof(value), "%f", m_HoughLinePara.HoughAcceptScore);
	HL_CreateTableRow(pstLog, &stTable, "HoughAcceptScore", value);
	_snprintf(value, sizeof(value), "%f", m_HoughLinePara.HoughAngleTol);
	HL_CreateTableRow(pstLog, &stTable, "HoughAngleTol", value);
	_snprintf(value, sizeof(value), "%f", m_HoughLinePara.HoughAngleResolution);
	HL_CreateTableRow(pstLog, &stTable, "HoughAngleResolution(in pixel)", value);
	_snprintf(value, sizeof(value), "%f", m_HoughLinePara.HoughInterceptResolution);
	HL_CreateTableRow(pstLog, &stTable, "HoughInterceptResolution(in pixel)", value);
	_snprintf(value, sizeof(value), "%f", m_HoughLinePara.HoughKernelSize);
	HL_CreateTableRow(pstLog, &stTable, "HoughKernelSize(in pixel)", value);
	_snprintf(value, sizeof(value), "%f", m_AcceptanceScore);
	HL_CreateTableRow(pstLog, &stTable, "AcceptanceScore", value);
	_snprintf(value, sizeof(value), "%f", m_LineAngleRange);
	HL_CreateTableRow(pstLog, &stTable, "LineAngleRange(related to start/end pt)", value);
	_snprintf(value, sizeof(value), "%f", m_FixAngle);
	HL_CreateTableRow(pstLog, &stTable, "m_FixAngle(related to start/end pt)", value);
	_snprintf(value, sizeof(value), "%d", m_LineFittingPara.IteMaxTimes);
	HL_CreateTableRow(pstLog, &stTable, "IteMaxTimes", value);
	_snprintf(value, sizeof(value), "%f", m_LineFittingPara.ItePrecision);
	HL_CreateTableRow(pstLog, &stTable, "ItePrecision", value);
	_snprintf(value, sizeof(value), "%f", m_LineFittingPara.LineFittingSigma);
	HL_CreateTableRow(pstLog, &stTable, "LineFittingSigma", value);
	switch(m_scanDir)
	{
		case RECTSCANDIR::LEFTHAND:
			_snprintf(value, sizeof(value), "LEFTHAND");
			break;
		case RECTSCANDIR::RIGHTHAND:
			_snprintf(value, sizeof(value), "RIGHTHAND");
			break;
		default:
			_snprintf(value, sizeof(value), "%d", (IMG_INT)m_scanDir);
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "m_scanDir", value);
	switch(m_edgeDir)
	{
		case EDGETYPE::ANY:
			_snprintf(value, sizeof(value), "ANY");
			break;
		case EDGETYPE::LIGHT2DARK:
			_snprintf(value, sizeof(value), "LIGHT2DARK");
			break;
		case EDGETYPE::DARK2LIGHT:
			_snprintf(value, sizeof(value), "DARK2LIGHT");
			break;
		case EDGETYPE::WHITECENTER:
			_snprintf(value, sizeof(value), "WHITECENTER");
			break;
		case EDGETYPE::BLACKCENTER:
			_snprintf(value, sizeof(value), "BLACKCENTER");
			break;
		case EDGETYPE::BOTH:
			_snprintf(value, sizeof(value), "BOTH");
			break;
		default:
			_snprintf(value, sizeof(value), "%d", (IMG_INT)m_edgeDir);
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "m_edgeDir", value);
	_snprintf(value, sizeof(value), "%f", m_MaxBlackWhiteCenterWidth);
	HL_CreateTableRow(pstLog, &stTable, "m_MaxBlackWhiteCenterWidth", value);
	_snprintf(value, sizeof(value), "%f", m_MinLineLengthPercentOfROI);
	HL_CreateTableRow(pstLog, &stTable, "m_MinLineLengthPercentOfROIh", value);

	switch(m_SelectionMode)
	{
		case SELECTIONMODE::all:
			_snprintf(value, sizeof(value), "all");
			break;
		case SELECTIONMODE::highscore:
			_snprintf(value, sizeof(value), "highscore");
			break;
		case SELECTIONMODE::best:
			_snprintf(value, sizeof(value), "best");
			break;
		case SELECTIONMODE::selectpoint:
			_snprintf(value, sizeof(value), "selectpoint");
			break;
		default:
			_snprintf(value, sizeof(value), "%d", (IMG_INT)m_SelectionMode);
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "m_SelectionMode", value);
	_snprintf(value, sizeof(value), "[ %.3f %.3f ] - [ %.3f %.3f ]", m_selPtStart.x- m_ROI.coWindowOff.x, m_selPtStart.y- m_ROI.coWindowOff.y, m_selPtEnd.x- m_ROI.coWindowOff.x, m_selPtEnd.y- m_ROI.coWindowOff.y);
	HL_CreateTableRow(pstLog, &stTable, "m_selPtStart-m_selPtEnd", value);
	_snprintf(value, sizeof(value), "%f", m_ScoreAcceptDistance);
	HL_CreateTableRow(pstLog, &stTable, "m_ScoreAcceptDistance(valid pt distance to line)", value);
	_snprintf(value, sizeof(value), "%f", m_fScore);
	HL_CreateTableRow(pstLog, &stTable, "m_fScore", value);
	_snprintf(value, sizeof(value), "[ %.3f %.3f ] - [ %.3f %.3f ]", m_LineInputPara.PointStart.x, m_LineInputPara.PointStart.y, m_LineInputPara.PointEnd.x, m_LineInputPara.PointEnd.y);
	HL_CreateTableRow(pstLog, &stTable, "ROILine:StartPt-EndPt", value);
	_snprintf(value, sizeof(value), "[ %d %d ] - [ %d %d ]", m_ROI.coWindowOff.x, m_ROI.coWindowOff.y, m_ROI.coWindowOff.x+m_ROI.szWindowSize.width, m_ROI.coWindowOff.y+m_ROI.szWindowSize.height);
	HL_CreateTableRow(pstLog, &stTable, "ROIImage:StartPt-EndPt", value);
	_snprintf(value, sizeof(value), "%f", m_LineInputPara.NormalVari);
	HL_CreateTableRow(pstLog, &stTable, "ROI:Halfwidth", value);
	switch(m_sobelSize)
	{
		case SOBELMSKSIZE::kerSize1x3:
			_snprintf(value, sizeof(value), "kerSize1x3");
			break;
		case SOBELMSKSIZE::kerSize1x5:
			_snprintf(value, sizeof(value), "kerSize1x5");
			break;
		case SOBELMSKSIZE::kerSize3x1:
			_snprintf(value, sizeof(value), "kerSize3x1");
			break;
		case SOBELMSKSIZE::kerSize3x3:
			_snprintf(value, sizeof(value), "kerSize3x3");
			break;
		case SOBELMSKSIZE::kerSize5x1:
			_snprintf(value, sizeof(value), "kerSize5x1");
			break;
		case SOBELMSKSIZE::kerSize5x5:
			_snprintf(value, sizeof(value), "kerSize5x5");
			break;
		default:
			_snprintf(value, sizeof(value), "%d", (IMG_INT)m_sobelSize);
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "m_sobelSize", value);
	switch(m_gradLevel)
	{
		case GRADLEVEL_LINE::DARK:
			_snprintf(value, sizeof(value), "DARK");
			break;
		case GRADLEVEL_LINE::NORMAL:
			_snprintf(value, sizeof(value), "NORMAL");
			break;
		case GRADLEVEL_LINE::LIGHT:
			_snprintf(value, sizeof(value), "LIGHT");
			break;
		case GRADLEVEL_LINE::USERINPUT:
			_snprintf(value, sizeof(value), "USERINPUT");
			break;
		default:
			_snprintf(value, sizeof(value), "%d", (IMG_INT)m_gradLevel);
			break;
	}
	HL_CreateTableRow(pstLog, &stTable, "m_gradLevel", value);
	_snprintf(value, sizeof(value), "%d", m_iMinGrad);
	HL_CreateTableRow(pstLog, &stTable, "m_iMinGrad", value);
	_snprintf(value, sizeof(value), "%d", m_bMustOutput);
	HL_CreateTableRow(pstLog, &stTable, "m_bMustOutput", value);
	_snprintf(value, sizeof(value), "%f", m_fOffset);
	HL_CreateTableRow(pstLog, &stTable, "m_fOffset", value);
	_snprintf(value, sizeof(value), "%d", m_bDelNoise);
	HL_CreateTableRow(pstLog, &stTable, "m_bDelNoise", value);
	_snprintf(value, sizeof(value), "%f", m_fDelEdgeDis);
	HL_CreateTableRow(pstLog, &stTable, "m_fDelEdgeDis", value);
	_snprintf(value, sizeof(value), "%d", m_iDelEdgeNums);
	HL_CreateTableRow(pstLog, &stTable, "m_iDelEdgeNums", value);
	HL_CloseTable(pstLog);
}
void CVisLine::DrawResultImage(CVisImage &canvas)
{
	IMG_RCOORD start, end, corner[4];
	IMG_REAL halfwidth, angle;
	start = m_LineInputPara.PointStart;
	end = m_LineInputPara.PointEnd;
	angle = atan2(end.y-start.y, end.x-start.x);
	halfwidth = m_LineInputPara.NormalVari;
	corner[0].x = halfwidth*sin(angle)+start.x;
	corner[0].y = -halfwidth*cos(angle)+start.y;
	corner[1].x = halfwidth*sin(angle)+end.x;
	corner[1].y = -halfwidth*cos(angle)+end.y;
	corner[2].x = -halfwidth*sin(angle)+end.x;
	corner[2].y = halfwidth*cos(angle)+end.y;
	corner[3].x = -halfwidth*sin(angle)+start.x;
	corner[3].y = halfwidth*cos(angle)+start.y;
	canvas.DrawLine(start, end, COLORS::Red);
	for(int i = 0; i<3; i++)
		canvas.DrawLine(corner[i], corner[i+1], COLORS::Green);
	canvas.DrawLine(corner[3], corner[0], COLORS::Green);
	if (m_SelectionMode == SELECTIONMODE::selectpoint)
	{
		start.x = m_selPtStart.x - m_ROI.coWindowOff.x;
		start.y = m_selPtStart.y - m_ROI.coWindowOff.y;
		end.x = m_selPtEnd.x - m_ROI.coWindowOff.x;
		end.y = m_selPtEnd.y - m_ROI.coWindowOff.y;
		canvas.DrawPoint(&start, 1, COLORS::Fuchsia);
		canvas.DrawPoint(&end, 1, COLORS::Fuchsia);
	}
	for(int i = 0; i<m_LineNum; i++)
	{
		start.x = m_lineOutInfo_Gen[i].startPt.x - m_ROI.coWindowOff.x;
		start.y = m_lineOutInfo_Gen[i].startPt.y - m_ROI.coWindowOff.y;
		end.x = m_lineOutInfo_Gen[i].endPt.x - m_ROI.coWindowOff.x;
		end.y = m_lineOutInfo_Gen[i].endPt.y - m_ROI.coWindowOff.y;
		canvas.DrawLine(start, end, COLORS::Yellow);
		canvas.DrawPoint(&start, 1, COLORS::Blue);
		canvas.DrawPoint(&end, 1, COLORS::Blue);
	}

}
void CVisLine::OutputLineTable(LINE_INFO2D *pstList, IMG_INT num_line, IMG_CHAR *title)
{
	CVisMemPool pool;
	HTMLLOGGING_TABLE_DATA stTable;
	HL_InitTableData(&stTable);
	stTable.title = title;
	stTable.tablelinewidth = 0;
	stTable.column = 15;
	stTable.fontweight = FW_Medium;
	stTable.tablealign = TX_CENTER;
	stTable.tablewidth = 50;
	stTable.tablelinewidth = 1;
	stTable.bgColorOddLine = 0xffff7f;
	stTable.formatstring = "%.6f";
	stTable.datatype = DT_REAL;
	stTable.heading = (IMG_CHAR **)pool.Malloc(12 * sizeof(IMG_CHAR *));
	VALIDATE_MALLOC(stTable.heading);
	stTable.heading[0] = "ID";
	stTable.heading[1] = "StartX";
	stTable.heading[2] = "StartY";
	stTable.heading[3] = "EndX";
	stTable.heading[4] = "EndY";
	stTable.heading[5] = "Slop";
	stTable.heading[6] = "Intercept";
	stTable.heading[7] = "HoughScore";
	stTable.heading[8] = "Score";
	stTable.heading[9] = "FittingScore";
	stTable.heading[10] = "EdgeGradient";
	stTable.heading[11] = "EdgeType";
	stTable.heading[12] = "LeftAverageGray";
	stTable.heading[13] = "CenterAverageGray";
	stTable.heading[14] = "RightAverageGray";
	HL_CreateTableHeader(m_pHtmlLog, &stTable);
	for (int i = 0; i < num_line; i++)
	{
		char value[15][20];
		if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
		else			stTable.bgColorOddLine = 0xffffcf;
		_snprintf(value[0], sizeof(value[0]), "%d", pstList[i].id);
		_snprintf(value[1], sizeof(value[1]), "%.3f", pstList[i].PointStart.x);
		_snprintf(value[2], sizeof(value[2]), "%.3f", pstList[i].PointStart.y);
		_snprintf(value[3], sizeof(value[3]), "%.3f", pstList[i].PointEnd.x);
		_snprintf(value[4], sizeof(value[4]), "%.3f", pstList[i].PointEnd.y);
		_snprintf(value[5], sizeof(value[5]), "%.6f", pstList[i].Slope);
		_snprintf(value[6], sizeof(value[6]), "%.6f", pstList[i].b);
		_snprintf(value[7], sizeof(value[7]), "%.3f", pstList[i].houghScore);
		_snprintf(value[8], sizeof(value[8]), "%.3f", pstList[i].Score);
		_snprintf(value[9], sizeof(value[9]), "%.6f", pstList[i].FittingScore);
		_snprintf(value[10], sizeof(value[10]), "%.3f", pstList[i].EdgeGradient);
		_snprintf(value[11], sizeof(value[11]), "%d", pstList[i].edgeType);
		switch (pstList[i].edgeType)
		{
		case EDGETYPE::ANY:
			_snprintf(value[11], sizeof(value[11]), "ANY");
			break;
		case EDGETYPE::LIGHT2DARK:
			_snprintf(value[11], sizeof(value[11]), "LIGHT2DARK");
			break;
		case EDGETYPE::DARK2LIGHT:
			_snprintf(value[11], sizeof(value[11]), "DARK2LIGHT");
			break;
		case EDGETYPE::WHITECENTER:
			_snprintf(value[11], sizeof(value[11]), "WHITECENTER");
			break;
		case EDGETYPE::BLACKCENTER:
			_snprintf(value[11], sizeof(value[11]), "BLACKCENTER");
			break;
		case EDGETYPE::BOTH:
			_snprintf(value[11], sizeof(value[11]), "BOTH");
			break;
		default:
			_snprintf(value[11], sizeof(value[11]), "%d", (IMG_INT)m_edgeDir);
			break;
		}
		_snprintf(value[12], sizeof(value[12]), "%d", pstList[i].LeftAvgGrayLevel);
		_snprintf(value[13], sizeof(value[13]), "%d", pstList[i].CenterAvgGrayLevel);
		_snprintf(value[14], sizeof(value[14]), "%d", pstList[i].RightAvgGrayLevel);

		HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6],
				value[7], value[8], value[9], value[10], value[11], value[12], value[13], value[14]);
	}
	HL_CloseTable(m_pHtmlLog);
	HL_Printf(m_pHtmlLog, "\n");
}
//IMG_VVOID  CVisLine::GetResult(IMG_ParallelLINE *&lineResult, IMG_INT &lineNums)
//{
//	lineNums = m_paraLineNum;
//	lineResult = new IMG_ParallelLINE[lineNums];
//	for (int i = 0; i < m_paraLineNum; i++)
//	{
//		lineResult[i] = m_paraLine[i];
//	}
//}
IMG_VVOID CVisLine::Serialize(CMEMPack &mp)
{
	CMEMPackHeader pack_header(this, mp);
	IMG_PVVOID p = NULL;
	IMG_UINT u;
	mp.Proc(m_uwDebug);
	u = (IMG_UINT)m_searchType;
	mp.Proc(u);
	m_searchType = (SEARCH_TYPE)u;
	u = (IMG_UINT)m_cEdge.GetGradMethod();
	mp.Proc(u);
	m_cEdge.SetGradMethod((GradMethod)u);
	u = (IMG_UINT)m_cEdge.GetGradKernal();
	mp.Proc(u);
	m_cEdge.SetGradKernal(u);
	mp.Proc(m_fStep);
	mp.Proc(m_GaussFilterPara.GaussKerHeight);
	mp.Proc(m_GaussFilterPara.GaussKerWidth);
	mp.Proc(m_GaussFilterPara.GaussSigmaWidth);
	mp.Proc(m_GaussFilterPara.GaussSigmaHeight);
	mp.Proc(m_HoughLinePara.HoughAcceptScore);
	mp.Proc(m_HoughLinePara.HoughAngleTol);
	mp.Proc(m_LineFittingPara.IteMaxTimes);
	mp.Proc(m_LineFittingPara.ItePrecision);
	mp.Proc(m_LineFittingPara.LineFittingSigma);
	u = (IMG_UINT)m_scanDir;
	mp.Proc(u);
	m_scanDir = (RECTSCANDIR)u;
	u = (IMG_UINT)m_edgeDir;
	mp.Proc(u);
	m_edgeDir = (EDGETYPE)u;
	u = (IMG_UINT)m_SelectionMode;
	mp.Proc(u);
	m_SelectionMode = (SELECTIONMODE)u;
	mp.Proc(m_selPtStart);
	mp.Proc(m_selPtEnd);
	mp.Proc(m_ScoreAcceptDistance);
	mp.Proc(m_fScore);
	mp.Proc(m_LineInputPara.PointStart);
	mp.Proc(m_LineInputPara.PointEnd);
	mp.Proc(m_LineInputPara.NormalVari);
	mp.Proc(m_ROI.coWindowOff);
	mp.Proc(m_ROI.szWindowSize);
	u = (IMG_UINT)m_sobelSize;
	mp.Proc(u);
	m_sobelSize = (SOBELMSKSIZE)u;
	u = (IMG_UINT)m_gradLevel;
	mp.Proc(u);
	m_gradLevel = (GRADLEVEL_LINE)u;
	mp.Proc(m_iMinGrad);
	mp.Proc(m_bMustOutput);
	mp.Proc(m_fOffset);
	mp.Proc(m_bDelNoise);
	mp.Proc(m_fDelEdgeDis);
	mp.Proc(m_iDelEdgeNums);
	mp.Proc(m_LineAngleRange);
	mp.Proc(m_AcceptanceScore);
	mp.Proc(m_MaxBlackWhiteCenterWidth);
	mp.Proc(m_MinLineLengthPercentOfROI);
	mp.Proc(m_HoughLinePara.HoughAngleResolution);
	mp.Proc(m_HoughLinePara.HoughInterceptResolution);
	mp.Proc(m_HoughLinePara.HoughKernelSize);
	mp.Proc(m_FixAngle);
}

IMG_INT CVisLine::findLine()
{
	IMG_UINT ulLineSearchLogIndex;
	IMG_INT status = RUN_OK;
	m_LineNum = 0;
	m_ID = 1;
	LINE_INPUT_PARA para = m_LineInputPara;
	if (m_LineInputPara.pSrc == NULL)
	{
		status = (int)RUN_ERROR;
		return status;
	}
	IMG_UBBUF src = *m_LineInputPara.pSrc, *psrc_save = m_LineInputPara.pSrc, mask, *pmask_save = m_LineInputPara.pMask;
	m_LineInputPara.pSrc = &src;
	if (m_LineInputPara.pMask != nullptr)
	{
		mask = *m_LineInputPara.pMask;
		m_LineInputPara.pMask = &mask;
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Start();
		m_clock.Click("start");
	}
	if((size_t)m_ROI.szWindowSize.width*m_ROI.szWindowSize.height == 0)
	{
		IMG_REAL length = ALIGN_DIST(m_LineInputPara.PointStart, m_LineInputPara.PointEnd);
		IMG_RCOORD center = { (m_LineInputPara.PointStart.x + m_LineInputPara.PointEnd.x) / 2, (m_LineInputPara.PointStart.y + m_LineInputPara.PointEnd.y) / 2 };
		IMG_ICOORD UL, BR;
		UL.x = floor(center.x-length-m_LineInputPara.NormalVari);
		UL.y = floor(center.y-length-m_LineInputPara.NormalVari);
		BR.x = floor(center.x+length+m_LineInputPara.NormalVari);
		BR.y = floor(center.y+length+m_LineInputPara.NormalVari);
		if (UL.x > m_LineInputPara.pSrc->size.width - 1 || UL.y > m_LineInputPara.pSrc->size.height - 1 || BR.x < 0 || BR.y < 0)
		{
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Line ROI out of Image");
		}
		if(UL.x < 0)UL.x = 0;
		if(UL.y < 0)UL.y = 0;
		if(BR.x >= m_LineInputPara.pSrc->size.width)BR.x = m_LineInputPara.pSrc->size.width-1;
		if(BR.y >= m_LineInputPara.pSrc->size.height)BR.y = m_LineInputPara.pSrc->size.height-1;
		m_ROI.coWindowOff = { UL.x, UL.y };
		m_ROI.szWindowSize = {(BR.x-UL.x+1), (BR.y-UL.y+1)};
		m_LineInputPara.pSrc->ptr += m_ROI.coWindowOff.x+m_ROI.coWindowOff.y*m_LineInputPara.pSrc->linestep;
		m_LineInputPara.pSrc->size = m_ROI.szWindowSize;
		if(m_LineInputPara.pMask && m_LineInputPara.pMask->ptr && (size_t)m_LineInputPara.pMask->size.width*m_LineInputPara.pMask->size.height > 0)
		{
			m_LineInputPara.pMask->ptr += m_ROI.coWindowOff.x+m_ROI.coWindowOff.y*m_LineInputPara.pMask->linestep;
			m_LineInputPara.pMask->size = m_ROI.szWindowSize;
		}
		m_LineInputPara.PointStart.x -= m_ROI.coWindowOff.x;
		m_LineInputPara.PointStart.y -= m_ROI.coWindowOff.y;
		m_LineInputPara.PointEnd.x -= m_ROI.coWindowOff.x;
		m_LineInputPara.PointEnd.y -= m_ROI.coWindowOff.y;
	}
	if(m_uwDebug)
	{
		if (_access(m_strDebugPath, 06) != 0)
		{
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Cannot open debug log path");
		}

		if (g_LineLogIndex == 0)
		{
			IMG_CHAR pathname[FILENAME_MAX_LENGTH];
			WIN32_FIND_DATA data;
			int index, maxindex = 0;
			HANDLE h_next;
			BOOL nextfile = true;
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG*.*", m_strDebugPath);
			h_next = FindFirstFile(pathname, &data);
			while (h_next != INVALID_HANDLE_VALUE && nextfile)
			{
				char *p = data.cFileName;
				sscanf(p, "LOG%d", &index);
				if (index > maxindex) maxindex = index;
				nextfile = FindNextFile(h_next, &data);
			}
			g_logIndexLock.try_lock_for(chrono::milliseconds(200));
			if (g_MasterLineLogIndex == 0)g_MasterLineLogIndex = maxindex + 1;
			else g_MasterLineLogIndex++;
			if (g_MasterLineLogIndex > 99999)g_MasterLineLogIndex = 1;
			g_LineLogIndex = g_MasterLineLogIndex;
		}
		else
		{
			g_MasterLineLogIndex++;
			if (g_MasterLineLogIndex > 99999)g_MasterLineLogIndex = 1;
			g_LineLogIndex = g_MasterLineLogIndex;
		}
	}
	ulLineSearchLogIndex = g_LineLogIndex;
	if (m_uwDebug & 513)
	{
		IMG_CHAR /*pathname[FILENAME_MAX_LENGTH], */*p;

		_snprintf(g_logpathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uLine.html", m_strDebugPath, ulLineSearchLogIndex);
		logInit(g_logpathname);
		writeLog("Log start\n");
#ifdef DEBUG
		writeLog("Align Version Tag: %s, DEBUG\n", VisAlign::VIS_ALIGN_Version());
#else
		writeLog("Align Version Tag: %s Release\n", VisAlign::VIS_ALIGN_Version());
#endif
		writeLog("VisSystem Version Tag: %s\n", VIS_SYSTEM_DLL_Version());
		writeLog("TCL Version Tag: %s\n", TCL_DLL_Version());

#ifdef _WIN64
		writeLog("build on %s %s, x64\n", __DATE__, __TIME__);
#else
		writeLog("build on %s %s, x86\n", __DATE__, __TIME__);
#endif // _WIN64
		_snprintf(g_logpathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uLine", m_strDebugPath, ulLineSearchLogIndex);
		_mkdir(g_logpathname);
		if(m_LineInputPara.pSrc!=nullptr)
		{
			CVisImage srcImage(*m_LineInputPara.pSrc);
			_snprintf(g_logpathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uLine.bmp", m_strDebugPath, ulLineSearchLogIndex);
			srcImage.WriteImage(g_logpathname);
			writeLog("Source Image\n");
			p = strrchr(g_logpathname, '\\')+1;
			HL_InsertImage(m_pHtmlLog, p);
		}
		else
		{
			writeLog("Source Image: null\n");
		}
		if(m_LineInputPara.pMask)
		{
			CVisImage maskImage(*m_LineInputPara.pMask);
			_snprintf(g_logpathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uLineMask.png", m_strDebugPath, ulLineSearchLogIndex);
			maskImage.WriteImage(g_logpathname);
		}
		else
		{
			CVisImage maskImage(m_LineInputPara.pSrc->size, 1);
			_snprintf(g_logpathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uLineMask.png", m_strDebugPath, ulLineSearchLogIndex);
			maskImage.WriteImage(g_logpathname);
		}

		SaveOptionToHTMLLog(m_pHtmlLog);

		_snprintf(g_logpathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uLine.opt", m_strDebugPath, ulLineSearchLogIndex);
		SaveToFile(g_logpathname);
	}
	//check_heap(__FILE__, __LINE__);

	if (m_lineOutInfo_Gen != NULL)
	{
		delete[]m_lineOutInfo_Gen;
		m_lineOutInfo_Gen = NULL;
	}
	if (m_lineOutInfo_Int != NULL)
	{
		delete[]m_lineOutInfo_Int;
		m_lineOutInfo_Int = NULL;
	}
	if (m_SrcEdgePoints)
	{
		delete[]m_SrcEdgePoints;
		m_SrcEdgePoints = nullptr;
	}
	if (m_fStep < 0.1)m_fStep = 0.1f;
	IMG_INT Result;
	if (m_searchType == SEARCH_TYPE::SOBEL_IPP)
	{
		switch (m_gradLevel)
		{
		/*case GRADLEVEL_LINE::DARKER:
			m_iMinGrad = 20;
			break;*/
		case GRADLEVEL_LINE::DARK:
			m_iMinGrad = 10;
			break;
		case GRADLEVEL_LINE::NORMAL:
			m_iMinGrad = 30;
			break;
		case GRADLEVEL_LINE::LIGHT:
			m_iMinGrad = 50;
			break;
		/*case GRADLEVEL_LINE::LIGHTER:
			m_iMinGrad = 200;*/
			break;
		case GRADLEVEL_LINE::USERINPUT:

			break;
		}

		Result = LineDetect_Sobel(m_LineInputPara, m_edgeDir, m_SelectionMode, m_iMinGrad);
	}
	
	else
	{
		Result = LineDetect_Gauge(m_LineInputPara, m_edgeDir, m_SelectionMode, m_gradLevel);
	}

	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		static int index = 0;
		IMG_CHAR timelog[MAX_FILE_NAME];
		snprintf(timelog, sizeof(timelog), "%s\\LOG%03dTime.log", m_strDebugPath, ulLineSearchLogIndex);
		index++;
		m_clock.Click("end_all");
		m_clock.SetPath(timelog);
		m_clock.SaveToFile();
	}
	if (m_uwDebug & 513)
	{
		IMG_UBBUF buf[3];
		CVisImage mask;
		CVisImage src, src1;
		src1.SetImage(*m_LineInputPara.pSrc);
		src1.GetImage(buf + 0);

		if (m_LineInputPara.pMask)
		{
			mask.SetImage(*m_LineInputPara.pMask);
			src.SetImage(*m_LineInputPara.pSrc);
			mask.Not();
			mask.And_C(1);
			mask.Mul_C(30);
			mask.Mul_C(2);
			src.Sub(mask);
			src.GetImage(buf + 1);
			src.GetImage(buf + 2);
		}
		else
		{
			buf[1] = buf[2] = buf[0];
		}
		CVisImage result_img(buf);
		DrawResultImage(result_img);
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
		if (result_img.Width()*result_img.Height() < 2048 * 2048 || result_img.Width()>JPG_SIZE_LIMITATION||result_img.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uLResult.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uLResult.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\')-12;
		result_img.WriteImage(pathname);
		writeLog("Result\n");
		HL_InsertImage(m_pHtmlLog, p);
		logfinish();

		IMG_CHAR resultPathname[FILENAME_MAX_LENGTH];
		_snprintf(resultPathname, FILENAME_MAX_LENGTH, "%s\\lineResults.txt", m_strDebugPath);
		FILE *fileRes;
		errno_t ret = fopen_s(&fileRes, resultPathname, "a");
		if (ret == 0)
		{
			fprintf(fileRes, "LOG%05u : runState = %d \n", ulLineSearchLogIndex, Result);
		}
		fclose(fileRes);

	}
	m_LineInputPara.pMask = pmask_save;
	m_LineInputPara.pSrc = psrc_save;
end:	
	m_LineInputPara = para;
	memset(&m_ROI, 0, sizeof(m_ROI));
	if (Result != 0)
		return RUN_ERROR;
	return status;
}


//IMG_INT CVisLine::findParallelLine()
//{
//	if (m_LineInputPara.pSrc == NULL)
//	{
//		return (int)RUN_ERROR;
//	}
//	if (m_paraLine != NULL)
//	{
//		delete[]m_paraLine;
//		m_paraLine = NULL;
//	}
//
//	if (m_SrcEdgePoints)
//	{
//		delete[]m_SrcEdgePoints;
//		m_SrcEdgePoints = nullptr;
//	}
//	IMG_INT Result;
//
//	switch (m_gradLevel)
//	{
//		/*case GRADLEVEL_LINE::DARKER:
//		m_iMinGrad = 20;
//		break;*/
//	case GRADLEVEL_LINE::DARK:
//		m_iMinGrad = 10;
//		break;
//	case GRADLEVEL_LINE::NORMAL:
//		m_iMinGrad = 40;
//		break;
//	case GRADLEVEL_LINE::LIGHT:
//		m_iMinGrad = 70;
//		break;
//		/*case GRADLEVEL_LINE::LIGHTER:
//		m_iMinGrad = 200;*/
//		break;
//	case GRADLEVEL_LINE::USERINPUT:
//
//		break;
//	}
//
//	Result = ParallelLineDetect(m_LineInputPara, m_edgeDir, m_SelectionMode, m_iMinGrad);
//	
//	if (Result != 0)
//		return RUN_ERROR;
//
//	return RUN_OK;
//}

IMG_INT  CVisLine::LineDetect_Gauge(const LINE_INPUT_PARA &LineInput, const EDGETYPE &edgeDirect, const SELECTIONMODE &select, const GRADLEVEL_LINE &gradLevel)
{
	CVisMemPool pool;
	IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
	IMG_UINT ulLineSearchLogIndex = g_LineLogIndex;
	int runState = RUN_OK;
	IMG_RCOORD rcoSelPtStart = m_selPtStart, rcoSelPtEnd = m_selPtEnd, rcoROISrc;
	if (edgeDirect == EDGETYPE::BOTH)
	{
		m_cEdge.SetEdgeDir(EDGETYPE::ANY);
	}
	else
	{
		m_cEdge.SetEdgeDir(edgeDirect);
	}
	m_cEdge.SetGaussFilterPara(m_GaussFilterPara.GaussSigmaWidth, m_GaussFilterPara.GaussSigmaHeight, m_GaussFilterPara.GaussKerWidth, m_GaussFilterPara.GaussKerHeight);
	m_cEdge.SetGRADLEVEL_EDGE((GRADLEVEL_EDGE)gradLevel, m_iMinGrad);
	m_cEdge.SetMaxBlackWhiteCenterWidth(m_MaxBlackWhiteCenterWidth);
	m_cEdge.SetPixelOffset(m_fOffset);

	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("LineDetect(GAUGE) Start");
	}
	if (select == SELECTIONMODE::best)
	{
		m_cEdge.SetPriorSelect(EdgePriorSelect::BEST);
	}
	else
	{
		m_cEdge.SetPriorSelect(EdgePriorSelect::ALL);
	}
	
	IMG_UBBUF pubbDst; pubbDst.ptr = NULL;
	RECTROI_LINE RoiStruct;
	IMG_LREAL sine, cose;
	vector<EdgePointLine> EdgeDetecResult;
	EdgePointLine *pEdgeDetecResult = nullptr; IMG_INT edgeNums = 0;
	HOUGH_TRANS_INFO *HoughResult = nullptr; IMG_INT houghLineNums = 0;
	LINE_INFO2D *HoughResult_Slope = nullptr;
	LINE_INFO2D *FirstFittingResult = nullptr; IMG_INT firstLineNums = 0;
	LINE_INFO2D *FinalFittingResult = nullptr; IMG_INT finalLineNums = 0;
	IMG_UBBUF *pMaskRTS = nullptr;


	EdgeDetecResult.clear();
	IMG_INT i, status = VisRoiGnerate_StraightLine(LineInput, pubbDst, RoiStruct);
	if (status != 0)
	{
		if (pubbDst.ptr)
		{
			ippsFree(pubbDst.ptr);
		}
		runState = RUN_ERROR;
		return runState;
	}
	if(m_uwDebug & 513)
	{
		writeLog("ROI image");
		CVisImage roi(pubbDst);
		if(roi.Width()>JPG_SIZE_LIMITATION||roi.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROI.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROI.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\') - 12;
		roi.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
	}
	IMG_REAL step = 0;
	float widEdge;
	m_cEdge.GetLineWidth(widEdge);
	EDGE_INFORMATION *tempPt = nullptr; IMG_INT tempNums = 0;
	EdgePointLine tempEdge;
	static int gauge_debug = ALIGN_DEBUG_NONE;
	m_cEdge.SetDebug(gauge_debug, ".\\logs");
	m_cEdge.SetImage(&pubbDst);
	while (step < pubbDst.size.width-0.5)
	{
		if (m_scanDir == RECTSCANDIR::LEFTHAND)
		{
			m_cEdge.SetLine({ step,(IMG_REAL)pubbDst.size.height - 2 }, { step,1.f });
		}
		if (m_scanDir == RECTSCANDIR::RIGHTHAND)
		{
			m_cEdge.SetLine({ step,1.f }, { step,(IMG_REAL)pubbDst.size.height - 2.f });
		}
		m_cEdge.FindEdgePts();
		m_cEdge.GetEdge(tempPt, tempNums);
		if (tempNums != 0)
		{
			for (int j = 0; j < tempNums; j++)
			{
				tempEdge.xyDecimal = tempPt[j].rcoPos;
				tempEdge.xyInteger = tempPt[j].coPos;
				tempEdge.gradient = tempPt[j].gradient;
				tempEdge.angle = tempPt[j].angle;
				EdgeDetecResult.push_back(tempEdge);
			}
		}
		if (tempPt)
		{
			delete[]tempPt;
			tempPt = nullptr;
		}
		step += m_fStep;
	}
	edgeNums = EdgeDetecResult.size();
	if (LineInput.pMask != NULL)
	{
		pMaskRTS = new IMG_UBBUF;
		EdgePointLine *p = (EdgePointLine *)pool.Malloc(sizeof(EdgePointLine)*edgeNums);
		VALIDATE_MALLOC(p);
		for (i = 0; i < edgeNums; i++)p[i] = EdgeDetecResult[i];
		DSP_RTS_R_8uC1(*(LineInput.pMask), RoiStruct.SrcCenterCo, *pMaskRTS, RoiStruct.DstCenterCo, RoiStruct.RotationAngle, RoiStruct.RectangleSize);
		EdgeFilter(pMaskRTS, p, edgeNums);
		EdgeDetecResult.clear();
		for(i = 0 ;i<edgeNums; i++)EdgeDetecResult.push_back(p[i]);
		//delete pMaskRTS;
	}
	sine = sin(RoiStruct.RotationAngle);
	cose = cos(RoiStruct.RotationAngle);
	{
		//check ROI if ROI out of source image;
		IMG_RCOORD corner[4], src_pt[4];
		IMG_INT flag = IMG_FALSE;
		corner[0] = { 0,0 };
		corner[1] = { (IMG_REAL)(RoiStruct.RectangleSize.width - 1) ,0 };
		corner[2] = { (IMG_REAL)(RoiStruct.RectangleSize.width - 1), (IMG_REAL)(RoiStruct.RectangleSize.height - 1) };
		corner[3] = { 0, (IMG_REAL)(RoiStruct.RectangleSize.height - 1) };
		for (i = 0; i < 4; i++)
		{
			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, corner[i], src_pt[i]);
			if (src_pt[i].x < 2 || src_pt[i].y< 2 || src_pt[i].x > m_LineInputPara.pSrc->size.width - 3 || src_pt[i].y > m_LineInputPara.pSrc->size.height - 3)
			{
				flag = IMG_TRUE;
			}
		}
		if (flag)
		{
			IMG_UINT CurrentEdgeNum = edgeNums;
			for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
			{
				ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, EdgeDetecResult[i].xyDecimal, src_pt[0]);

				if (src_pt[0].x < 2 || src_pt[0].y< 2 || src_pt[0].x > m_LineInputPara.pSrc->size.width - 3 || src_pt[0].y > m_LineInputPara.pSrc->size.height - 3)
				{
					EdgeDetecResult[i] = EdgeDetecResult[CurrentEdgeNum - 1];
					CurrentEdgeNum--;
					i--;
				}
			}
			edgeNums = CurrentEdgeNum;
			EdgeDetecResult.resize(edgeNums);
		}
	}

	if(m_uwDebug & 4)
	{
		IMG_UINT edgeNums = EdgeDetecResult.size();
		pool.Push();
		_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdge.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		FILE *fp = fopen(pathname, "wt");
		if(fp)
		{
			fprintf(fp, "num %d\n", edgeNums);
			fprintf(fp, "x\ty\tmag\tangle\n");
			for(int i = 0; i<edgeNums;i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", EdgeDetecResult[i].xyDecimal.x, EdgeDetecResult[i].xyDecimal.y, EdgeDetecResult[i].gradient, EdgeDetecResult[i].angle);
			fclose(fp);
		}
		p = strrchr(pathname, '\\')-12;
		HL_InsertObject(m_pHtmlLog, "EdgeList", p);
		writeLog("\n");
		IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums);
		VALIDATE_MALLOC(pt);
		for(int i = 0; i<edgeNums; i++)pt[i] = EdgeDetecResult[i].xyDecimal;
		writeLog("\nEdge Point total %d\n", edgeNums);
		CVisImage edge(pubbDst);
		edge.DrawPoint(pt, edgeNums, COLORS::Red);
		if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdge.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdge.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\') - 12;
		edge.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
		pool.Pop();
	}

	if ((int)EdgeDetecResult.size() < 2)
	{
		if (pubbDst.ptr)
		{
			ippsFree(pubbDst.ptr);
		}
		runState = RUN_ERROR;
		return runState;
	}
	//if (rcoSelPtStart.x + 1.f < 1e-6&&rcoSelPtStart.y + 1.f < 1e-6&&rcoSelPtEnd.x + 1.f < 1e-6&&rcoSelPtEnd.y + 1.f < 1e-6)
	//{
	//	if (m_scanDir == RECTSCANDIR::RIGHTHAND)
	//	{
	//		rcoSelPtStart.x = 0.f; rcoSelPtStart.y = 0;
	//		rcoSelPtEnd.x = (RoiStruct.RectangleSize.width - 1); rcoSelPtEnd.y = 0;
	//	}
	//	else
	//	{
	//		rcoSelPtStart.x = 0.f; rcoSelPtStart.y = RoiStruct.RectangleSize.height - 1;
	//		rcoSelPtEnd.x = RoiStruct.RectangleSize.width - 1; rcoSelPtEnd.y = RoiStruct.RectangleSize.height - 1;
	//	}
	//}
	//else
	//{
	//	rcoSelPtStart.x = 0.f; rcoSelPtStart.y = (RoiStruct.RectangleSize.height - 1) / 2.f;
	//	rcoSelPtEnd.x = RoiStruct.RectangleSize.width - 1; rcoSelPtEnd.y = (RoiStruct.RectangleSize.height - 1) / 2.f;
	//}
	rcoROISrc = RoiStruct.SrcCenterCo;
	rcoROISrc.x += m_ROI.coWindowOff.x, rcoROISrc.y += m_ROI.coWindowOff.y;
	ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(-sine, cose, RoiStruct.DstCenterCo, rcoROISrc, m_selPtStart, rcoSelPtStart);
	ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(-sine, cose, RoiStruct.DstCenterCo, rcoROISrc, m_selPtEnd, rcoSelPtEnd);

	edgeNums = (int)EdgeDetecResult.size();
	pEdgeDetecResult = new EdgePointLine[edgeNums * 2];
	for (int i = 0; i < edgeNums; i++)
	{
		pEdgeDetecResult[i] = EdgeDetecResult[i];
	}
	EdgeDetecResult.clear();
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("edge(gauge)");
	}

	int breakNums = (int)(2.f*pubbDst.size.height / m_cEdge.GetGradKernal());
	//int lengthThre = m_HoughLinePara.HoughAcceptScore / 100.0*RoiStruct.RectangleSize.width / 2 / m_fStep;
	//int lengthThre = m_iDelEdgeNums;
	if (m_bDelNoise)
	{
		DelLineNorse(pEdgeDetecResult, edgeNums, breakNums);
	}
	
	if (m_uwDebug & 4)
	{
		pool.Push();
		_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeDelNorse.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		FILE *fp = fopen(pathname, "wt");
		if (fp)
		{
			fprintf(fp, "num %d\n", edgeNums);
			fprintf(fp, "x\ty\tmag\tangle\n");
			for (int i = 0; i<edgeNums; i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", pEdgeDetecResult[i].xyDecimal.x, pEdgeDetecResult[i].xyDecimal.y, pEdgeDetecResult[i].gradient, pEdgeDetecResult[i].angle);
			fclose(fp);
		}
		p = strrchr(pathname, '\\') - 12;
		HL_InsertObject(m_pHtmlLog, "EdgeListDelNorse", p);
		writeLog("\n");
		IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums);
		VALIDATE_MALLOC(pt);
		for (int i = 0; i<edgeNums; i++)pt[i] = pEdgeDetecResult[i].xyDecimal;
		writeLog("\nEdge Point total %d\n", edgeNums);
		CVisImage edge(pubbDst);
		edge.DrawPoint(pt, edgeNums, COLORS::Red);
		if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeDelNorse.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeDelNorse.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\') - 12;
		edge.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
		pool.Pop();
	}
	if (edgeNums < 2)
	{
		if (pubbDst.ptr)
		{
			ippsFree(pubbDst.ptr);
		}
		runState = RUN_ERROR;
		return runState;
	}

	if (m_edgeDir == EDGETYPE::BOTH)
	{
		HOUGH_TRANS_INFO *hough_info[2] = { nullptr };
		LINE_INFO2D *line_info[2] = { nullptr };
		IMG_INT line_num0 = 0, line_num1 = 0, edge_num0 = 0, edge_num1 = 0;
		EdgePointLine *edges[2] = { nullptr };
		pool.Push();
		edges[0] = (EdgePointLine *)pool.Malloc(sizeof(EdgePointLine)*edgeNums);
		edges[1] = (EdgePointLine *)pool.Malloc(sizeof(EdgePointLine)*edgeNums);
		for (i = 0; i < edgeNums; i++)
		{
			if (pEdgeDetecResult[i].angle > 0 && pEdgeDetecResult[i].angle < 180)
			{
				if (m_scanDir == RECTSCANDIR::LEFTHAND)
				{
					//light to dark
					edges[0][edge_num0] = pEdgeDetecResult[i];
					edge_num0++;
				}
				else
				{
					//dark to light
					edges[1][edge_num1] = pEdgeDetecResult[i];
					edge_num1++;
				}
			}
			else
			{
				if (m_scanDir == RECTSCANDIR::RIGHTHAND)
				{
					//light to dark
					edges[0][edge_num0] = pEdgeDetecResult[i];
					edge_num0++;
				}
				else
				{
					//dark to light
					edges[1][edge_num1] = pEdgeDetecResult[i];
					edge_num1++;
				}
			}
		}
		if (edge_num0 > 5)
		{
			HoughTransLine(RoiStruct.RectangleSize, hough_info[0], line_info[0], line_num0, edges[0], edge_num0, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol, 0);
			for (int i = 0; i < line_num0; i++)
			{
				line_info[0][i].edgeType = EDGETYPE::LIGHT2DARK;
			}
		}
		if (edge_num1 > 5)
		{
			HoughTransLine(RoiStruct.RectangleSize, hough_info[1], line_info[1], line_num1, edges[1], edge_num1, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol, 1);
			for (int i = 0; i < line_num1; i++)
			{
				line_info[1][i].edgeType = EDGETYPE::DARK2LIGHT;
			}
		}
		HoughResult = new HOUGH_TRANS_INFO[line_num0 + line_num1];
		HoughResult_Slope = new LINE_INFO2D[line_num0 + line_num1];
		houghLineNums = 0;
		for (i = 0; i < line_num0; i++)
		{
			HoughResult[houghLineNums] = hough_info[0][i];
			HoughResult_Slope[houghLineNums] = line_info[0][i];
			houghLineNums++;
		}
		for (i = 0; i < line_num1; i++)
		{
			HoughResult[houghLineNums] = hough_info[1][i];
			HoughResult_Slope[houghLineNums] = line_info[1][i];
			houghLineNums++;
		}
		delete hough_info[0];
		delete hough_info[1];
		delete line_info[0];
		delete line_info[1];
		pool.Pop();
	}
	else
	{
		HoughTransLine(RoiStruct.RectangleSize, HoughResult, HoughResult_Slope, houghLineNums, pEdgeDetecResult, edgeNums, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol, 0);
		for (int i = 0; i < houghLineNums; i++)
		{
			HoughResult_Slope[i].edgeType = m_edgeDir;
		}
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("hough");
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", houghLineNums);
		OutputLineTable(HoughResult_Slope, houghLineNums, "Hough Result");
	}
	LineFitting(FirstFittingResult, firstLineNums, HoughResult_Slope, houghLineNums, pEdgeDetecResult, edgeNums, RoiStruct.RectangleSize, m_LineFittingPara.LineFittingSigma * 1.5, m_LineFittingPara.IteMaxTimes, m_LineFittingPara.ItePrecision);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", firstLineNums);
		OutputLineTable(FirstFittingResult, firstLineNums, "First Fitting Result");
	}	
	RejectOverlapLine(FirstFittingResult, firstLineNums, pEdgeDetecResult, edgeNums, RoiStruct.RectangleSize, 0.7f);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("fitting1");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", firstLineNums);
		OutputLineTable(FirstFittingResult, firstLineNums, "First overlap reject Result");
	}
	LineFitting(FinalFittingResult, finalLineNums, FirstFittingResult, firstLineNums, pEdgeDetecResult, edgeNums, RoiStruct.RectangleSize, m_LineFittingPara.LineFittingSigma, m_LineFittingPara.IteMaxTimes, m_LineFittingPara.ItePrecision);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Second Fitting Result");
	}
	RejectOverlapLine(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums, RoiStruct.RectangleSize, 0.85f);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("fitting2");
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", firstLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "second overlap reject Result");
	}
	//if (m_bDelNoise)
	//{
	//	DelLineEdge(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums);
	//	if (edgeNums <= 2)
	//	{
	//		finalLineNums = 0;
	//	}
	//}
	LineFinalResult(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums, m_ScoreAcceptDistance);
	RejectLineOutOfAngleRange(FinalFittingResult, finalLineNums, m_LineAngleRange);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "After out of Angle reject");
	}
	RejectLineOutOfLengthRange(FinalFittingResult, finalLineNums, m_MinLineLengthPercentOfROI);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "After out of min Length reject");
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("finnal_result");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Final Result");
	}
	if (finalLineNums < 1)
	{
		ippsFree(pubbDst.ptr);
		if (pEdgeDetecResult)
		{
			delete[]pEdgeDetecResult;
			pEdgeDetecResult = nullptr;
		}
		if (HoughResult)
		{
			delete[]HoughResult;
			HoughResult = nullptr;
		}
		if (HoughResult_Slope)
		{
			delete[]HoughResult_Slope;
			HoughResult_Slope = nullptr;
		}
		if (FirstFittingResult)
		{
			delete[]FirstFittingResult;
			FirstFittingResult = nullptr;
		}
		if (FinalFittingResult)
		{
			delete[]FinalFittingResult;
			FinalFittingResult = nullptr;
		}
		runState = RUN_ERROR;
		return runState;
	}
	if (LineInput.pMask != NULL) {
		ScoreInMask(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums, pMaskRTS, m_ScoreAcceptDistance);
	}
	else
		Score(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums, m_ScoreAcceptDistance);
	GetLineAvgGray(&pubbDst, pMaskRTS, FinalFittingResult, finalLineNums, m_ScoreAcceptDistance);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("score_cal");
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after scoring %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Scoring");
	}
	IMG_REAL maxscore = 0;
	for (i = 0; i<finalLineNums; i++)
	{
		if (FinalFittingResult[i].Score > maxscore)maxscore = FinalFittingResult[i].Score;
	}
	if (m_AcceptanceScore > 0 && maxscore < m_AcceptanceScore)
	{
		if (m_bMustOutput)
		{
			for (i = 0; i < finalLineNums; i++)
			{
				if (FinalFittingResult[i].Score == maxscore)
				{
					FinalFittingResult[0] = FinalFittingResult[i];
					finalLineNums = 1;
					break;
				}
			}
		}
		else
		{
			finalLineNums = 0;
		}
	}
	else
	{
		for (i = 0; i < finalLineNums; i++)
		{
			if (m_AcceptanceScore > 0 && FinalFittingResult[i].Score < m_AcceptanceScore)
			{
				FinalFittingResult[i] = FinalFittingResult[finalLineNums - 1];
				finalLineNums--;
				i--;
			}
		}
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "After score reject");
	}
	RejectOverlapLine(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums, RoiStruct.RectangleSize, 1);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after self-reject %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "final self-reject");
		if (m_SelectionMode == SELECTIONMODE::selectpoint)
		{
			writeLog("Selection point after translated\n");
			writeLog("Start: [ %.2f %.2f], End: [ %.2f %.2f]\n", rcoSelPtStart.x, rcoSelPtStart.y, rcoSelPtEnd.x, rcoSelPtEnd.y);
		}
	}
	LineSelection(FinalFittingResult, finalLineNums, pEdgeDetecResult, edgeNums, select, rcoSelPtStart, rcoSelPtEnd);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("line_select");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after Selection %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Line Selection");
	}
	//IMG_REAL lineError;
	IMG_REAL Angle;
	if (finalLineNums != 0)
	{
		m_LineNum = finalLineNums;
		m_lineOutInfo_Gen = new IMG_LINE[finalLineNums];
		m_lineOutInfo_Int = new LINE_INFO2D[finalLineNums];
		memset(m_lineOutInfo_Int, 0, sizeof(LINE_INFO2D)*finalLineNums);
		//LineFitOutput.Line = (LINEAR_GENERNAL_EQUATION *)pool.PMalloc(sizeof(LINEAR_GENERNAL_EQUATION) * LineFitOutput.LineNumber);
		for (IMG_INT i = 0; i < finalLineNums; i++)
		{
			//lineError = LineError_KB(FinalFittingResult[i].Slope, FinalFittingResult[i].b, EdgeDetecResult);

			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, FinalFittingResult[i].PointStart, m_lineOutInfo_Int[i].PointStart);
			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, FinalFittingResult[i].PointEnd, m_lineOutInfo_Int[i].PointEnd);
			m_lineOutInfo_Int[i].PointStart.x += m_ROI.coWindowOff.x;
			m_lineOutInfo_Int[i].PointStart.y += m_ROI.coWindowOff.y;
			m_lineOutInfo_Int[i].PointEnd.x += m_ROI.coWindowOff.x;
			m_lineOutInfo_Int[i].PointEnd.y += m_ROI.coWindowOff.y;

			//Angle = atan2(m_lineOutInfo_Gen[i].PointEnd.x - m_lineOutInfo_Gen[i].PointStart.x, m_lineOutInfo_Gen[i].PointStart.y - m_lineOutInfo_Gen[i].PointEnd.y);
			Angle = atan2(m_lineOutInfo_Int[i].PointEnd.y - m_lineOutInfo_Int[i].PointStart.y, m_lineOutInfo_Int[i].PointEnd.x - m_lineOutInfo_Int[i].PointStart.x);

			m_lineOutInfo_Gen[i].a = (IMG_REAL)sin(Angle);
			m_lineOutInfo_Gen[i].b = -(IMG_REAL)cos(Angle);
			m_lineOutInfo_Gen[i].c = -(m_lineOutInfo_Int[i].PointEnd.x * m_lineOutInfo_Gen[i].a + m_lineOutInfo_Int[i].PointEnd.y * m_lineOutInfo_Gen[i].b);
			if (m_lineOutInfo_Gen[i].a < 0)
			{
				m_lineOutInfo_Gen[i].a = -m_lineOutInfo_Gen[i].a;
				m_lineOutInfo_Gen[i].b = -m_lineOutInfo_Gen[i].b;
				m_lineOutInfo_Gen[i].c = -m_lineOutInfo_Gen[i].c;
			}
			//m_lineOutInfo_Gen[i].Score = FinalFittingResult[i].Score;
			//LineFitOutput.Line[i].FittingScore = FinalFittingResult[i].FittingScore;
			//m_lineOutInfo_Gen[i].straightness = lineError;
			//m_lineOutInfo_Gen[i].EdgeGradient = FinalFittingResult[i].EdgeGradient;

			m_lineOutInfo_Gen[i].startPt.x = (IMG_REAL)m_lineOutInfo_Int[i].PointStart.x;
			m_lineOutInfo_Gen[i].startPt.y = (IMG_REAL)m_lineOutInfo_Int[i].PointStart.y;
			m_lineOutInfo_Gen[i].endPt.x = (IMG_REAL)m_lineOutInfo_Int[i].PointEnd.x;
			m_lineOutInfo_Gen[i].endPt.y = (IMG_REAL)m_lineOutInfo_Int[i].PointEnd.y;
			m_lineOutInfo_Gen[i].edgeType = FinalFittingResult[i].edgeType;
			m_lineOutInfo_Int[i].Score = FinalFittingResult[i].Score;
			m_lineOutInfo_Int[i].Slope = -m_lineOutInfo_Gen[i].a / (m_lineOutInfo_Gen[i].b + 1e-10);
			m_lineOutInfo_Int[i].b = -m_lineOutInfo_Gen[i].c / m_lineOutInfo_Gen[i].b;
			//m_lineOutInfo_Int[i].straightness = m_lineOutInfo_Gen[i].straightness;
			m_lineOutInfo_Int[i].EdgeGradient = FinalFittingResult[i].EdgeGradient;
			m_lineOutInfo_Int[i].houghScore = FinalFittingResult[i].houghScore;
			m_lineOutInfo_Int[i].FittingScore = FinalFittingResult[i].FittingScore;
			m_lineOutInfo_Int[i].edgeType= FinalFittingResult[i].edgeType;
			m_lineOutInfo_Int[i].CenterAvgGrayLevel = FinalFittingResult[i].CenterAvgGrayLevel;
			m_lineOutInfo_Int[i].LeftAvgGrayLevel = FinalFittingResult[i].LeftAvgGrayLevel;
			m_lineOutInfo_Int[i].RightAvgGrayLevel = FinalFittingResult[i].RightAvgGrayLevel;
			m_lineOutInfo_Int[i].id = FinalFittingResult[i].id;
		}
		IMG_RCOORD SrcPoint = { 0.f, 0.f }; IMG_RCOORD tempPt;
		IMG_INT pointNums = edgeNums;
		vector<IMG_RCOORD>SrcEdgePoints;
	
		if (finalLineNums == 1)
		{
			float Denominator = pow(FinalFittingResult[0].Slope*FinalFittingResult[0].Slope + 1, 0.5);
			for (int i = 0; i < pointNums; i++)
			{
				float a = abs(FinalFittingResult[0].Slope*pEdgeDetecResult[i].xyDecimal.x - pEdgeDetecResult[i].xyDecimal.y + FinalFittingResult[0].b) / Denominator;
				if (a <= m_ScoreAcceptDistance)
				{
					ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, pEdgeDetecResult[i].xyDecimal, tempPt);
					SrcPoint.x = tempPt.x+m_ROI.coWindowOff.x; SrcPoint.y = tempPt.y+m_ROI.coWindowOff.y;
					SrcEdgePoints.push_back(SrcPoint);
				}
			}
		}
		else
		{
			for (int i = 0; i < pointNums; i++)
			{
				ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, pEdgeDetecResult[i].xyDecimal, tempPt);
				SrcPoint.x = (float)tempPt.x+m_ROI.coWindowOff.x; SrcPoint.y = (float)tempPt.y+m_ROI.coWindowOff.y;
				SrcEdgePoints.push_back(SrcPoint);
			}
		}
		
		m_ptNums = SrcEdgePoints.size();
		m_SrcEdgePoints = new IMG_RCOORD[m_ptNums];
		for (int i = 0; i < m_ptNums; i++)
		{
			m_SrcEdgePoints[i] = SrcEdgePoints[i];
		}
		SrcEdgePoints.clear();
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after Coordinate translate%d\n", finalLineNums);
		OutputLineTable(m_lineOutInfo_Int , finalLineNums, "Coordinate Translate");
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("output_edge");
	}

	ippsFree(pubbDst.ptr);
	if (pEdgeDetecResult)
	{
		delete[]pEdgeDetecResult;
		pEdgeDetecResult = nullptr;
	}
	if (HoughResult)
	{
		delete[]HoughResult;
		HoughResult = nullptr;
	}
	if (HoughResult_Slope)
	{
		delete[]HoughResult_Slope;
		HoughResult_Slope = nullptr;
	}
	if (FirstFittingResult)
	{
		delete[]FirstFittingResult;
		FirstFittingResult = nullptr;
	}
	if (FinalFittingResult)
	{
		delete[]FinalFittingResult;
		FinalFittingResult = nullptr;
	}
	if (pMaskRTS)
	{
		ippsFree(pMaskRTS->ptr);
		delete[]pMaskRTS;
		pMaskRTS = nullptr;
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("LineDetect(GAUGE) Finish");
	}
	return RUN_OK;
}

void CVisLine::GetLineAvgGray(IMG_UBBUF *pubSrc, IMG_UBBUF *pubMask, LINE_INFO2D *pstList, IMG_INT num_line, IMG_REAL rLineWidth)
{
	IMG_INT i, x ,y, center_num, left_num, right_num;
	IMG_REAL left, right, center, step;
	IMG_REAL angle,b,l;
	IMG_RCOORD pt, pt2;
	for (i = 0; i < num_line; i++)
	{
		//j = 0;
		l = ALIGN_DIST(pstList[i].PointStart, pstList[i].PointEnd);
		angle = atan2(pstList[i].PointEnd.y - pstList[i].PointStart.y, pstList->PointEnd.x - pstList->PointStart.x);
		center_num = left_num = right_num = 0;
		left = right = center = 0;
		for (step=0;step<l;step+= m_fStep)
		{
			pt.x = pstList[i].PointStart.x + step*cos(angle);
			pt.y = pstList[i].PointStart.y + step*sin(angle);
			if (pt.x < pubSrc->size.width-1 && pt.y < pubSrc->size.height-1 && pt.x >= 0 && pt.y >= 0)
			{
				x = (IMG_INT)pt.x;
				y = (IMG_INT)pt.y;
				if (pubMask == nullptr || pubMask->ptr[x + y*pubSrc->linestep])
				{
					center += pubSrc->ptr[x + y*pubSrc->linestep] * (y + 1 - pt.y) + pubSrc->ptr[x + (y + 1)*pubSrc->linestep] * (pt.y - y);
					center_num++;
					pt2.x = pt.x - sin(angle)*rLineWidth;
					pt2.y = pt.y - cos(angle)*rLineWidth;
					if (pt2.x < pubSrc->size.width - 1 && pt2.y < pubSrc->size.height - 1 && pt2.x >= 0 && pt2.y >= 0)
					{
						x = (IMG_INT)pt2.x;
						y = (IMG_INT)pt2.y;
						left += pubSrc->ptr[x + y*pubSrc->linestep] * (x + 1 - pt2.x) + pubSrc->ptr[x + (y + 1)*pubSrc->linestep] * (pt2.x - x);
						left_num++;
					}
					pt2.x = pt.x + sin(angle)*rLineWidth;
					pt2.y = pt.y + cos(angle)*rLineWidth;
					if (pt2.x < pubSrc->size.width - 1 && pt2.y < pubSrc->size.height - 1 && pt2.x >= 0 && pt2.y >= 0)
					{
						x = (IMG_INT)pt2.x;
						y = (IMG_INT)pt2.y;
						right += pubSrc->ptr[x + y*pubSrc->linestep] * (x + 1 - pt2.x) + pubSrc->ptr[x + (y + 1)*pubSrc->linestep] * (pt2.x - x);
						right_num++;
					}
				}
			}
		}
		pstList[i].CenterAvgGrayLevel = center / (center_num+1e-6f);
		pstList[i].LeftAvgGrayLevel = left / (left_num+1e-6f);
		pstList[i].RightAvgGrayLevel = right / (right_num + 1e-6f);

	}
}
IMG_INT  CVisLine::LineDetect_Sobel(const LINE_INPUT_PARA &LineInput, const EDGETYPE &edgeDirect, const SELECTIONMODE &select, const int &minAThreshold)
{
	//if ((m_edgeDir == EDGETYPE::BLACKCENTER || m_edgeDir == EDGETYPE::WHITECENTER) && m_SelectionMode == SELECTIONMODE::highscore)
	//{
	//	return RUN_ERROR;
	//}
	IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
	CVisMemPool pool;
	int runState = RUN_OK;
	IMG_UINT ulLineSearchLogIndex = g_LineLogIndex;
	IMG_UBBUF pubbDst; pubbDst.ptr = nullptr;
	IMG_WORD *pDst = nullptr;
	IMG_REAL *pAngle = nullptr;
	IMG_UBBUF *pMaskRTS = nullptr;
	RECTROI_LINE RoiStruct;
	IMG_LREAL sine, cose;
	//vector<EdgePointLine> EdgeDetecResult;
	EdgePointLine *EdgeDetecResult = nullptr; IMG_INT edgeNums;
	HOUGH_TRANS_INFO *HoughResult = nullptr; IMG_INT houghLineNums = 0;
	LINE_INFO2D *HoughResult_Slope = nullptr; 
	LINE_INFO2D *FirstFittingResult = nullptr; IMG_INT firstLineNums = 0;
	LINE_INFO2D *FinalFittingResult = nullptr; IMG_INT finalLineNums = 0;
	IMG_RCOORD rcoSelPtStart = m_selPtStart, rcoSelPtEnd = m_selPtEnd;
	IMG_INT i;

	IMG_INT status = VisRoiGnerate_StraightLine(LineInput, pubbDst, RoiStruct);
	if (status != 0)
	{
		if (pubbDst.ptr)
		{
			ippsFree(pubbDst.ptr);
		}
		runState = RUN_ERROR;
		return runState;
	}
	sine = sin(RoiStruct.RotationAngle);
	cose = cos(RoiStruct.RotationAngle);
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("LineDetect(SOBEL) Start");
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("ROI_Generate");
	}
	if(m_uwDebug && 513)
	{
		writeLog("ROI image");
		CVisImage roi(pubbDst);
		if(roi.Width()>JPG_SIZE_LIMITATION||roi.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROI.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROI.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);

		p = strrchr(pathname, '\\')-12;
		roi.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
	}

	
	IMG_RCOORD rcoROISrc;
	//centerInSrc.x = (IMG_REAL)-(cos(RoiStruct.RotationAngle) * RoiStruct.DstCenterCo.x - sin(RoiStruct.RotationAngle)* RoiStruct.DstCenterCo.y - RoiStruct.SrcCenterCo.x);
	//centerInSrc.y = (IMG_REAL)(-sin(RoiStruct.RotationAngle) * RoiStruct.DstCenterCo.x - cos(RoiStruct.RotationAngle)* RoiStruct.DstCenterCo.y + RoiStruct.SrcCenterCo.y);
	//if (rcoSelPtStart.x + 1.f < 1e-6&&rcoSelPtStart.y + 1.f < 1e-6&&rcoSelPtEnd.x + 1.f < 1e-6&&rcoSelPtEnd.y + 1.f < 1e-6)
	//{
	//	if (m_scanDir == RECTSCANDIR::RIGHTHAND)
	//	{
	//		rcoSelPtStart.x = 0.f; rcoSelPtStart.y = 0;
	//		rcoSelPtEnd.x = (RoiStruct.RectangleSize.width - 1); rcoSelPtEnd.y = 0;
	//	}
	//	else
	//	{
	//		rcoSelPtStart.x = 0.f; rcoSelPtStart.y = RoiStruct.RectangleSize.height - 1;
	//		rcoSelPtEnd.x = RoiStruct.RectangleSize.width - 1; rcoSelPtEnd.y = RoiStruct.RectangleSize.height - 1;
	//	}
	//}
	//else
	//{
	//	IMG_RCOORD tempPt;
	//	CoorConvert_Negative(centerInSrc, RoiStruct.RotationAngle, rcoSelPtStart, tempPt);
	//	rcoSelPtStart = tempPt;
	//	CoorConvert_Negative(centerInSrc, RoiStruct.RotationAngle, rcoSelPtEnd, tempPt);
	//	rcoSelPtEnd = tempPt;
	//}
	rcoROISrc = RoiStruct.SrcCenterCo;
	rcoROISrc.x += m_ROI.coWindowOff.x, rcoROISrc.y += m_ROI.coWindowOff.y;
	ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(-sine, cose, RoiStruct.DstCenterCo, rcoROISrc, m_selPtStart, rcoSelPtStart);
	ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(-sine, cose, RoiStruct.DstCenterCo, rcoROISrc, m_selPtEnd, rcoSelPtEnd);

	//if (m_edgeDir == EDGETYPE::BLACKCENTER || m_edgeDir == EDGETYPE::WHITECENTER)
	//{
	//	m_SelectionMode = SELECTIONMODE::all;
	//}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("Before_edge");
	}
	EdgeExtract_8uC1(LineInput.pSrc->size,RoiStruct, pubbDst, minAThreshold, pDst, pAngle, EdgeDetecResult, edgeNums);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("after_edge");
	}
	if(m_uwDebug & 4)
	{
		pool.Push();
		_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdge.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		FILE *fp = fopen(pathname, "wt");
		if(fp)
		{
			fprintf(fp, "num %d\n", edgeNums);
			fprintf(fp, "x\ty\tmag\tangle\n");
			for(int i = 0; i<edgeNums; i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", EdgeDetecResult[i].xyDecimal.x, EdgeDetecResult[i].xyDecimal.y, EdgeDetecResult[i].gradient, EdgeDetecResult[i].angle);
			fclose(fp);
		}
		p = strrchr(pathname, '\\')-12;
		HL_InsertObject(m_pHtmlLog, "EdgeList", p);
		writeLog("\n");
		IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums);
		VALIDATE_MALLOC(pt);
		for(int i = 0; i<edgeNums; i++)pt[i] = EdgeDetecResult[i].xyDecimal;
		writeLog("\nEdge Point total %d\n", edgeNums);
		CVisImage edge(pubbDst);
		edge.DrawPoint(pt, edgeNums, COLORS::Red);
		if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdge.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdge.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\')-12;
		edge.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
		pool.Pop();
	}
	if (LineInput.pMask != NULL)
	{
		pMaskRTS = new IMG_UBBUF;
		DSP_RTS_R_8uC1(*(LineInput.pMask), RoiStruct.SrcCenterCo, *pMaskRTS, RoiStruct.DstCenterCo, RoiStruct.RotationAngle, RoiStruct.RectangleSize);
		EdgeFilter(pMaskRTS, EdgeDetecResult, edgeNums);
		//delete pMaskRTS;
	}
	{
		//check ROI if ROI out of source image;
		IMG_RCOORD corner[4], src_pt[4];
		IMG_INT flag = IMG_FALSE;
		corner[0] = { 0,0 };
		corner[1] = { (IMG_REAL)(RoiStruct.RectangleSize.width - 1) ,0};
		corner[2] = { (IMG_REAL)(RoiStruct.RectangleSize.width - 1), (IMG_REAL)(RoiStruct.RectangleSize.height - 1) };
		corner[3] = { 0, (IMG_REAL)(RoiStruct.RectangleSize.height - 1) };
		for (i = 0; i < 4; i++)
		{
			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, corner[i], src_pt[i]);
			if (src_pt[i].x < 2 || src_pt[i].y< 2 || src_pt[i].x > m_LineInputPara.pSrc->size.width - 3 || src_pt[i].y > m_LineInputPara.pSrc->size.height - 3)
			{
				flag = IMG_TRUE;
			}
		}
		if (flag)
		{
			IMG_UINT CurrentEdgeNum = edgeNums;
			for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
			{
				ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, EdgeDetecResult[i].xyDecimal, src_pt[0]);

				if (src_pt[0].x < 2 || src_pt[0].y< 2 || src_pt[0].x > m_LineInputPara.pSrc->size.width - 3 || src_pt[0].y > m_LineInputPara.pSrc->size.height - 3)
				{
					EdgeDetecResult[i] = EdgeDetecResult[CurrentEdgeNum - 1];
					CurrentEdgeNum--;
					i--;
				}
			}
			edgeNums = CurrentEdgeNum;
		}
	}

	int breakNums = (int)(2.f*pubbDst.size.height / m_cEdge.GetGradKernal());
	//int lengthThre = m_iDelEdgeNums;
	if (m_bDelNoise)
	{
		DelLineNorse(EdgeDetecResult, edgeNums, breakNums);
	}

	if (m_uwDebug & 4)
	{
		pool.Push();
		_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeDelNorse.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		FILE *fp = fopen(pathname, "wt");
		if (fp)
		{
			fprintf(fp, "num %d\n", edgeNums);
			fprintf(fp, "x\ty\tmag\tangle\n");
			for (int i = 0; i<edgeNums; i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", EdgeDetecResult[i].xyDecimal.x, EdgeDetecResult[i].xyDecimal.y, EdgeDetecResult[i].gradient, EdgeDetecResult[i].angle);
			fclose(fp);
		}
		p = strrchr(pathname, '\\') - 12;
		HL_InsertObject(m_pHtmlLog, "EdgeListDelNorse", p);
		writeLog("\n");
		IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums);
		VALIDATE_MALLOC(pt);
		for (int i = 0; i<edgeNums; i++)pt[i] = EdgeDetecResult[i].xyDecimal;
		writeLog("\nEdge Point total %d\n", edgeNums);
		CVisImage edge(pubbDst);
		edge.DrawPoint(pt, edgeNums, COLORS::Red);
		if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeDelNorse.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeDelNorse.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\') - 12;
		edge.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
		pool.Pop();
	}
	if (edgeNums < 2)
	{
		if (pubbDst.ptr)
		{
			ippsFree(pubbDst.ptr);
		}
		runState = RUN_ERROR;
		return runState;
	}

	if (edgeDirect == EDGETYPE::BOTH || edgeDirect == EDGETYPE::BLACKCENTER || edgeDirect == EDGETYPE::WHITECENTER)
	{
		EdgePointLine *EdgeDetecResult1 = nullptr; IMG_INT edgeNums1 = edgeNums;
		EdgeDetecResult1 = new EdgePointLine[edgeNums1];
		EdgePointLine *EdgeDetecResult2 = nullptr; IMG_INT edgeNums2 = edgeNums;
		EdgeDetecResult2 = new EdgePointLine[edgeNums2];
		memcpy(EdgeDetecResult1, EdgeDetecResult, sizeof(EdgePointLine)*edgeNums);
		memcpy(EdgeDetecResult2, EdgeDetecResult, sizeof(EdgePointLine)*edgeNums);
		HOUGH_TRANS_INFO *HoughResult1 = nullptr; IMG_INT houghLineNums1 = 0;
		LINE_INFO2D *HoughResult_Slope1 = nullptr;
		HOUGH_TRANS_INFO *HoughResult2 = nullptr; IMG_INT houghLineNums2 = 0;
		LINE_INFO2D *HoughResult_Slope2 = nullptr;
		EDGEPOINT_FILTER(LineInput.PointStart, LineInput.PointEnd, m_scanDir, edgeDirect, EdgeDetecResult1, edgeNums1);
		EDGEPOINT_FILTER(LineInput.PointStart, LineInput.PointEnd, m_scanDir, edgeDirect, EdgeDetecResult2, edgeNums2,false);
		if (pDst)
			delete[]pDst;
		if (pAngle)
			delete[]pAngle;
		if (edgeNums1 == 0 && edgeNums2 == 0)
		{
			if (pubbDst.ptr)
			{
				ippsFree(pubbDst.ptr);
			}
			if (EdgeDetecResult1)
			{
				delete[]EdgeDetecResult1;
				EdgeDetecResult1 = nullptr;
			}
			if (EdgeDetecResult2)
			{
				delete[] EdgeDetecResult2;
				EdgeDetecResult2 = nullptr;
			}
			runState = RUN_ERROR;
			return runState;
		}

		if (m_uwDebug == ALIGN_DEBUG_TIME)
		{
			m_clock.Click("edge_filter");
		}
		if(m_uwDebug & 4)
		{
			pool.Push();
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter1.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			FILE *fp = fopen(pathname, "wt");
			if(fp)
			{
				fprintf(fp, "num %d\n", edgeNums1);
				fprintf(fp, "x\ty\tmag\tangle\n");
				for(int i = 0; i<edgeNums1; i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", EdgeDetecResult1[i].xyDecimal.x, EdgeDetecResult1[i].xyDecimal.y, EdgeDetecResult1[i].gradient, EdgeDetecResult1[i].angle);
				fclose(fp);
			}
			p = strrchr(pathname, '\\')-12;
			HL_InsertObject(m_pHtmlLog, "EdgeListAfterFilter1", p);
			writeLog("\n");
			IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums1);
			VALIDATE_MALLOC(pt);
			for(int i = 0; i<edgeNums1; i++)pt[i] = EdgeDetecResult1[i].xyDecimal;
			writeLog("\nEdge Point after filter total %d\n", edgeNums1);
			CVisImage edge(pubbDst);
			edge.DrawPoint(pt, edgeNums1, COLORS::Red);
			if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
				_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter1.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			else
				_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter1.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			p = strrchr(pathname, '\\')-12;
			edge.WriteImage(pathname);
			HL_InsertImage(m_pHtmlLog, p);
			writeLog("\n");
			pool.Pop();
		}
		if (m_uwDebug & 4)
		{
			pool.Push();
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter2.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			FILE *fp = fopen(pathname, "wt");
			if (fp)
			{
				fprintf(fp, "num %d\n", edgeNums2);
				fprintf(fp, "x\ty\tmag\tangle\n");
				for (int i = 0; i < edgeNums2; i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", EdgeDetecResult2[i].xyDecimal.x, EdgeDetecResult2[i].xyDecimal.y, EdgeDetecResult2[i].gradient, EdgeDetecResult2[i].angle);
				fclose(fp);
			}
			p = strrchr(pathname, '\\') - 12;
			HL_InsertObject(m_pHtmlLog, "EdgeListAfterFilter2", p);
			writeLog("\n");
			IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums2);
			VALIDATE_MALLOC(pt);
			for (int i = 0; i < edgeNums2; i++)pt[i] = EdgeDetecResult2[i].xyDecimal;
			writeLog("\nEdge Point after filter total %d\n", edgeNums2);
			CVisImage edge(pubbDst);
			edge.DrawPoint(pt, edgeNums2, COLORS::Red);
			if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
				_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter2.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			else
				_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter2.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			p = strrchr(pathname, '\\') - 12;
			edge.WriteImage(pathname);
			HL_InsertImage(m_pHtmlLog, p);
			writeLog("\n");
			pool.Pop();
		}
		if (edgeNums1 == 0 && edgeNums2 == 0)
		{
			if (pubbDst.ptr)
			{
				ippsFree(pubbDst.ptr);
			}
			if (EdgeDetecResult1)
			{
				delete[]EdgeDetecResult1;
				EdgeDetecResult1 = nullptr;
			}
			if (EdgeDetecResult2)
			{
				delete[]EdgeDetecResult2;
				EdgeDetecResult2 = nullptr;
			}
			if (pMaskRTS)
			{
				delete[]pMaskRTS;
				pMaskRTS = nullptr;
			}
			runState = RUN_ERROR;
			return runState;
		}

		HoughTransLine(RoiStruct.RectangleSize, HoughResult1, HoughResult_Slope1, houghLineNums1, EdgeDetecResult1, edgeNums1, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol, 0);
		for (int i = 0; i < houghLineNums1; i++)HoughResult_Slope1[i].edgeType = EDGETYPE::LIGHT2DARK;
		HoughTransLine(RoiStruct.RectangleSize, HoughResult2, HoughResult_Slope2, houghLineNums2, EdgeDetecResult2, edgeNums2, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol, 1);
		for (int i = 0; i < houghLineNums2; i++)HoughResult_Slope2[i].edgeType = EDGETYPE::DARK2LIGHT;
		//EdgePointLine *EdgeDetecResult = nullptr; 
		edgeNums = edgeNums1 + edgeNums2;
		//HOUGH_TRANS_INFO *HoughResult = nullptr; 
		houghLineNums = houghLineNums1 + houghLineNums2;
		//LINE_INFO2D *HoughResult_Slope = nullptr;
		EdgeDetecResult = new EdgePointLine[edgeNums]; memset(EdgeDetecResult, 0, sizeof(EdgePointLine)*edgeNums);
		HoughResult = new HOUGH_TRANS_INFO[houghLineNums]; HoughResult_Slope = new LINE_INFO2D[houghLineNums];
		memset(HoughResult, 0, sizeof(HOUGH_TRANS_INFO)*houghLineNums); memset(HoughResult_Slope, 0, sizeof(LINE_INFO2D)*houghLineNums);
		if (edgeNums1 != 0)
		{
			if (edgeNums2 == 0)
			{
				memcpy(EdgeDetecResult, EdgeDetecResult1, sizeof(EdgePointLine)*edgeNums1);
				if (houghLineNums1 != 0)
				{
					memcpy(HoughResult, HoughResult1, sizeof(HOUGH_TRANS_INFO)*houghLineNums1);
					memcpy(HoughResult_Slope, HoughResult_Slope1, sizeof(LINE_INFO2D)*houghLineNums1);
				}
			}
			else
			{
				memcpy(EdgeDetecResult, EdgeDetecResult1, sizeof(EdgePointLine)*edgeNums1);

				if (houghLineNums1 != 0)
				{
					memcpy(HoughResult, HoughResult1, sizeof(HOUGH_TRANS_INFO)*houghLineNums1);
					memcpy(HoughResult_Slope, HoughResult_Slope1, sizeof(LINE_INFO2D)*houghLineNums1);
				}
				memcpy(EdgeDetecResult + edgeNums1 , EdgeDetecResult2, sizeof(EdgePointLine)*edgeNums2);
				if (houghLineNums2 != 0)
				{
					memcpy(HoughResult + houghLineNums1 , HoughResult2, sizeof(HOUGH_TRANS_INFO)*houghLineNums2);
					memcpy(HoughResult_Slope + houghLineNums1 , HoughResult_Slope2, sizeof(LINE_INFO2D)*houghLineNums2);
				}
				//for (int b = 0; b < edgeNums2; b++)
				//{
				//	EdgeDetecResult[b + edgeNums1] = EdgeDetecResult2[b];
				//}
				//for (int c = 0; c < houghLineNums2; c++)
				//{
				//	HoughResult[c + houghLineNums1] = HoughResult2[c];
				//	HoughResult_Slope[c + houghLineNums1] = HoughResult_Slope2[c];
				//}
			}
		}
		else
		{
			memcpy(EdgeDetecResult, EdgeDetecResult2, sizeof(EdgePointLine)*edgeNums);
			if (houghLineNums2 != 0)
			{
				memcpy(HoughResult, HoughResult2, sizeof(HOUGH_TRANS_INFO)*houghLineNums2);
				memcpy(HoughResult_Slope, HoughResult_Slope2, sizeof(LINE_INFO2D)*houghLineNums2);
			}
		}

		if (EdgeDetecResult1)
		{
			delete[] EdgeDetecResult1;
			EdgeDetecResult1 = nullptr;
		}
		if (HoughResult1)
		{
			delete[] HoughResult1;
			HoughResult1 = nullptr;
		}
		if (HoughResult_Slope1)
		{
			delete[] HoughResult_Slope1;
			HoughResult_Slope1 = nullptr;
		}
		if (EdgeDetecResult2)
		{
			delete[] EdgeDetecResult2;
			EdgeDetecResult2 = nullptr;
		}
		if (HoughResult2)
		{
			delete[] HoughResult2;
			HoughResult2 = nullptr;
		}
		if (HoughResult_Slope2)
		{
			delete[] HoughResult_Slope2;
			HoughResult_Slope2 = nullptr;
		}
	}
	else
	{
		EDGEPOINT_FILTER(LineInput.PointStart, LineInput.PointEnd, m_scanDir, edgeDirect, EdgeDetecResult, edgeNums);
		if (pDst)
			delete[]pDst;
		if (pAngle)
			delete[]pAngle;
		if (edgeNums == 0 )
		{
			if (pubbDst.ptr)
			{
				ippsFree(pubbDst.ptr);
			}
			if (EdgeDetecResult)
			{
				delete[]EdgeDetecResult;
				EdgeDetecResult = nullptr;
			}
			runState = RUN_ERROR;
			return runState;
		}

		if (m_uwDebug == ALIGN_DEBUG_TIME)
		{
			m_clock.Click("edge_filter");
		}
		if (m_uwDebug & 4)
		{
			pool.Push();
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			FILE *fp = fopen(pathname, "wt");
			if (fp)
			{
				fprintf(fp, "num %d\n", edgeNums);
				fprintf(fp, "x\ty\tmag\tangle\n");
				for (int i = 0; i < edgeNums; i++)fprintf(fp, "%.3f\t%.3f\t%d\t%.3f\n", EdgeDetecResult[i].xyDecimal.x, EdgeDetecResult[i].xyDecimal.y, EdgeDetecResult[i].gradient, EdgeDetecResult[i].angle);
				fclose(fp);
			}
			p = strrchr(pathname, '\\') - 12;
			HL_InsertObject(m_pHtmlLog, "EdgeListAfterFilter", p);
			writeLog("\n");
			IMG_RCOORD *pt = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*edgeNums);
			VALIDATE_MALLOC(pt);
			for (int i = 0; i < edgeNums; i++)pt[i] = EdgeDetecResult[i].xyDecimal;
			writeLog("\nEdge Point after filter total %d\n", edgeNums);
			CVisImage edge(pubbDst);
			edge.DrawPoint(pt, edgeNums, COLORS::Red);
			if(edge.Width()>JPG_SIZE_LIMITATION||edge.Height()>JPG_SIZE_LIMITATION)
				_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			else
				_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uROIEdgeFilter.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
			p = strrchr(pathname, '\\') - 12;
			edge.WriteImage(pathname);
			HL_InsertImage(m_pHtmlLog, p);
			writeLog("\n");
			pool.Pop();
		}
		if (edgeNums == 0 )
		{
			if (pubbDst.ptr)
			{
				ippsFree(pubbDst.ptr);
			}
			if (EdgeDetecResult)
			{
				delete[]EdgeDetecResult;
				EdgeDetecResult = nullptr;
			}
			if (pMaskRTS)
			{
				delete[]pMaskRTS;
				pMaskRTS = nullptr;
			}
			runState = RUN_ERROR;
			return runState;
		}

		HoughTransLine(RoiStruct.RectangleSize, HoughResult, HoughResult_Slope, houghLineNums, EdgeDetecResult, edgeNums, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol, 0);
		if (m_edgeDir == EDGETYPE::DARK2LIGHT || m_edgeDir == EDGETYPE::LIGHT2DARK)
		{
			for (int i = 0; i < houghLineNums; i++)HoughResult_Slope[i].edgeType = m_edgeDir;
		}
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", houghLineNums);
		OutputLineTable(HoughResult_Slope, houghLineNums, "Hough Result");
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("hough");
	}
	if(m_uwDebug & 4)
	{
		_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uHoughResult.txt", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		FILE *fp = fopen(pathname, "wt");
		if(fp)
		{
			fprintf(fp, "num %d\n", houghLineNums);
			fprintf(fp, "startx\tstarty\tendx\tendy\tslop\tb\though_score\tscore\n");
			for(int i = 0; i<houghLineNums; i++)
				fprintf(fp, "%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n", 
					HoughResult_Slope[i].PointStart.x, HoughResult_Slope[i].PointStart.y, 
					HoughResult_Slope[i].PointEnd.x, HoughResult_Slope[i].PointEnd.y,
					HoughResult_Slope[i].Slope, HoughResult_Slope[i].b,
					HoughResult_Slope[i].houghScore, HoughResult_Slope[i].Score);
			fclose(fp);
		}
		p = strrchr(pathname, '\\')-12;
		HL_InsertObject(m_pHtmlLog, "HoughResult", p);
		writeLog("\n");
		writeLog("\nHought Result: %d\n", houghLineNums);
		CVisImage hough(pubbDst);
		for(int i = 0; i<houghLineNums; i++)
			hough.DrawLine(HoughResult_Slope[i].PointStart, HoughResult_Slope[i].PointEnd, COLORS::Green);
		if(hough.Width()>JPG_SIZE_LIMITATION||hough.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uHoughResult.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uHoughResult.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex);
		p = strrchr(pathname, '\\')-12;
		hough.WriteImage(pathname);
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Hough Line Num %d\n", houghLineNums);
		OutputLineTable(HoughResult_Slope, houghLineNums, "Hough Line Result");
	}
	LineFitting(FirstFittingResult, firstLineNums, HoughResult_Slope, houghLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, m_LineFittingPara.LineFittingSigma * 1.5, m_LineFittingPara.IteMaxTimes, m_LineFittingPara.ItePrecision);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", firstLineNums);
		OutputLineTable(FirstFittingResult, firstLineNums, "First Fitting Result");
	}	
	RejectOverlapLine(FirstFittingResult, firstLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, 0.7f);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("fitting1");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", firstLineNums);
		OutputLineTable(FirstFittingResult, firstLineNums, "First overlap reject Result");
	}
	LineFitting(FinalFittingResult, finalLineNums, FirstFittingResult, firstLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, m_LineFittingPara.LineFittingSigma, m_LineFittingPara.IteMaxTimes, m_LineFittingPara.ItePrecision);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Second Fitting Result");
	}
	RejectOverlapLine(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, 0.85f);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("fitting2");
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", firstLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "second overlap reject Result");
	}
	/*if (m_bDelNoise)
	{
		DelLineEdge(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums);
		if (edgeNums <= 2)
		{
			finalLineNums = 0;
		}
	}*/
	LineFinalResult(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, m_ScoreAcceptDistance);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("finnal_result");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Final Result");
	}
	RejectLineOutOfAngleRange(FinalFittingResult, finalLineNums, m_LineAngleRange);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "After out of Angle reject");
	}
	RejectLineOutOfLengthRange(FinalFittingResult, finalLineNums, m_MinLineLengthPercentOfROI);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "After out of min Length reject");
	}
	if (finalLineNums < 1)
	{
		ippsFree(pubbDst.ptr);
		if (EdgeDetecResult)
		{
			delete[]EdgeDetecResult;
			EdgeDetecResult = nullptr;
		}
		if (HoughResult)
		{
			delete[]HoughResult;
			HoughResult = nullptr;
		}
		if (HoughResult_Slope)
		{
			delete[]HoughResult_Slope;
			HoughResult_Slope = nullptr;
		}
		if (FirstFittingResult)
		{
			delete[]FirstFittingResult;
			FirstFittingResult = nullptr;
		}
		if (FinalFittingResult)
		{
			delete[]FinalFittingResult;
			FinalFittingResult = nullptr;
		}
		runState = RUN_ERROR;
		return runState;
	}
	if (LineInput.pMask != NULL) {
		ScoreInMask(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, pMaskRTS, m_ScoreAcceptDistance);
	}
	else
		Score(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, m_ScoreAcceptDistance);
	GetLineAvgGray(&pubbDst, pMaskRTS, FinalFittingResult, finalLineNums, m_ScoreAcceptDistance);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("score_cal");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after scoring %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Scoring");
	}
	IMG_REAL maxscore = 0;
	for (i = 0; i < finalLineNums; i++)
	{
		if (FinalFittingResult[i].Score > maxscore)maxscore = FinalFittingResult[i].Score;
	}
	if (m_AcceptanceScore > 0 && maxscore < m_AcceptanceScore)
	{
		if (m_bMustOutput)
		{
			for (i = 0; i < finalLineNums; i++)
			{
				if (FinalFittingResult[i].Score == maxscore)
				{
					FinalFittingResult[0] = FinalFittingResult[i];
					finalLineNums = 1;
					break;
				}
			}
		}
		else
		{
			finalLineNums = 0;
		}
	}
	else
	{
		for (i = 0; i < finalLineNums; i++)
		{
			if (m_AcceptanceScore > 0 && FinalFittingResult[i].Score < m_AcceptanceScore)
			{
				FinalFittingResult[i] = FinalFittingResult[finalLineNums - 1];
				finalLineNums--;
				i--;
			}
		}
	}
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Line Num %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "After score reject");
	}
	RejectOverlapLine(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, 1);
	if (m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after self-reject %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "final self-reject");
	}
	LineSelection(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, select, rcoSelPtStart, rcoSelPtEnd);
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("line_select");
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after Selection %d\n", finalLineNums);
		OutputLineTable(FinalFittingResult, finalLineNums, "Line Selection");
	}
	//IMG_REAL lineError;
	IMG_REAL Angle;
	if (finalLineNums != 0)
	{
		m_LineNum = finalLineNums;
		m_lineOutInfo_Gen = new IMG_LINE[finalLineNums];
		m_lineOutInfo_Int = new LINE_INFO2D[finalLineNums];
		memset(m_lineOutInfo_Int, 0, sizeof(LINE_INFO2D)*finalLineNums);
		//LineFitOutput.Line = (LINEAR_GENERNAL_EQUATION *)pool.PMalloc(sizeof(LINEAR_GENERNAL_EQUATION) * LineFitOutput.LineNumber);
		for (IMG_INT i = 0; i < finalLineNums; i++)
		{
			//lineError = LineError_KB(FinalFittingResult[i].Slope, FinalFittingResult[i].b, EdgeDetecResult);

			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, FinalFittingResult[i].PointStart, m_lineOutInfo_Int[i].PointStart);
			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, FinalFittingResult[i].PointEnd, m_lineOutInfo_Int[i].PointEnd);
			m_lineOutInfo_Int[i].PointStart.x += m_ROI.coWindowOff.x;
			m_lineOutInfo_Int[i].PointStart.y += m_ROI.coWindowOff.y;
			m_lineOutInfo_Int[i].PointEnd.x += m_ROI.coWindowOff.x;
			m_lineOutInfo_Int[i].PointEnd.y += m_ROI.coWindowOff.y;

			//Angle = atan2(m_lineOutInfo_Gen[i].PointEnd.x - m_lineOutInfo_Gen[i].PointStart.x, m_lineOutInfo_Gen[i].PointStart.y - m_lineOutInfo_Gen[i].PointEnd.y);
			Angle = atan2(m_lineOutInfo_Int[i].PointEnd.y - m_lineOutInfo_Int[i].PointStart.y, m_lineOutInfo_Int[i].PointEnd.x - m_lineOutInfo_Int[i].PointStart.x);

			m_lineOutInfo_Gen[i].a = (IMG_REAL)sin(Angle);
			m_lineOutInfo_Gen[i].b = -(IMG_REAL)cos(Angle);
			m_lineOutInfo_Gen[i].c = -(m_lineOutInfo_Int[i].PointEnd.x * m_lineOutInfo_Gen[i].a + m_lineOutInfo_Int[i].PointEnd.y * m_lineOutInfo_Gen[i].b);
			if (m_lineOutInfo_Gen[i].a < 0)
			{
				m_lineOutInfo_Gen[i].a = -m_lineOutInfo_Gen[i].a;
				m_lineOutInfo_Gen[i].b = -m_lineOutInfo_Gen[i].b;
				m_lineOutInfo_Gen[i].c = -m_lineOutInfo_Gen[i].c;
			}
			//m_lineOutInfo_Gen[i].Score = FinalFittingResult[i].Score;
			//LineFitOutput.Line[i].FittingScore = FinalFittingResult[i].FittingScore;
			//m_lineOutInfo_Gen[i].straightness = lineError;
			//m_lineOutInfo_Gen[i].EdgeGradient = FinalFittingResult[i].EdgeGradient;

			m_lineOutInfo_Gen[i].startPt.x = (IMG_REAL)m_lineOutInfo_Int[i].PointStart.x;
			m_lineOutInfo_Gen[i].startPt.y = (IMG_REAL)m_lineOutInfo_Int[i].PointStart.y;
			m_lineOutInfo_Gen[i].endPt.x = (IMG_REAL)m_lineOutInfo_Int[i].PointEnd.x;
			m_lineOutInfo_Gen[i].endPt.y = (IMG_REAL)m_lineOutInfo_Int[i].PointEnd.y;
			m_lineOutInfo_Int[i].Score = FinalFittingResult[i].Score;
			m_lineOutInfo_Int[i].Slope = -m_lineOutInfo_Gen[i].a / (m_lineOutInfo_Gen[i].b + 1e-10);
			m_lineOutInfo_Int[i].b = -m_lineOutInfo_Gen[i].c / m_lineOutInfo_Gen[i].b;
			//m_lineOutInfo_Int[i].straightness = m_lineOutInfo_Gen[i].straightness;
			m_lineOutInfo_Int[i].EdgeGradient = FinalFittingResult[i].EdgeGradient;
			m_lineOutInfo_Int[i].houghScore = FinalFittingResult[i].houghScore;
			m_lineOutInfo_Int[i].FittingScore = FinalFittingResult[i].FittingScore;
			m_lineOutInfo_Int[i].edgeType= FinalFittingResult[i].edgeType;
			m_lineOutInfo_Int[i].CenterAvgGrayLevel = FinalFittingResult[i].CenterAvgGrayLevel;
			m_lineOutInfo_Int[i].LeftAvgGrayLevel = FinalFittingResult[i].LeftAvgGrayLevel;
			m_lineOutInfo_Int[i].RightAvgGrayLevel = FinalFittingResult[i].RightAvgGrayLevel;
			m_lineOutInfo_Int[i].id = FinalFittingResult[i].id;
		}
		IMG_RCOORD SrcPoint = { 0.f, 0.f }; IMG_RCOORD tempPt;
		IMG_INT pointNums = edgeNums;
		vector<IMG_RCOORD>SrcEdgePoints;

		if (finalLineNums == 1)
		{
			float Denominator = pow(FinalFittingResult[0].Slope*FinalFittingResult[0].Slope + 1, 0.5);
			for (int i = 0; i < pointNums; i++)
			{
				float a = abs(FinalFittingResult[0].Slope*EdgeDetecResult[i].xyDecimal.x - EdgeDetecResult[i].xyDecimal.y + FinalFittingResult[0].b) / Denominator;
				if (a <= m_ScoreAcceptDistance)
				{
					ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, EdgeDetecResult[i].xyDecimal, tempPt);
					SrcPoint.x = tempPt.x+m_ROI.coWindowOff.x; SrcPoint.y = tempPt.y+m_ROI.coWindowOff.y;
					SrcEdgePoints.push_back(SrcPoint);
				}
			}
		}
		else
		{
			for (int i = 0; i < pointNums; i++)
			{
				ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, EdgeDetecResult[i].xyDecimal, tempPt);
				SrcPoint.x = (float)tempPt.x+m_ROI.coWindowOff.x; SrcPoint.y = (float)tempPt.y+m_ROI.coWindowOff.y;
				SrcEdgePoints.push_back(SrcPoint);
			}
		}

		m_ptNums = SrcEdgePoints.size();
		m_SrcEdgePoints = new IMG_RCOORD[m_ptNums];
		for (int i = 0; i < m_ptNums; i++)
		{
			m_SrcEdgePoints[i] = SrcEdgePoints[i];
		}
		SrcEdgePoints.clear();

	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("Final Line Num after Coordinate translate%d\n", finalLineNums);
		OutputLineTable(m_lineOutInfo_Int , finalLineNums, "Coordinate Translate");
	}
	if (m_uwDebug == ALIGN_DEBUG_TIME)
	{
		m_clock.Click("output_edge");
	}
	ippsFree(pubbDst.ptr);
	if (EdgeDetecResult)
	{
		delete[]EdgeDetecResult;
		EdgeDetecResult = nullptr;
	}
	if (HoughResult)
	{
		delete[]HoughResult;
		HoughResult = nullptr;
	}
	if (HoughResult_Slope)
	{
		delete[]HoughResult_Slope;
		HoughResult_Slope = nullptr;
	}
	if (FirstFittingResult)
	{
		delete[]FirstFittingResult;
		FirstFittingResult = nullptr;
	}
	if (FinalFittingResult)
	{
		delete[]FinalFittingResult;
		FinalFittingResult = nullptr;
	}
	if (pMaskRTS)
	{
		delete[]pMaskRTS;
		pMaskRTS = nullptr;
	}
	if(m_uwDebug & ALIGN_DEBUG_NORMAL)
	{
		writeLog("LineDetect(SOBEL) End");
	}
	return RUN_OK;
}

//IMG_INT  CVisLine::ParallelLineDetect(const LINE_INPUT_PARA &LineInput, const EDGETYPE &edgeDirect, const SELECTIONMODE &select, const int &minAThreshold)
//{
//	if ((m_edgeDir == EDGETYPE::BLACKCENTER || m_edgeDir == EDGETYPE::WHITECENTER) && m_SelectionMode == SELECTIONMODE::highscore)
//	{
//		return RUN_ERROR;
//	}
//
//	int runState = RUN_OK;
//	IMG_UBBUF prbDst; prbDst.ptr = nullptr;
//	IMG_WORD *pDst = nullptr;
//	IMG_REAL *pAngle = nullptr;
//	IMG_UBBUF *pMaskRTS = nullptr;
//	RECTROI_LINE RoiStruct;
//	//vector<EdgePointLine> EdgeDetecResult;
//	EdgePointLine *EdgeDetecResult = nullptr; IMG_INT edgeNums;
//	HOUGH_TRANS_INFO *HoughResult = nullptr; IMG_INT houghLineNums = 0;
//	LINE_INFO2D *HoughResult_Slope = nullptr;
//	LINE_INFO2D *FirstFittingResult = nullptr; IMG_INT firstLineNums = 0;
//	LINE_INFO2D *FinalFittingResult = nullptr; IMG_INT finalLineNums = 0;
//
//	IMG_INT status = VisRoiGnerate_StraightLine(LineInput, prbDst, RoiStruct);
//	if (status != 0)
//	{
//		if (prbDst.ptr)
//		{
//			ippsFree(prbDst.ptr);
//		}
//		runState = RUN_ERROR;
//		return runState;
//	}
//
//	IMG_RCOORD centerInSrc;
//	centerInSrc.x = (IMG_REAL)-(cos(RoiStruct.RotationAngle) * RoiStruct.DstCenterCo.x - sin(RoiStruct.RotationAngle)* RoiStruct.DstCenterCo.y - RoiStruct.SrcCenterCo.x);
//	centerInSrc.y = (IMG_REAL)(-sin(RoiStruct.RotationAngle) * RoiStruct.DstCenterCo.x - cos(RoiStruct.RotationAngle)* RoiStruct.DstCenterCo.y + RoiStruct.SrcCenterCo.y);
//	if (rcoSelPtStart.x + 1.f < 1e-6&&rcoSelPtStart.y + 1.f < 1e-6&&rcoSelPtEnd.x + 1.f < 1e-6&&rcoSelPtEnd.y + 1.f < 1e-6)
//	{
//		if (m_scanDir == RECTSCANDIR::RIGHTHAND)
//		{
//			rcoSelPtStart.x = 0.f; rcoSelPtStart.y = 0;
//			rcoSelPtEnd.x = (RoiStruct.RectangleSize.width - 1); rcoSelPtEnd.y = 0;
//		}
//		else
//		{
//			rcoSelPtStart.x = 0.f; rcoSelPtStart.y = RoiStruct.RectangleSize.height - 1;
//			rcoSelPtEnd.x = RoiStruct.RectangleSize.width - 1; rcoSelPtEnd.y = RoiStruct.RectangleSize.height - 1;
//		}
//	}
//	else
//	{
//		IMG_RCOORD tempPt;
//		CoorConvert_Negative(centerInSrc, RoiStruct.RotationAngle, rcoSelPtStart, tempPt);
//		rcoSelPtStart = tempPt;
//		CoorConvert_Negative(centerInSrc, RoiStruct.RotationAngle, rcoSelPtEnd, tempPt);
//		rcoSelPtEnd = tempPt;
//	}
//	//if (m_edgeDir == EDGETYPE::BLACKCENTER || m_edgeDir == EDGETYPE::WHITECENTER)
//	//{
//	//	m_SelectionMode = SELECTIONMODE::all;
//	//}
//	EdgeExtract_8uC1(LineInput.pSrc->size, RoiStruct, prbDst, minAThreshold, pDst, pAngle, EdgeDetecResult, edgeNums);
//	EDGEPOINT_FILTER(LineInput.PointStart, LineInput.PointEnd, m_scanDir, edgeDirect, EdgeDetecResult, edgeNums);
//	if (pDst)
//		delete[]pDst;
//	if (pAngle)
//		delete[]pAngle;
//	if (edgeNums == 0)
//	{
//		if (prbDst.ptr)
//		{
//			ippsFree(prbDst.ptr);
//		}
//		if (EdgeDetecResult)
//		{
//			delete[]EdgeDetecResult;
//			EdgeDetecResult = nullptr;
//		}
//		runState = RUN_ERROR;
//		return runState;
//	}
//
//	if (LineInput.pMask != NULL)
//	{
//		pMaskRTS = new IMG_UBBUF;
//		DSP_RTS_R_8uC1(*(LineInput.pMask), RoiStruct.SrcCenterCo, *pMaskRTS, RoiStruct.DstCenterCo, RoiStruct.RotationAngle, RoiStruct.RectangleSize);
//		EdgeFilter(pMaskRTS, EdgeDetecResult, edgeNums);
//		//delete pMaskRTS;
//	}
//	if (edgeNums == 0)
//	{
//		if (prbDst.ptr)
//		{
//			ippsFree(prbDst.ptr);
//		}
//		if (EdgeDetecResult)
//		{
//			delete[]EdgeDetecResult;
//			EdgeDetecResult = nullptr;
//		}
//		if (pMaskRTS)
//		{
//			delete[]pMaskRTS;
//			pMaskRTS = nullptr;
//		}
//		runState = RUN_ERROR;
//		return runState;
//	}
//
//	HoughTransLine(RoiStruct.RectangleSize, HoughResult, HoughResult_Slope, houghLineNums, EdgeDetecResult, edgeNums, m_HoughLinePara.HoughAcceptScore, m_HoughLinePara.HoughAngleTol);
//	LineFitting(FirstFittingResult, firstLineNums, HoughResult_Slope, houghLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, m_LineFittingPara.LineFittingSigma * 1.5, m_LineFittingPara.IteMaxTimes, m_LineFittingPara.ItePrecision);
//	LineFitting(FinalFittingResult, finalLineNums, FirstFittingResult, firstLineNums, EdgeDetecResult, edgeNums, RoiStruct.RectangleSize, m_LineFittingPara.LineFittingSigma, m_LineFittingPara.IteMaxTimes, m_LineFittingPara.ItePrecision);
//	LineFinalResult(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, m_ScoreAcceptDistance);
//	if (finalLineNums < 1)
//	{
//		ippsFree(prbDst.ptr);
//		if (EdgeDetecResult)
//		{
//			delete[]EdgeDetecResult;
//			EdgeDetecResult = nullptr;
//		}
//		if (HoughResult)
//		{
//			delete[]HoughResult;
//			HoughResult = nullptr;
//		}
//		if (HoughResult_Slope)
//		{
//			delete[]HoughResult_Slope;
//			HoughResult_Slope = nullptr;
//		}
//		if (FirstFittingResult)
//		{
//			delete[]FirstFittingResult;
//			FirstFittingResult = nullptr;
//		}
//		if (FinalFittingResult)
//		{
//			delete[]FinalFittingResult;
//			FinalFittingResult = nullptr;
//		}
//		if (pMaskRTS)
//		{
//			delete[]pMaskRTS;
//			pMaskRTS = nullptr;
//		}
//		runState = RUN_ERROR;
//		return runState;
//	}
//	if (LineInput.pMask != NULL) {
//		ScoreInMask(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, pMaskRTS, m_ScoreAcceptDistance);
//		if (pMaskRTS)
//		{
//			delete[]pMaskRTS;
//			pMaskRTS = nullptr;
//		}
//	}
//	else
//		Score(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, m_ScoreAcceptDistance);
//
//	LineSelection(FinalFittingResult, finalLineNums, EdgeDetecResult, edgeNums, select);
//	//IMG_REAL lineError;
//	IMG_REAL Angle;
//
//	if (finalLineNums != 2)
//	{
//		runState = RUN_ERROR;
//		return runState;
//	}
//	else
//	{
//		vector<IMG_RCOORD> tempPt0, tempPt1;
//		float Denominator0 = (float)pow(FinalFittingResult[0].Slope * FinalFittingResult[0].Slope + 1, 0.5);
//		float Denominator1 = (float)pow(FinalFittingResult[1].Slope * FinalFittingResult[1].Slope + 1, 0.5);
//		float disTemp0, disTemp1;
//		IMG_RCOORD tempt;
//		for (int i = 0; i < edgeNums; i++)
//		{
//			disTemp0 = abs(FinalFittingResult[0].Slope * EdgeDetecResult[i].xyDecimal.x - EdgeDetecResult[i].xyDecimal.y + FinalFittingResult[0].b) / Denominator0;
//			disTemp1 = abs(FinalFittingResult[1].Slope * EdgeDetecResult[i].xyDecimal.x - EdgeDetecResult[i].xyDecimal.y + FinalFittingResult[1].b) / Denominator1;
//			if (disTemp0 <= m_ScoreAcceptDistance)
//			{
//				tempPt0.push_back(EdgeDetecResult[i].xyDecimal);
//			}
//			if (disTemp1 <= m_ScoreAcceptDistance)
//			{
//				tempPt1.push_back(EdgeDetecResult[i].xyDecimal);
//			}
//		}
//		IMG_REAL kTemp, bTemp0, bTemp1;
//		kTemp = FinalFittingResult[0].Slope;
//		bTemp0 = FinalFittingResult[0].b;
//		bTemp1 = FinalFittingResult[1].b;
//		ParallellFitting(kTemp, bTemp0, bTemp1, tempPt0, tempPt1, 1.5, 25, 0.0001);
//		m_paraLineNum = 1;
//		m_paraLine = new IMG_ParallelLINE[m_paraLineNum];
//		IMG_ParallelLINE paraLine;
//		paraLine.startPt1.x = FinalFittingResult[0].PointStart.x; paraLine.startPt1.y = kTemp*paraLine.startPt1.x + bTemp0;
//		paraLine.endPt1.x = FinalFittingResult[0].PointEnd.x; paraLine.endPt1.y = kTemp*paraLine.endPt1.x + bTemp0;
//		paraLine.startPt2.x = FinalFittingResult[1].PointStart.x; paraLine.startPt2.y = kTemp*paraLine.startPt2.x + bTemp1;
//		paraLine.endPt2.x = FinalFittingResult[1].PointEnd.x; paraLine.endPt2.y = kTemp*paraLine.endPt2.x + bTemp1;
//
//		ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, paraLine.startPt1, m_paraLine[0].startPt1);
//		ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, paraLine.startPt2, m_paraLine[0].startPt2);
//		ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, paraLine.endPt1, m_paraLine[0].endPt1);
//		ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, paraLine.endPt2, m_paraLine[0].endPt2);
//
//		Angle = atan2(m_paraLine[0].endPt1.y - m_paraLine[0].startPt1.y, m_paraLine[0].endPt1.x - m_paraLine[0].startPt1.x);
//		m_paraLine[0].a = (IMG_REAL)sin(Angle);
//		m_paraLine[0].b = -(IMG_REAL)cos(Angle);
//		m_paraLine[0].c1 = -(m_paraLine[0].endPt1.x * m_paraLine[0].a + m_paraLine[0].endPt1.y * m_paraLine[0].b);
//		m_paraLine[0].c2 = -(m_paraLine[0].endPt2.x * m_paraLine[0].a + m_paraLine[0].endPt2.y * m_paraLine[0].b);
//		if (m_paraLine[0].a < 0)
//		{
//			m_paraLine[0].a = -m_paraLine[0].a;
//			m_paraLine[0].b = -m_paraLine[0].b;
//			m_paraLine[0].c1 = -m_paraLine[0].c1;
//			m_paraLine[0].c2 = -m_paraLine[0].c2;
//		}
//		tempPt0.clear(); tempPt1.clear();
//	}
//	//if (finalLineNums != 0)
//	//{
//	//	m_LineNum = finalLineNums;
//	//	m_lineOutInfo_Gen = new IMG_LINE[finalLineNums];
//	//	m_lineOutInfo_Int = new LINE_INFO2D[finalLineNums];
//	//	//LineFitOutput.Line = (LINEAR_GENERNAL_EQUATION *)pool.PMalloc(sizeof(LINEAR_GENERNAL_EQUATION) * LineFitOutput.LineNumber);
//	//	for (IMG_INT i = 0; i < finalLineNums; i++)
//	//	{
//	//		//lineError = LineError_KB(FinalFittingResult[i].Slope, FinalFittingResult[i].b, EdgeDetecResult);
//
//	//		ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, FinalFittingResult[i].PointStart, m_lineOutInfo_Int[i].PointStart);
//	//		ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, FinalFittingResult[i].PointEnd, m_lineOutInfo_Int[i].PointEnd);
//
//	//		//Angle = atan2(m_lineOutInfo_Gen[i].PointEnd.x - m_lineOutInfo_Gen[i].PointStart.x, m_lineOutInfo_Gen[i].PointStart.y - m_lineOutInfo_Gen[i].PointEnd.y);
//	//		Angle = atan2(m_lineOutInfo_Int[i].PointEnd.y - m_lineOutInfo_Int[i].PointStart.y, m_lineOutInfo_Int[i].PointEnd.x - m_lineOutInfo_Int[i].PointStart.x);
//
//	//		m_lineOutInfo_Gen[i].a = (IMG_REAL)sin(Angle);
//	//		m_lineOutInfo_Gen[i].b = -(IMG_REAL)cos(Angle);
//	//		m_lineOutInfo_Gen[i].c = -(m_lineOutInfo_Int[i].PointEnd.x * m_lineOutInfo_Gen[i].a + m_lineOutInfo_Int[i].PointEnd.y * m_lineOutInfo_Gen[i].b);
//	//		if (m_lineOutInfo_Gen[i].a < 0)
//	//		{
//	//			m_lineOutInfo_Gen[i].a = -m_lineOutInfo_Gen[i].a;
//	//			m_lineOutInfo_Gen[i].b = -m_lineOutInfo_Gen[i].b;
//	//			m_lineOutInfo_Gen[i].c = -m_lineOutInfo_Gen[i].c;
//	//		}
//	//		//m_lineOutInfo_Gen[i].Score = FinalFittingResult[i].Score;
//	//		//LineFitOutput.Line[i].FittingScore = FinalFittingResult[i].FittingScore;
//	//		//m_lineOutInfo_Gen[i].straightness = lineError;
//	//		//m_lineOutInfo_Gen[i].EdgeGradient = FinalFittingResult[i].EdgeGradient;
//
//	//		m_lineOutInfo_Gen[i].startPt.x = (IMG_REAL)m_lineOutInfo_Int[i].PointStart.x;
//	//		m_lineOutInfo_Gen[i].startPt.y = (IMG_REAL)m_lineOutInfo_Int[i].PointStart.y;
//	//		m_lineOutInfo_Gen[i].endPt.x = (IMG_REAL)m_lineOutInfo_Int[i].PointEnd.x;
//	//		m_lineOutInfo_Gen[i].endPt.y = (IMG_REAL)m_lineOutInfo_Int[i].PointEnd.y;
//	//		m_lineOutInfo_Gen[i].edgeType = FinalFittingResult[i].edgeType;
//
//	//		m_lineOutInfo_Int[i].Score = FinalFittingResult[i].Score;
//	//		m_lineOutInfo_Int[i].Slope = -m_lineOutInfo_Gen[i].a / m_lineOutInfo_Gen[i].b;
//	//		m_lineOutInfo_Int[i].b = -m_lineOutInfo_Gen[i].c / m_lineOutInfo_Gen[i].b;
//	//		//m_lineOutInfo_Int[i].straightness = m_lineOutInfo_Gen[i].straightness;
//	//		m_lineOutInfo_Int[i].EdgeGradient = FinalFittingResult[i].EdgeGradient;
//	//	}
//	//	IMG_RCOORD SrcPoint = { 0.f, 0.f }; IMG_RCOORD tempPt;
//	//	IMG_INT pointNums = edgeNums;
//	//	vector<IMG_RCOORD>SrcEdgePoints;
//	//	if (m_IsParallelLineCheck)
//	//	{
//	//		if (finalLineNums == 1)
//	//		{
//	//			float Denominator = pow(FinalFittingResult[0].Slope*FinalFittingResult[0].Slope + 1, 0.5);
//	//			for (int i = 0; i < pointNums; i++)
//	//			{
//	//				float a = abs(FinalFittingResult[0].Slope*EdgeDetecResult[i].xyDecimal.x - EdgeDetecResult[i].xyDecimal.y + FinalFittingResult[0].b) / Denominator;
//	//				if (a <= m_ScoreAcceptDistance)
//	//				{
//	//					ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, EdgeDetecResult[i].xyDecimal, tempPt);
//	//					SrcPoint.x = tempPt.x; SrcPoint.y = tempPt.y;
//	//					SrcEdgePoints.push_back(SrcPoint);
//	//				}
//	//			}
//	//		}
//	//		else
//	//		{
//	//			for (int i = 0; i < pointNums; i++)
//	//			{
//	//				ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(RoiStruct.RotationAngle, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, EdgeDetecResult[i].xyDecimal, tempPt);
//	//				SrcPoint.x = (float)tempPt.x; SrcPoint.y = (float)tempPt.y;
//	//				SrcEdgePoints.push_back(SrcPoint);
//	//			}
//	//		}
//	//	}
//	//	m_ptNums = SrcEdgePoints.size();
//	//	m_SrcEdgePoints = new IMG_RCOORD[m_ptNums];
//	//	for (int i = 0; i < m_ptNums; i++)
//	//	{
//	//		m_SrcEdgePoints[i] = SrcEdgePoints[i];
//	//	}
//	//	SrcEdgePoints.clear();
//	//}
//
//	ippsFree(prbDst.ptr);
//	if (EdgeDetecResult)
//	{
//		delete[]EdgeDetecResult;
//		EdgeDetecResult = nullptr;
//	}
//	if (HoughResult)
//	{
//		delete[]HoughResult;
//		HoughResult = nullptr;
//	}
//	if (HoughResult_Slope)
//	{
//		delete[]HoughResult_Slope;
//		HoughResult_Slope = nullptr;
//	}
//	if (FirstFittingResult)
//	{
//		delete[]FirstFittingResult;
//		FirstFittingResult = nullptr;
//	}
//	if (FinalFittingResult)
//	{
//		delete[]FinalFittingResult;
//		FinalFittingResult = nullptr;
//	}
//	return RUN_OK;
//}

//#pragma CVisLine::PrivateFunction

IMG_INT  CVisLine::VisRoiGnerate_StraightLine(const LINE_INPUT_PARA &LineInput, IMG_UBBUF &pubDst, RECTROI_LINE &RoiStruct)
{
	if (LineInput.NormalVari < 0)
		return -1;

	IMG_INT Count;

	Count = ROI_HORIZONTAL_ROTATION(*LineInput.pSrc, LineInput.PointStart, LineInput.PointEnd, LineInput.NormalVari, RoiStruct, pubDst);
	if (Count == 0)
		return 0;
	else
		return -1;
}

IMG_INT CVisLine::ROI_HORIZONTAL_ROTATION(const IMG_UBBUF &pSrc, const IMG_RCOORD &PointStart, const IMG_RCOORD &PointEnd, const IMG_REAL &NormalVari, 
	RECTROI_LINE &RoiStruct, IMG_UBBUF &pubDst)
{
	IMG_REAL rAngle;
	IMG_RCOORD prcoSrcCenter, prcoDstCenter;

	IMG_SIZE pszOp;
	IMG_INT DisPoint;

	if (PointEnd.y == PointStart.y && PointEnd.x == PointStart.x)
		return -1;

	rAngle = (IMG_REAL)atan2((PointEnd.y - PointStart.y), (PointEnd.x - PointStart.x));

	prcoSrcCenter.x = (PointEnd.x + PointStart.x) / 2.f;
	prcoSrcCenter.y = (PointEnd.y + PointStart.y) / 2.f;
	DisPoint = (IMG_INT)ceil(sqrt(pow(PointEnd.y - PointStart.y, 2) + pow(PointEnd.x - PointStart.x, 2)));
	pszOp.width = DisPoint;
	pszOp.height = (1 + NormalVari * 2);
	prcoDstCenter.x = (pszOp.width - 1) / 2;
	prcoDstCenter.y = (pszOp.height - 1) / 2;

	//step: RTS 反旋转平移
	//pubDst.ptr = (IMG_UBYTE*)malloc(sizeof(IMG_UBYTE) * pszOp.width * pszOp.height);
	pubDst.size.width = pszOp.width;
	pubDst.size.height = pszOp.height;
	pubDst.linestep = pszOp.width;

	DSP_RTS_R_8uC1(pSrc, prcoSrcCenter, pubDst, prcoDstCenter, rAngle, pszOp);
	RoiStruct.SrcCenterCo.x = prcoSrcCenter.x;
	RoiStruct.SrcCenterCo.y = prcoSrcCenter.y;
	RoiStruct.DstCenterCo.x = prcoDstCenter.x;
	RoiStruct.DstCenterCo.y = prcoDstCenter.y;
	RoiStruct.RectangleSize.width = pszOp.width;
	RoiStruct.RectangleSize.height = pszOp.height;
	RoiStruct.RotationAngle = rAngle;
	ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sin(rAngle), cos(rAngle), prcoSrcCenter, prcoDstCenter, { 0.f,0.f }, RoiStruct.LeftVertex);
	return 0;

}

IMG_VVOID  CVisLine::ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(const IMG_LREAL sine, const IMG_LREAL cose, const IMG_RCOORD &SrcCenterCo, 
	const IMG_RCOORD &DstCenterCo, const IMG_RCOORD &RoiCo, IMG_RCOORD & RealCo)
{
	RealCo.x = (IMG_REAL)(RoiCo.x * cose - sine * RoiCo.y - (cose * DstCenterCo.x - sine* DstCenterCo.y - SrcCenterCo.x));
	RealCo.y = (IMG_REAL)(RoiCo.x * sine + cose * RoiCo.y + (-sine * DstCenterCo.x - cose* DstCenterCo.y + SrcCenterCo.y));
}

IMG_INT  CVisLine::DSP_RTS_R_8uC1(const IMG_UBBUF &prbSrc, const IMG_RCOORD &prcoSrcCenter, IMG_UBBUF &prbDst, const IMG_RCOORD &prcoDstCenter,
	const IMG_REAL &rAngle, const IMG_SIZE &pszOp, double scale3)
{
	IMG_UBYTE *prSrc, *prDst, *pBuffer;
	IppiSize szSrc;
	IppiRect srcROI, dstROI;
	IppStatus sts;
	IMG_WORD wState = 0;//IMG_WORD wState = OK;
	int buffersize, srclinestep, dstlinestep;

	double coeff[2][4];
	prbDst.ptr = nullptr;
	prbDst.ptr = ippsMalloc_8u(sizeof(IMG_UBYTE) * (size_t)pszOp.width * pszOp.height);
	//prbDst->ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE) * pszOp->width * pszOp->height);
	
	prbDst.size.width = pszOp.width;
	prbDst.size.height = pszOp.height;
	prbDst.linestep = pszOp.width;
	//memcpy(prbDst.ptr, 0, sizeof(IMG_UBYTE) * pszOp.width * pszOp.height);

	coeff[0][0] = 0;
	coeff[0][1] = cos(rAngle)*scale3;
	coeff[0][2] = -sin(rAngle)*scale3;
	coeff[0][3] = -(cos(rAngle)*prcoDstCenter.x - sin(rAngle)*prcoDstCenter.y)*scale3 + prcoSrcCenter.x;

	coeff[1][0] = 0;
	coeff[1][1] = sin(rAngle)*scale3;
	coeff[1][2] = cos(rAngle)*scale3;
	coeff[1][3] = (-sin(rAngle)*prcoDstCenter.x - cos(rAngle)*prcoDstCenter.y)*scale3 + prcoSrcCenter.y;

	prSrc = prbSrc.ptr;
	szSrc.width = prbSrc.size.width;
	szSrc.height = prbSrc.size.height;

	srcROI.x = 0, srcROI.y = 0;
	srcROI.width = szSrc.width, srcROI.height = szSrc.height;

	prDst = prbDst.ptr;
	dstROI.x = 0;
	dstROI.y = 0;
	dstROI.width = pszOp.width;
	dstROI.height = pszOp.height;

	srclinestep = prbSrc.linestep * sizeof(IMG_UBYTE);
	dstlinestep = prbDst.linestep * sizeof(IMG_UBYTE);

	sts = ippiWarpBilinearGetBufferSize(szSrc, srcROI, dstROI, ippWarpBackward, coeff, IPPI_INTER_LINEAR, &buffersize);
	//pBuffer = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*buffersize);
	pBuffer = ippsMalloc_8u(sizeof(IMG_UBYTE)*buffersize);
	VALIDATE_MALLOC(pBuffer);
	sts = ippiWarpBilinearBack_8u_C1R(prSrc, szSrc, srclinestep, srcROI, prbDst.ptr, dstlinestep, dstROI, coeff, IPPI_INTER_LINEAR, pBuffer);

	if (sts != ippStsOk)
	{
		wState = 1;
		//wState = DSP_ERR_FAIL_IN_IPPI;
		goto end;
	}
end:
	if (pBuffer)
	{
		ippiFree(pBuffer);
	}
	
	return wState;
}

IMG_WORD  CVisLine::DSP_RTS_R_8uC1_Spec(IMG_UBBUF prbSrc, IMG_LRCOORD prcoSrcCenter, IMG_UBBUF & prbDst, IMG_LRCOORD prcoDstCenter, int nAngle_spec, IMG_SIZE pszOp)
{
	IMG_UBYTE *prSrc, *prDst, *pBuffer;
	IppiSize szSrc;
	IppiRect srcROI, dstROI;
	IppStatus sts;
	IMG_WORD wState = 0;//IMG_WORD wState = OK;
	int buffersize, srclinestep, dstlinestep;
	double coeff[2][4];

	if (nAngle_spec == 90)
	{
		coeff[0][0] = 0;
		coeff[0][1] = 0;
		coeff[0][2] = -1;
		coeff[0][3] = -(0 * prcoDstCenter.x - 1 * prcoDstCenter.y - prcoSrcCenter.x);

		coeff[1][0] = 0;
		coeff[1][1] = 1;
		coeff[1][2] = 0;
		coeff[1][3] = (-1 * prcoDstCenter.x - 0 * prcoDstCenter.y + prcoSrcCenter.y);
	}
	else if (nAngle_spec == -90)
	{
		coeff[0][0] = 0;
		coeff[0][1] = 0;
		coeff[0][2] = 1;
		coeff[0][3] = -(0 * prcoDstCenter.x + 1 * prcoDstCenter.y - prcoSrcCenter.x);

		coeff[1][0] = 0;
		coeff[1][1] = -1;
		coeff[1][2] = 0;
		coeff[1][3] = (1 * prcoDstCenter.x - 0 * prcoDstCenter.y + prcoSrcCenter.y);
	}


	prSrc = prbSrc.ptr;
	szSrc.width = prbSrc.size.width;
	szSrc.height = prbSrc.size.height;

	srcROI.x = 0, srcROI.y = 0;
	srcROI.width = szSrc.width, srcROI.height = szSrc.height;

	prDst = prbDst.ptr;
	dstROI.x = 0;
	dstROI.y = 0;
	dstROI.width = pszOp.width;
	dstROI.height = pszOp.height;

	srclinestep = prbSrc.linestep * sizeof(IMG_UBYTE);
	dstlinestep = prbDst.linestep * sizeof(IMG_UBYTE);

	sts = ippiWarpBilinearGetBufferSize(szSrc, srcROI, dstROI, ippWarpBackward, coeff, IPPI_INTER_NN, &buffersize);
	pBuffer = new IMG_UBYTE[buffersize];//(IMG_UBYTE*)malloc(sizeof(IMG_UBYTE)*buffersize);
	VALIDATE_MALLOC(pBuffer);
	sts = ippiWarpBilinearBack_8u_C1R(prSrc, szSrc, srclinestep, srcROI, prbDst.ptr, dstlinestep, dstROI, coeff, IPPI_INTER_LINEAR, pBuffer);
	delete[] pBuffer;

	if (sts != ippStsOk)
	{
		wState = 1;
		//wState = DSP_ERR_FAIL_IN_IPPI;
		goto end;
	}
	if (pBuffer)delete pBuffer;

end:
	return wState;
}



IMG_INT  CVisLine::EdgeExtract_8uC1(const IMG_SIZE &size, const RECTROI_LINE &RoiStruct, IMG_UBBUF &prbSrc, int minAThreshold,
	IMG_WORD *& pDst, IMG_REAL *& pAngle, EdgePointLine *&EdgePts, IMG_INT &ptNums)
{
	if (prbSrc.ptr == NULL || prbSrc.size.height < 3 || prbSrc.size.width < 3)
	{
		return -1;
	}
	if (m_sobelSize == SOBELMSKSIZE::kerSize3x3)
	{
		minAThreshold = 4 * minAThreshold;
	}
	if (m_sobelSize == SOBELMSKSIZE::kerSize5x5)
	{
		minAThreshold = 48 * minAThreshold;
	}
	std::vector<EdgePointLine> EdgeDetecResult;
	EdgePointLine edInf;
	//IMG_REAL LineDirection = PointStart.x - PointEnd.x;
	IMG_INT FLAG, TempCo;
	Ipp16u k1;//抛物线拟合的三个已知点
	Ipp16u k2;
	Ipp16u k3;
	IMG_LREAL deci;//抛物线拟合顶点的小数部分，即对应的亚像素
				  //IMG_INT numberChannels = 1; //the source image is single channel
				  //IMG_SIZE dstRoiSize = { RoiCols,RoiRows };
	IMG_LWORD RoiCols = prbSrc.size.width;
	IMG_LWORD RoiRows = prbSrc.size.height;

	IMG_UBYTE *pSrcGauss;
	//pSrcGauss = (IMG_UBYTE *)malloc(sizeof(IMG_UBYTE)*RoiCols*RoiRows);
	pSrcGauss = new IMG_UBYTE[RoiCols*RoiRows];
	if (m_GaussFilterPara.GaussSigmaWidth != 0.f && m_GaussFilterPara.GaussSigmaHeight != 0.f)
	{
		GaussianFilter_2D(prbSrc.ptr, prbSrc.size.width, prbSrc.size.height, m_GaussFilterPara.GaussKerWidth, m_GaussFilterPara.GaussKerHeight, m_GaussFilterPara.GaussSigmaWidth, m_GaussFilterPara.GaussSigmaHeight, pSrcGauss);
		SobelFilter_8u16s_C1_3x3(pSrcGauss, { prbSrc.size.width, prbSrc.size.height }, pDst, pAngle, prbSrc.linestep);
	}

	else
	{
		SobelFilter_8u16s_C1_3x3(prbSrc.ptr, { prbSrc.size.width, prbSrc.size.height }, pDst, pAngle, prbSrc.linestep);
	}
	delete[]pSrcGauss;
	IMG_RCOORD dstCoor, srcCoor;
	IMG_LREAL sine, cose;
	IMG_REAL angle;
	sine = sin(RoiStruct.RotationAngle);
	cose = cos(RoiStruct.RotationAngle);
	for (IMG_LWORD i = 1; i < RoiRows - 1 ; i++)
	{
		for (IMG_LWORD j = 1; j < RoiCols - 1 ; j++)
		{
			dstCoor.x = (IMG_LREAL)j;
			dstCoor.y = (IMG_LREAL)i;
			
			ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(sine, cose, RoiStruct.SrcCenterCo, RoiStruct.DstCenterCo, dstCoor, srcCoor);
			if (srcCoor.x <= 1 || srcCoor.x >= (size.width - 2) || srcCoor.y <= 1 || srcCoor.y >= (size.height - 2))
			{
				continue;
			}

			TempCo = j + i * RoiCols;
			angle = 180.0 - pAngle[TempCo] / PI * 180.0;
			if (pDst[TempCo] > minAThreshold)
			{
				if ((angle >= 67.5) && (angle <= 112.5))
				{
					if ((pDst[TempCo] > pDst[j + (i - 1) * RoiCols]) && (pDst[TempCo] >= pDst[j + (i + 1) * RoiCols]))
					{
						k1 = pDst[j + (i - 1) * RoiCols];
						k2 = pDst[TempCo];
						k3 = pDst[j + (i + 1) * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j;
						edInf.xyDecimal.y = i + deci + m_fOffset;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if ((angle >= 247.5) && (angle <= 292.5))
				{
					if ((pDst[TempCo] > pDst[j + (i - 1)*RoiCols]) && (pDst[TempCo] >= pDst[j + (i + 1)*RoiCols]))
					{
						k3 = pDst[j + (i - 1) * RoiCols];
						k2 = pDst[TempCo];
						k1 = pDst[j + (i + 1) * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j;
						edInf.xyDecimal.y = i - deci - m_fOffset;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if ((angle > 22.5) && (angle < 67.5))
				{
					if ((pDst[TempCo] > pDst[j - 1 + (i - 1) * RoiCols]) && (pDst[TempCo] >= pDst[(j + 1) + (i + 1) * RoiCols]))
					{
						k1 = pDst[j - 1 + (i - 1) * RoiCols];
						k2 = pDst[TempCo];
						k3 = pDst[(j + 1) + (i + 1) * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j + deci + m_fOffset;
						edInf.xyDecimal.y = i + deci + m_fOffset;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if ((angle > 202.5) && (angle < 247.5))
				{
					if ((pDst[TempCo] > pDst[j - 1 + (i - 1) * RoiCols]) && (pDst[TempCo] >= pDst[(j + 1) + (i + 1)*RoiCols]))
					{
						k3 = pDst[j - 1 + (i - 1) * RoiCols];
						k2 = pDst[TempCo];
						k1 = pDst[(j + 1) + (i + 1) * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j - deci - m_fOffset;
						edInf.xyDecimal.y = i - deci - m_fOffset;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if ((angle > 112.5) && (angle < 157.5))
				{
					if ((pDst[TempCo] > pDst[(j + 1) + (i - 1) * RoiCols]) && (pDst[TempCo] >= pDst[(j - 1) + (i + 1) * RoiCols]))
					{
						k1 = pDst[(j + 1) + (i - 1) * RoiCols];
						k2 = pDst[TempCo];
						k3 = pDst[(j - 1) + (i + 1) * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j - deci + m_fOffset;
						edInf.xyDecimal.y = i + deci + m_fOffset;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if ((angle > 292.5) && (angle < 337.5))
				{
					if ((pDst[TempCo] > pDst[(j + 1) + (i - 1) * RoiCols]) && (pDst[TempCo] >= pDst[(j - 1) + (i + 1) * RoiCols]))
					{
						k3 = pDst[(j + 1) + (i - 1) * RoiCols];
						k2 = pDst[TempCo];
						k1 = pDst[(j - 1) + (i + 1) * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j + deci - m_fOffset;
						edInf.xyDecimal.y = i - deci - m_fOffset;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if (((angle >= 0) && (angle <= 22.5)) || ((angle >= 337.5) && (angle <= 360)))
				{
					if ((pDst[TempCo] > pDst[(j - 1) + i * RoiCols]) && (pDst[TempCo] >= pDst[(j + 1) + i * RoiCols]))
					{
						k1 = pDst[(j - 1) + i * RoiCols];
						k2 = pDst[TempCo];
						k3 = pDst[(j + 1) + i * RoiCols];
						deci = (k3 - k1) / (2.0 * (2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j + deci + m_fOffset;
						edInf.xyDecimal.y = i;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
				if ((angle <= 202.5) && (angle >= 157.5))
				{
					if ((pDst[TempCo] > pDst[(j - 1) + i * RoiCols]) && (pDst[TempCo] >= pDst[(j + 1) + i * RoiCols]))
					{
						k3 = pDst[(j - 1) + i * RoiCols];
						k2 = pDst[TempCo];
						k1 = pDst[(j + 1) + i * RoiCols];
						deci = (k3 - k1) / (2.0 *(2.0 * k2 - k1 - k3));

						edInf.xyInteger.x = j;
						edInf.xyInteger.y = i;
						edInf.xyDecimal.x = j - deci - m_fOffset;
						edInf.xyDecimal.y = i;
						edInf.gradient = pDst[TempCo];
						edInf.angle = angle;
						EdgeDetecResult.push_back(edInf);
						continue;
					}
				}
			}
		}
	}
	ptNums = EdgeDetecResult.size();
	EdgePts = new EdgePointLine[ptNums];
	for (int i = 0; i < ptNums; i++)
	{
		EdgePts[i] = EdgeDetecResult[i];
	}
	EdgeDetecResult.clear();
	return 0;
}

IMG_INT CVisLine::EDGEPOINT_FILTER(const IMG_RCOORD &PointStart, const IMG_RCOORD &PointEnd, const RECTSCANDIR &scanDirect,
	const EDGETYPE &edgeDirect, EdgePointLine *&EdgePts, IMG_INT &ptNums,bool flag)
{

	//vector<EdgePointLine> tempEdge;
	IMG_INT LinePhase;//0,lefthand 180,righthand
	//IMG_REAL AngleTol = 30;
	IMG_REAL AngleTol = m_HoughLinePara.HoughAngleTol;
	IMG_UINT CurrentEdgeNum = ptNums;
	if (edgeDirect == EDGETYPE::BOTH || edgeDirect == EDGETYPE::BLACKCENTER || edgeDirect == EDGETYPE::WHITECENTER)
	{
		for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
		{
			if (flag)
			{
				if ((EdgePts[i].angle < 90 + AngleTol && EdgePts[i].angle > 90 - AngleTol))
					continue;
				else
				{
					EdgePts[i] = EdgePts[CurrentEdgeNum - 1];
					CurrentEdgeNum--;
					i--;
				}
			}

			else
			{
				if (EdgePts[i].angle > 270 - AngleTol && EdgePts[i].angle < 270 + AngleTol)
					continue;
				else
				{
					EdgePts[i] = EdgePts[CurrentEdgeNum - 1];
					CurrentEdgeNum--;
					i--;
				}
			}
		}
		ptNums = CurrentEdgeNum;
		return 0;
	}


	if (edgeDirect == EDGETYPE::ANY)
	{
		for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
		{
			if ((EdgePts[i].angle < 90 + AngleTol && EdgePts[i].angle > 90 - AngleTol) || (EdgePts[i].angle > 270 - AngleTol && EdgePts[i].angle < 270 + AngleTol))
				continue;
			else
			{
				EdgePts[i] = EdgePts[CurrentEdgeNum - 1];
				CurrentEdgeNum--;
				i--;
			}
		}
		ptNums = CurrentEdgeNum;
		return 0;
	}

	if (PointEnd.x >= PointStart.x)
	{
		if ((scanDirect == RECTSCANDIR::LEFTHAND && edgeDirect == EDGETYPE::DARK2LIGHT) || (scanDirect == RECTSCANDIR::RIGHTHAND && edgeDirect == EDGETYPE::LIGHT2DARK))
			LinePhase = 2;//lefthand
		else
			LinePhase = 3;//righthand
	}
	else
	{
		if ((scanDirect == RECTSCANDIR::LEFTHAND && edgeDirect == EDGETYPE::DARK2LIGHT) || (scanDirect == RECTSCANDIR::RIGHTHAND && edgeDirect == EDGETYPE::LIGHT2DARK))
			LinePhase = 2;
		else
			LinePhase = 3;
	}

	//0-vertical lefthand, 1-v r, 2-Horizontal lefthand, 3-H r
	switch (LinePhase)
	{

	case 2:
		for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
		{
			if (EdgePts[i].angle > 270 - AngleTol && EdgePts[i].angle < 270 + AngleTol)
				continue;
			else
			{
				EdgePts[i] = EdgePts[CurrentEdgeNum - 1];
				CurrentEdgeNum--;
				i--;
			}
		}
		break;
	case 3:
		for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
		{
			if (EdgePts[i].angle < 90 + AngleTol && EdgePts[i].angle > 90 - AngleTol)
				continue;
			else
			{
				EdgePts[i] = EdgePts[CurrentEdgeNum - 1];
				CurrentEdgeNum--;
				i--;
			}
		}
		break;
	default:
		break;
	}
	ptNums = CurrentEdgeNum;
	return 0;
}

//IMG_INT CVisLine::SCANDRECTION_POINT_FILTER(vector<EdgePointLine> EdgePoint, RectScanDirection2D scanDirect, EdgeTransition edgeDirect, vector<EdgePointLine> &PointFiltering)
//{
//	IMG_INT PointNums = (int)EdgePoint.size();
//	if ((scanDirect == RectScanDirection2D::LEFTHAND && edgeDirect == EdgeTransition::DARK2LIGHT) || (scanDirect == RectScanDirection2D::RIGHTHAND && edgeDirect == EdgeTransition::LIGHT2DARK))
//	{
//		for (IMG_INT i = 0; i < PointNums; i++)
//		{
//			if (EdgePoint[i].angle >= 180 && EdgePoint[i].angle <= 360)
//				PointFiltering.push_back(EdgePoint[i]);
//		}
//	}
//	else if (edgeDirect == EdgeTransition::ANNY)
//	{
//		for (IMG_INT i = 0; i < PointNums; i++)
//		{
//			PointFiltering.push_back(EdgePoint[i]);
//		}
//
//	}
//	else
//	{
//		for (IMG_INT i = 0; i < PointNums; i++)
//		{
//			if (EdgePoint[i].angle <= 180 && EdgePoint[i].angle >= 0)
//				PointFiltering.push_back(EdgePoint[i]);
//		}
//	}
//	return 0;
//}
void set_IMG_UBBUF(IMG_UBBUF &buf, IMG_UBYTE *p, IMG_SIZE sz, IMG_UINT linstep)
{
	buf.ptr = p;
	buf.size = sz;
	buf.linestep = linstep;
}
IMG_INT  CVisLine::GaussianFilter_2D(const IMG_UBYTE *src, const IMG_INT &roiWidth, const IMG_INT &roiHeight, const IMG_INT &kerWidth, const IMG_INT &kerHeight, const IMG_LREAL &sigma_width, const IMG_LREAL &sigma_height, IMG_UBYTE *&dst)
{
	IMG_INT status = 0;
	//VisBuf visbuf;
	IMG_UBBUF ubbGauss;
	set_IMG_UBBUF(ubbGauss, dst, { roiWidth,roiHeight }, roiWidth);

	//row filter
	int pos = 0;
	for (int i = 0; i < roiHeight; i++)
	{
		status = GaussianFilter_dim1_fixed(src + pos, roiWidth, sigma_width, kerWidth, dst + pos);
		pos += roiWidth;
	}

	//rotate 90
	IMG_UBBUF ubbTempBuf;
	unsigned char *m_pTemp = new unsigned char[(size_t)roiWidth * roiHeight];
	set_IMG_UBBUF(ubbTempBuf, m_pTemp, { roiHeight,roiWidth }, roiHeight);
	IMG_LRCOORD oldCenter = { (roiWidth - 1.0) / 2, (roiHeight - 1.0) / 2 };
	IMG_LRCOORD newCenter = { (roiHeight - 1.0) / 2, (roiWidth - 1.0) / 2 };
	status = DSP_RTS_R_8uC1_Spec(ubbGauss, oldCenter, ubbTempBuf, newCenter, -90, { roiHeight,roiWidth });

	//col filter
	IMG_UBBUF ubbTempGaussBuf;
	unsigned char *m_pTempGauss = new unsigned char[(size_t)roiWidth * roiHeight];
	set_IMG_UBBUF(ubbTempGaussBuf, m_pTempGauss, { roiHeight,roiWidth }, roiHeight);

	pos = 0;
	for (int i = 0; i < roiWidth; i++)
	{
		status = GaussianFilter_dim1_fixed(ubbTempBuf.ptr + pos, roiHeight, sigma_height, kerHeight, m_pTempGauss + pos);
		pos += roiHeight;
	}

	//rotate 90
	status = DSP_RTS_R_8uC1_Spec(ubbTempGaussBuf, newCenter, ubbGauss, oldCenter, 90, { roiWidth,roiHeight });

	delete[] m_pTempGauss;
	delete[] m_pTemp;

	return status;
}

IMG_VVOID  CVisLine::GetGaussianKernel_dim1(IMG_REAL * gaus, IMG_UINT size, IMG_LREAL sigma)
{
	const float pi = 4.0*atan(1.0); //圆周率π赋值  
	double center = (size-1) / 2.0f;
	double sum = 0;
	for (int i = 0; i < size; i++)
	{
		gaus[i] = (1 / (sqrt(2 * pi)*sigma))*exp(-((i - center)*(i - center)) / (2 * sigma*sigma));
		sum += gaus[i];
	}
	for (int i = 0; i < size; i++)
	{
		if (size > 0)
			gaus[i] /= sum;
	}
}



IMG_INT  CVisLine::GaussianFilter_dim1_fixed(const IMG_UBYTE *src, const IMG_INT &srcWidth, const IMG_LREAL &sigma, const IMG_UINT &kernelSize, IMG_UBYTE *dst)
{
	IMG_INT status = 0;
	IMG_INT src1Len = srcWidth, src2Len = kernelSize;
	src1Len += 2 * (src2Len / 2);	//top and bottom


	IppEnum funCfg = (IppEnum)(ippAlgAuto);
	IMG_INT bufSize = 0;
	Ipp8u *pBuffer;

	Ipp32f *pSrc1 = new Ipp32f[src1Len];
	int additionLen = src2Len / 2;
	for (int i = 0; i < src1Len; i++)
	{
		if (i < additionLen)
		{
			pSrc1[i] = src[0];
		}
		else if (i > src1Len - 1 - (additionLen))
		{
			pSrc1[i] = src[srcWidth - 1];
		}
		else
		{
			pSrc1[i] = src[i - (additionLen)];
		}

	}
	Ipp32f *pSrc2 = new Ipp32f[src2Len];
	int dstLen = src1Len + src2Len - 1;
	Ipp32f *pDst = new Ipp32f[dstLen];

	GetGaussianKernel_dim1(pSrc2, src2Len, sigma);

	status = ippsConvolveGetBufferSize(src1Len, src2Len, ipp32f, funCfg, &bufSize);
	if (status != ippStsNoErr)
		return status;

	pBuffer = ippsMalloc_8u(bufSize);

	status = ippsConvolve_32f(pSrc1, src1Len, pSrc2, src2Len, pDst, funCfg, pBuffer);

	//assert(_CrtCheckMemory());
	if (status == 0)
	{
		for (int i = 0; i < srcWidth; i++)			//注意两端
		{
			dst[i] = (unsigned char)pDst[i + src2Len - 1];
		}
	}

	//assert(_CrtCheckMemory());
	ippsFree(pBuffer);
	delete[] pDst;
	delete[] pSrc2;
	delete[] pSrc1;

	return status;
}

IMG_VVOID  CVisLine::SobelFilter_8u16s_C1_3x3(IMG_UBYTE *&pSrc, IMG_SIZE roiSize, IMG_WORD *& pDst, IMG_REAL *& pAngle, IMG_INT srcImgStep)
{
	IppiMaskSize mask = (IppiMaskSize)m_sobelSize;
	IppiBorderType bordertype = ippBorderConst; //Border is replicated from the edge pixels
	IMG_WORD *pHoriz, *pVert;
	IppiSize RoiSize;
	IMG_UBYTE *pBuffer;
	IppNormType normType = ippNormL2;//input gradient magnitude
	IMG_INT srcStep = srcImgStep * sizeof(IMG_UBYTE);
	IMG_INT dstStep = roiSize.width * sizeof(IMG_WORD);
	IMG_INT angleStep = roiSize.width * sizeof(IMG_REAL);
	IMG_INT bufferSize;
	IMG_INT bufLen = roiSize.width * roiSize.height;

	RoiSize.height = roiSize.height;
	RoiSize.width = roiSize.width;
	pVert = new IMG_WORD[bufLen];
	pHoriz = new IMG_WORD[bufLen];
	pAngle = new IMG_REAL[bufLen];
	pDst = new IMG_WORD[bufLen];

	ippiGradientVectorGetBufferSize(RoiSize, mask, ipp16s, 1, &bufferSize);
	pBuffer = new IMG_UBYTE[bufferSize];
	ippiGradientVectorSobel_8u16s_C1R(pSrc, srcStep, pVert, dstStep, pHoriz, dstStep, pDst, dstStep, pAngle, angleStep, RoiSize, mask, normType, bordertype, 0, pBuffer);
	delete[]pHoriz;
	delete[]pVert;
	delete[]pBuffer;

}

IMG_VVOID  CVisLine::EdgeFilter(IMG_UBBUF * pMaskRTS, EdgePointLine *&EdgePts, IMG_INT &ptNums)
{
	IMG_UINT CurrentEdgeNum = ptNums;
	for (IMG_INT i = 0; i < CurrentEdgeNum; i++)
	{
		if (0 == pMaskRTS->ptr[EdgePts[i].xyInteger.y * pMaskRTS->size.width + EdgePts[i].xyInteger.x])
		{
			EdgePts[i] = EdgePts[CurrentEdgeNum - 1];
			CurrentEdgeNum--;
			i--;
		}
	}
	ptNums = CurrentEdgeNum;
}

IMG_VVOID  CVisLine::HoughTransLine(const IMG_SIZE &pSrc, HOUGH_TRANS_INFO *&HoughResult, LINE_INFO2D *&HoughResult_Slope, IMG_INT &houghLineNums,
	EdgePointLine *&EdgePts, IMG_INT &ptNums, const IMG_LREAL &HoughAcceptScore, const IMG_LREAL &AngleTol, IMG_INT log_index)
{
	std::vector<HOUGH_TRANS_INFO> HoughResult_Vec; std::vector<LINE_INFO2D> HoughResult_Slope_Vec;
	LINE_INFO2D Line;
	HOUGH_TRANS_INFO HoughLine;
	IMG_RCOORD pSrcCenter;
	IMG_REAL AngleIncre, Sin, Cos, VoteRo, PointThd, Angle;
	IMG_REAL *VoteNum;
	IMG_INT RoMax, Width, Height,  TempCo, FloorCo, CeilCo;
	size_t Length;
	CVisImage debugbuf;
	CVisMemPool pool;
	IMG_INT i, j, k, kernel_size;
	IMG_REAL *kernel;
	IMG_RBUF buf_inspection, buf_kernel;

	IMG_INT edgePts = ptNums;
	if (edgePts < 2)
		return;
	kernel_size = (IMG_INT)floor((m_HoughLinePara.HoughKernelSize & (~1))+ 1)/m_HoughLinePara.HoughInterceptResolution;
	if (kernel_size < 1)kernel_size = 1;
	kernel = (IMG_REAL *)pool.Malloc(kernel_size * sizeof(IMG_REAL)*10);
	VALIDATE_MALLOC(kernel);
	buf_kernel.size.width = kernel_size;
	buf_kernel.size.height = 10;
	buf_kernel.linestep = kernel_size;
	buf_kernel.ptr = kernel;

	GetGaussianKernel_dim1(kernel, kernel_size, m_LineFittingPara.LineFittingSigma/2);
	for (i = 1; i < 10; i++)
	{
		kernel[i*kernel_size] = kernel[0] * (10 - i) / 10;
		for (j = 1; j < kernel_size; j++)
		{
			kernel[i*kernel_size + j] = kernel[j - 1] * i / 10 + kernel[j] * (10 - i) / 10;
		}
	}
	AngleIncre = (IMG_REAL)atan2(m_HoughLinePara.HoughAngleResolution, (pSrc.width - 1)) / PI * 180.f;
	RoMax = (pow(pow(pSrc.height - 1, 2) + pow(pSrc.width - 1, 2), 0.5)) / 2 / m_HoughLinePara.HoughInterceptResolution;
	//AngleIncre = atan2(2.f, RoMax) / PI * 180.f;
	Width = RoMax * 2 + 2 + 1;
	Height = AngleTol * 2 / AngleIncre + 1 + 2;
	if (m_FixAngle)
	{
		Height = 3;
	}
	Length = (size_t)Width * Height;
	pSrcCenter.x = (pSrc.width - 1) / 2;
	pSrcCenter.y = (pSrc.height - 1) / 2;
	
	VoteNum = new IMG_REAL[Length];

	buf_inspection.size.width = Width;
	buf_inspection.size.height = Height;
	buf_inspection.linestep = Width;
	buf_inspection.ptr = VoteNum;
	//step: initialing votespace
	memset(VoteNum, 0, sizeof(IMG_REAL)*Length);

	PointThd = HoughAcceptScore / 100.0*pSrc.width/2/ m_fStep;
	//step: vote
	for ( i = 1; i < Height - 1; i++)
	{
		if (m_FixAngle)
		{
			Sin = 1;
			Cos = 0;
		}
		else
		{
			Sin = (IMG_REAL)sin((90 - AngleTol + (i - 1) * AngleIncre) / 180 * PI);
			Cos = (IMG_REAL)cos((90 - AngleTol + (i - 1) * AngleIncre) / 180 * PI);
		}
		for ( j = 0; j < edgePts; j++)
		{
			IMG_INT index, start_kernel, end_kernel,center, start_vote, end_vote;
			VoteRo = (EdgePts[j].xyDecimal.x - pSrcCenter.x) * Cos + (EdgePts[j].xyDecimal.y - pSrcCenter.y) * Sin;
			index = (IMG_INT)((VoteRo - floor(VoteRo)) * 10);
			if (index < 0)
			{
				printf("wrong\n");
			}
			center = (IMG_INT)((RoMax + 1 + VoteRo));
			start_kernel = 0;
			if (center - (kernel_size >> 1) < 0)
			{
				start_kernel = (kernel_size>>1)-center;
			}
			start_vote = center - (kernel_size >> 1) + start_kernel;
			end_kernel = kernel_size;
			if (center + (kernel_size >> 1) >= Width)
			{
				end_kernel = kernel_size-(center+(kernel_size>>1)-Height);
			}
			end_vote = center + end_kernel - (kernel_size >> 1) - 1;

			//FloorCo = floor(VoteRo), CeilCo = ceil(VoteRo);
			//VoteNum[Width * i + RoMax + 1 + FloorCo] += CeilCo - VoteRo;
			//VoteNum[Width * i + RoMax + 1 + CeilCo] += VoteRo - FloorCo;
			for (k = start_kernel; k < end_kernel; k++)
			{
				VoteNum[(size_t)Width * i + start_vote + k - start_kernel] += kernel[index*kernel_size + k];
			}
		}
	}
	if (m_uwDebug & 4)
	{
		IMG_RBUF buf;
		IMG_UINT ulLineSearchLogIndex = g_LineLogIndex;
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
		IMG_REAL rMax = 0;
		for(size_t i = 0; i<(size_t)Height*Width; i++)
		{
			if(rMax < VoteNum[i])rMax = VoteNum[i];
		}
		buf.ptr = VoteNum;
		buf.linestep = Width;
		buf.size = { Width, Height };
		CVisImage rdebugbuf(buf);
		_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uHoughRaw%d.tif", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex, log_index);
		rdebugbuf.WriteImage(pathname);
		writeLog("Hough Image Threshold %.2f\n", PointThd);
		writeLog("Hough Raw Image\n");
		p = strrchr(pathname, '\\')-12;
		HL_InsertObject(m_pHtmlLog, "Raw_Real_buf", p);
		writeLog("\n");
		debugbuf.CopyFrom(rdebugbuf);
		debugbuf.Mul_C(240/rMax);
		debugbuf.Convert_32f_to_8u();

	}
	int bufSize;
	int maxsize = Height*Width, peakCount;
	IppStatus sts;
	IppiSize roiSize = { Width, Height };
	sts = ippiFindPeaks3x3GetBufferSize_32f_C1R(Width, &bufSize);
	if (sts != ippStsOk)
	{
		THROW_VIS_EXCEPTION(VIS_ERR_FAIL_IN_IPPI);
	}
	Ipp8u *pBuffer = (Ipp8u *)pool.Malloc(bufSize);
	VALIDATE_MALLOC(pBuffer);
	IppiPoint *localmax_pt = (IppiPoint *)pool.Malloc(sizeof(IppiPoint)*maxsize);
	VALIDATE_MALLOC(localmax_pt);
	IMG_INT dstStep = Width * sizeof(float);
	float maxVal; int indexI, indexJ;
	ippiMaxIndx_32f_C1R(VoteNum, dstStep, { Width ,Height }, &maxVal, &indexI, &indexJ);
	if (PointThd < maxVal / 3)PointThd = maxVal / 3;
	if (PointThd > maxVal && PointThd<maxVal*3)PointThd = maxVal*.8;
	if (m_uwDebug & 4)
	{
		writeLog("Hough Image Maxium %.2f\n", maxVal);
		writeLog("Hough Threshold revised as %.2f\n", PointThd);

	}
	if (m_FixAngle)
	{
		peakCount = 0;
		for (i = 1; i < Width-1; i++)
		{
			if(VoteNum[i+Width] < PointThd) continue;
			if (VoteNum[i + Width] > VoteNum[i + Width - 1] && VoteNum[i + Width] > VoteNum[i + Width + 1])
			{
				localmax_pt[peakCount++] = { i, 1 };
			}
		}
	}
	else
	{
		sts = ippiFindPeaks3x3_32f_C1R(VoteNum, Width * sizeof(IMG_REAL), roiSize, PointThd, localmax_pt, maxsize,
			&peakCount, ippiNormInf, 2, pBuffer);
		if (sts != ippStsOk)
		{
			THROW_VIS_EXCEPTION(VIS_ERR_FAIL_IN_IPPI);
		}
	}

	// step: find local maximum
	for (int count = 0; count < peakCount; count++)
	{
		j = localmax_pt[count].x;
		i = localmax_pt[count].y;
		TempCo = i * Width + j;
		{
			if (m_FixAngle)
				Angle = 90*PI/180;
			else
				Angle = (IMG_REAL)(90.0 - AngleTol + (i - 1.0)*AngleIncre) / 180 * PI;
			memset(&Line, 0, sizeof(Line));
			Line.Slope = -(IMG_REAL)(cos(Angle) / sin(Angle));
			Line.b = (IMG_REAL)(j - RoMax -1) / sin(Angle) + 1.f / tan(Angle) * pSrcCenter.x + pSrcCenter.y;
			Line.houghScore = VoteNum[TempCo];
			Line.PointStart.x = 0;
			Line.PointStart.y = Line.b;
			Line.PointEnd.x = pSrc.width-1;
			Line.PointEnd.y = Line.Slope*Line.PointEnd.x + Line.b;
			Line.id = m_ID++;
			HoughResult_Slope_Vec.push_back(Line);

			HoughLine.theta = 90.0 - AngleTol + i - 1.0;
			HoughLine.roRadius = j - RoMax - 1;
			HoughLine.votePoNum = VoteNum[TempCo];
			HoughResult_Vec.push_back(HoughLine);
			if (m_uwDebug & 4)
			{
				IMG_RCOORD rco = {(IMG_REAL)j, (IMG_REAL)i};
				debugbuf.DrawPoint(&rco, 1, COLORS::Red);
			}
		}
	}
	if (HoughResult_Vec.size() < 1 )
	{

		Angle = (IMG_REAL)(90.0 - AngleTol + (indexJ - 1.0)*AngleIncre) / 180 * PI;
		TempCo = indexJ * Width + indexI;
		memset(&Line, 0, sizeof(Line));
		Line.Slope = -(IMG_REAL)(cos(Angle) / sin(Angle));
		Line.b = (IMG_REAL)(indexI - RoMax - 1) / sin(Angle) + 1.f / tan(Angle) * pSrcCenter.x + pSrcCenter.y;
		Line.houghScore = VoteNum[TempCo];
		Line.PointStart.x = 0; 
		Line.PointStart.y = Line.b;
		Line.PointEnd.x = pSrc.width;
		Line.PointEnd.y = Line.Slope*Line.PointEnd.x + Line.b;
		Line.id = m_ID++;
		HoughResult_Slope_Vec.push_back(Line);
		HoughLine.theta = 90.0 - AngleTol + indexJ - 1.0;
		HoughLine.roRadius = indexI - RoMax - 1;
		HoughLine.votePoNum = VoteNum[TempCo];
		HoughResult_Vec.push_back(HoughLine);
		if (m_uwDebug & 4)
		{
			IMG_RCOORD rco = {(IMG_REAL)indexI, (IMG_REAL)indexJ};
			debugbuf.DrawPoint(&rco, 1, COLORS::Blue);
		}
	}
	if (m_uwDebug & 4)
	{
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
		IMG_UINT ulLineSearchLogIndex = g_LineLogIndex;
		if(debugbuf.Width()>JPG_SIZE_LIMITATION||debugbuf.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uHough%d.bmp", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex, log_index);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uLine\\LOG%05uHough%d.jpg", m_strDebugPath, ulLineSearchLogIndex, ulLineSearchLogIndex, log_index);		
		debugbuf.WriteImage(pathname);
		writeLog("Hough Image\n");
		p = strrchr(pathname, '\\')-12;
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
	}

	houghLineNums = HoughResult_Vec.size();
	HoughResult = new HOUGH_TRANS_INFO[houghLineNums];
	HoughResult_Slope = new LINE_INFO2D[houghLineNums];
	for (int i = 0; i < houghLineNums; i++)
	{
		HoughResult[i] = HoughResult_Vec[i];
		HoughResult_Slope[i] = HoughResult_Slope_Vec[i];
	}
	HoughResult_Slope_Vec.clear(); HoughResult_Vec.clear();
	delete[]VoteNum;
}

IMG_VVOID  CVisLine::LineFitting(LINE_INFO2D *&FittingResult, IMG_INT &lineNums, LINE_INFO2D *&OriginLine, IMG_INT srcLineNums, EdgePointLine *&EdgePts, IMG_INT &ptNums,
	const IMG_SIZE &SrcSize, const IMG_REAL &Sigma, const IMG_UINT &IteMaxTimes, const IMG_REAL &ItePrecision)
{
	CVisMemPool pool;
	vector <LINE_INFO2D> FittingResult_Vec;
	IMG_LREAL *MatA, *MatACopy, *MatB, *MatC, *MatCCopy, *Weight, *ErrorRecord;
	IMG_LREAL Denominator;
	IMG_INT ErrorTimes, Length;
	LINE_INFO2D TempLine;
	EdgePointLine *fitpoint;

	IMG_UINT LineLen = ALIGN_DIST(m_LineInputPara.PointStart, m_LineInputPara.PointEnd);
	IMG_REAL *fitscore = (IMG_REAL *)pool.Malloc(LineLen * sizeof(IMG_REAL));

	MatA = (IMG_LREAL *)pool.Malloc(sizeof(IMG_LREAL)*2 * ptNums); //column: 2, rows: number of points
	MatB = (IMG_LREAL *)pool.Malloc(sizeof(IMG_LREAL) * 2);
	MatC = (IMG_LREAL *)pool.Malloc(sizeof(IMG_LREAL)*ptNums);
	fitpoint = (EdgePointLine *) pool.Malloc(sizeof(EdgePointLine)*ptNums);
	ErrorRecord = (IMG_LREAL *)pool.Malloc(sizeof(IMG_LREAL)*IteMaxTimes * 3);
	VALIDATE_MALLOC(MatA);
	VALIDATE_MALLOC(MatB);
	VALIDATE_MALLOC(MatC);
	VALIDATE_MALLOC(fitpoint);
	VALIDATE_MALLOC(ErrorRecord);
	VALIDATE_MALLOC(fitscore);

	IMG_INT edgePts = ptNums;
	//vector <IMG_REAL> EdgePointsX;
	//IMG_REAL Xmin, Xmax, Xtemp;

	for (IMG_INT i = 0; i < srcLineNums; i++)
	{
		TempLine = OriginLine[i];
		Length = 0; 
		Denominator = pow(OriginLine[i].Slope * OriginLine[i].Slope + 1, 0.5);

		MatB[0] = OriginLine[i].Slope;
		MatB[1] = OriginLine[i].b;

		//step: choose points

		for (IMG_INT j = 0; j < edgePts; j++)
		{
			float a = abs(OriginLine[i].Slope * EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + OriginLine[i].b) / Denominator;
			if (abs(OriginLine[i].Slope * EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + OriginLine[i].b) / Denominator <= m_ScoreAcceptDistance)
			{
				if ((m_edgeDir == EDGETYPE::BOTH || m_edgeDir == EDGETYPE::BLACKCENTER || m_edgeDir == EDGETYPE::WHITECENTER) && m_searchType == SEARCH_TYPE::SOBEL_IPP)
				{
					if ((OriginLine[i].edgeType == EDGETYPE::LIGHT2DARK && EdgePts[j].angle > 90-m_HoughLinePara.HoughAngleTol && EdgePts[j].angle<90+m_HoughLinePara.HoughAngleTol)||
						(OriginLine[i].edgeType == EDGETYPE::DARK2LIGHT && EdgePts[j].angle > 270 - m_HoughLinePara.HoughAngleTol && EdgePts[j].angle<270 + m_HoughLinePara.HoughAngleTol))
					{
						MatA[Length * 2 + 0] = EdgePts[j].xyDecimal.x;
						MatA[Length * 2 + 1] = 1;
						MatC[Length] = EdgePts[j].xyDecimal.y;
						fitpoint[Length] = EdgePts[j];
						Length++;
					}
				}
				else
				{
					MatA[Length * 2 + 0] = EdgePts[j].xyDecimal.x;
					MatA[Length * 2 + 1] = 1;
					MatC[Length] = EdgePts[j].xyDecimal.y;
					fitpoint[Length] = EdgePts[j];
					Length++;
				}
			}
		}
		if (Length < 3)
		{
			continue;
		}

		MatACopy = new IMG_LREAL[2 * Length]; //column: 2, rows: number of points
		MatCCopy = new IMG_LREAL[Length];
		Weight = new IMG_LREAL[Length];

		for (IMG_INT j = 0; j < Length; j++)
		{
			Weight[j] = 1;
			MatCCopy[j] = MatC[j];

		}

		//step: fitting 
		ErrorTimes = 0;
		while (1)
		{
			if (m_FixAngle)
			{
				MatB[0] = 0;
				MatB[1] = 0;
				for (IMG_INT j = 0; j < Length; j++)MatB[1] += MatC[j];
				MatB[1] /= Length;
			}
			else
			{
				cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, Length, 1, 2, 1, MatA, 2, MatB, 1, -1, MatCCopy, 1); //calculate error
			}
			ErrorRecord[ErrorTimes * 3] = 0;
			for (IMG_INT j = 0; j < Length; j++)
			{
				ErrorRecord[ErrorTimes * 3] += abs(MatCCopy[j]);
			}
			ErrorRecord[ErrorTimes * 3] /= (IMG_REAL)Length;
			ErrorRecord[ErrorTimes * 3 + 1] = MatB[0];
			ErrorRecord[ErrorTimes * 3 + 2] = MatB[1];
			TempLine.FittingScore = 0;
			memset(fitscore, 0, LineLen * sizeof(IMG_REAL));
			for (int k = 0; k < Length; k++)
			{
				IMG_LREAL slop = MatB[0], b = MatB[1];
				IMG_LREAL Denominator = pow(slop*slop + 1, 0.5);
				IMG_LREAL dis = fabs(slop*fitpoint[k].xyDecimal.x - fitpoint[k].xyDecimal.y + b) / Denominator;
				if (dis < m_ScoreAcceptDistance)
				{
					IMG_REAL high = m_LineFittingPara.LineFittingSigma / 3 > 1 ? m_LineFittingPara.LineFittingSigma / 3 : 1;
					IMG_REAL low = m_LineFittingPara.LineFittingSigma > high + 0.1 ? m_LineFittingPara.LineFittingSigma : high + 0.1;
					IMG_REAL fittingscore = VisAlign::Align_Sigmoid(dis, high, low);
					if (fittingscore > fitscore[(IMG_INT)fitpoint[k].xyDecimal.x])
						fitscore[(IMG_INT)fitpoint[k].xyDecimal.x] = fittingscore;
				}
			}
			for (int k = 0; k < LineLen; k++)
				TempLine.FittingScore += fitscore[k];
			if(m_fStep >= 1.0)
				TempLine.FittingScore /= LineLen/ m_fStep;
			else
				TempLine.FittingScore /= LineLen;


			if ((ErrorTimes >= 1 && abs(ErrorRecord[ErrorTimes * 3] - ErrorRecord[(ErrorTimes - 1) * 3]) <= ItePrecision)
				|| (ErrorTimes >= 0 && ErrorRecord[ErrorTimes*3]-0.0f < 1e-7))
			{
				TempLine.Slope = MatB[0];
				TempLine.b = MatB[1];
				TempLine.Score = Length;
				//TempLine.FittingScore = ErrorRecord[FLAG * 3];
				TempLine.PointStart.y = TempLine.Slope*TempLine.PointStart.x + TempLine.b;
				TempLine.PointEnd.y = TempLine.Slope*TempLine.PointEnd.x + TempLine.b;
				FittingResult_Vec.push_back(TempLine);
				break;
			}
			if (ErrorTimes == IteMaxTimes - 1)
			{
				IMG_INT FLAG = 0;
				for (IMG_INT k = 0; k < IteMaxTimes - 1; k++)
				{
					if (ErrorRecord[3 * k] < ErrorRecord[3 * (k + 1)])
						ErrorRecord[3 * (k + 1)] = ErrorRecord[3 * k];
					else
						FLAG = k + 1;
				}

				TempLine.Slope = ErrorRecord[FLAG * 3 + 1];
				TempLine.b = ErrorRecord[FLAG * 3 + 2];
				//TempLine.FittingScore = ErrorRecord[FLAG * 3];
				TempLine.Score = Length;
				TempLine.PointStart.y = TempLine.Slope*TempLine.PointStart.x + TempLine.b;
				TempLine.PointEnd.y = TempLine.Slope*TempLine.PointEnd.x + TempLine.b;
				FittingResult_Vec.push_back(TempLine);
				break;
			}
			
			for (IMG_INT j = 0; j < Length; j++)
			{
				MatACopy[j * 2 + 0] = MatA[j * 2 + 0];
				MatACopy[j * 2 + 1] = MatA[j * 2 + 1];

				//Weight[j] = 1.0 / (1.f + exp(MatCCopy[j] * MatCCopy[j] / (ErrorRecord[ErrorTimes * 3] * ErrorRecord[ErrorTimes * 3])));
				Weight[j] = 1.0 / (1.f + exp(MatCCopy[j] * MatCCopy[j] / (Sigma*Sigma)));
				MatACopy[j * 2 + 0] = Weight[j] * MatACopy[j * 2 + 0];
				MatACopy[j * 2 + 1] = Weight[j] * MatACopy[j * 2 + 1];


				MatCCopy[j] = MatC[j] * Weight[j]; //reset MatCCopy after calculating error
			}
			//_CrtDumpMemoryLeaks();
			LAPACKE_dgels(LAPACK_ROW_MAJOR, 'N', Length, 2, 1, MatACopy, 2, MatCCopy, 1);//fitting slope and b

			MatB[0] = MatCCopy[0];
			MatB[1] = MatCCopy[1];
			for (IMG_INT j = 0; j < Length; j++) //reset MatCCopy after fitting line
			{
				MatCCopy[j] = MatC[j];
			}
			ErrorTimes++;
		}
		delete[]MatACopy;
		delete[]MatCCopy;
		delete[]Weight;
		//EdgePointsX.clear();

	}
	mkl_free_buffers();
	//step: reject overlap

	lineNums = FittingResult_Vec.size();
	FittingResult = new LINE_INFO2D[lineNums];
	for (int i = 0; i < lineNums; i++)
	{
		FittingResult[i] = FittingResult_Vec[i];
		FittingResult[i].PointStart.y = FittingResult[i].PointStart.x*FittingResult[i].Slope + FittingResult[i].b;
	}
	FittingResult_Vec.clear();	
}
IMG_VVOID CVisLine::RejectLineOutOfAngleRange(LINE_INFO2D *&FittingResult, IMG_INT &lineNums, IMG_REAL rAngleTor)
{
	IMG_REAL angle;
	for (int i = 0; i < lineNums; i++)
	{
		angle = atan(FittingResult[i].Slope)*180/PI;
		if (fabs(angle) > rAngleTor)
		{
			FittingResult[i] = FittingResult[lineNums - 1];
			lineNums--;
			i--;
		}
	}
}
IMG_VVOID CVisLine::RejectLineOutOfLengthRange(LINE_INFO2D *&FittingResult, IMG_INT &lineNums, IMG_REAL rLengthPercent)
{
	IMG_REAL ROILength = ALIGN_DIST(m_LineInputPara.PointStart, m_LineInputPara.PointEnd);
	for (int i = 0; i < lineNums; i++)
	{
		IMG_REAL length = ALIGN_DIST(FittingResult[i].PointStart, FittingResult[i].PointEnd);
		if (length < ROILength*rLengthPercent)
		{
			FittingResult[i] = FittingResult[lineNums - 1];
			lineNums--;
			i--;
		}
	}
}

IMG_VVOID  CVisLine::RejectOverlapLine(LINE_INFO2D *&FittingResult, IMG_INT &lineNums, EdgePointLine *&EdgePts, IMG_INT &ptNums, const IMG_SIZE &size, IMG_REAL margin)
{
	if (lineNums < 2)
	{
		return;
	}
	IMG_RCOORD ptLeft, ptRight;
	IMG_REAL leftDis, rightDis;
	if (m_scanDir == RECTSCANDIR::LEFTHAND)
	{
		ptLeft.x = 0; ptLeft.y = size.height - 1;
		ptRight.x = size.width - 1; ptRight.y = size.height - 1;
	}
	else
	{
		ptLeft.x = 0; ptLeft.y = 0;
		ptRight.x = size.width - 1; ptRight.y = 0;
	}
	IMG_INT iDark = 0; IMG_INT iLight = 0;
	IMG_LREAL Denominator;
	IMG_INT iLength = 0;
	for (int i = 0; i < lineNums; i++)
	{
		iDark = 0; IMG_INT iLight = 0; iLength = 0;;
		Denominator = pow(FittingResult[i].Slope * FittingResult[i].Slope + 1, 0.5);
		if (FittingResult[i].edgeType == EDGETYPE::ANY)
		{
			for (int j = 0; j < ptNums; j++)
			{
				float a = abs(FittingResult[i].Slope * EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + FittingResult[i].b) / Denominator;
				if (abs(FittingResult[i].Slope * EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + FittingResult[i].b) / Denominator <= m_ScoreAcceptDistance)
				{
					if ((((EdgePts[j].angle > 270 - m_HoughLinePara.HoughAngleTol) && (EdgePts[j].angle < 270 + m_HoughLinePara.HoughAngleTol)) && m_scanDir == RECTSCANDIR::LEFTHAND)
						|| (((EdgePts[j].angle > 90 - m_HoughLinePara.HoughAngleTol) && (EdgePts[j].angle < 90 + m_HoughLinePara.HoughAngleTol)) && m_scanDir == RECTSCANDIR::RIGHTHAND))
					{
						iDark++;
					}
					else if ((((EdgePts[j].angle > 270 - m_HoughLinePara.HoughAngleTol) && (EdgePts[j].angle < 270 + m_HoughLinePara.HoughAngleTol)) && m_scanDir == RECTSCANDIR::RIGHTHAND)
						|| (((EdgePts[j].angle > 90 - m_HoughLinePara.HoughAngleTol) && (EdgePts[j].angle < 90 + m_HoughLinePara.HoughAngleTol)) && m_scanDir == RECTSCANDIR::LEFTHAND))
					{
						iLight++;
					}
					iLength++;
				}
			}
			if (iLight > iDark)
			{
				if ((float)iLight / (float)iLength > 0.85)
				{
					FittingResult[i].edgeType = EDGETYPE::LIGHT2DARK;
				}
				else
				{
					FittingResult[i].edgeType = EDGETYPE::ANY;
				}
			}
			else
			{
				if ((float)iDark / (float)iLength > 0.85)
				{
					FittingResult[i].edgeType = EDGETYPE::DARK2LIGHT;
				}
				else
				{
					FittingResult[i].edgeType = EDGETYPE::ANY;
				}
			}
		}
		leftDis = abs(FittingResult[i].Slope * ptLeft.x - ptLeft.y + FittingResult[i].b) / Denominator;
		rightDis = abs(FittingResult[i].Slope * ptRight.x - ptRight.y + FittingResult[i].b) / Denominator;
		FittingResult[i].dist = leftDis + rightDis;
	}
	QuickSort(FittingResult, lineNums, 0, lineNums - 1);
	
	vector<LINE_INFO2D> tempLine; tempLine.clear();
	for (int i = 0; i < lineNums; i++)
	{
		if (m_edgeDir == EDGETYPE::ANY)
		{
			tempLine.push_back(FittingResult[i]);
		}
		else
		{
			if (FittingResult[i].edgeType == EDGETYPE::ANY)
			{
				continue;
			}
			else
			{
				tempLine.push_back(FittingResult[i]);
			}
		}
	}
	IMG_RCOORD intePt;
	if (tempLine.size() < 1)
	{
		lineNums = 0;
		return;
	}
	//for (int i = 0; i < tempLine.size() - 1; i++)
	//{
	//	intePt.x = -(tempLine[i].b - tempLine[i + 1].b) / (tempLine[i].Slope - tempLine[i + 1].Slope);
	//	intePt.y = tempLine[i].Slope*intePt.x + tempLine[i].b;
	//	if (intePt.x > 0 && intePt.x < size.width - 1 && intePt.y>0 && intePt.y < size.height - 1 && tempLine[i].edgeType == tempLine[i + 1].edgeType)
	//	{
	//		if (tempLine[i].houghScore > tempLine[i + 1].houghScore)
	//		{
	//			tempLine.erase(tempLine.begin() + i + 1);
	//		}
	//		else
	//		{
	//			tempLine.erase(tempLine.begin() + i);
	//			i--;
	//		}
	//	}
	//}
	IMG_INT numTemp = tempLine.size();
	for (int i = 0; i < tempLine.size(); i++)
	{
		for (int j = i + 1; j < tempLine.size(); j++)
		{
			IMG_REAL dist1, dist2, length_i, length_j;
			IMG_INT reject = 0;
			dist1 = (tempLine[i].PointStart.x*tempLine[i].Slope + tempLine[i].b) - (tempLine[i].PointStart.x*tempLine[j].Slope + tempLine[j].b);
			dist2 = (tempLine[i].PointEnd.x*tempLine[i].Slope + tempLine[i].b) - (tempLine[i].PointEnd.x*tempLine[j].Slope + tempLine[j].b);
			intePt.x = -(tempLine[i].b - tempLine[j].b) / (tempLine[i].Slope - tempLine[j].Slope);
			intePt.y = tempLine[i].Slope*intePt.x + tempLine[i].b;
			length_i = ALIGN_DIST(tempLine[i].PointStart, tempLine[i].PointEnd);
			length_j = ALIGN_DIST(tempLine[j].PointStart, tempLine[j].PointEnd);
			//two line cross
			if (intePt.x > 0 && intePt.x < size.width - 1 && intePt.y>0 && intePt.y < size.height - 1 && tempLine[i].edgeType == tempLine[i + 1].edgeType)
			{
				reject = 1;
			}
			if (fabs(dist1) <= 1 && fabs(dist2) <= 1)
			{
				reject = 1;
			}
			//two line too close
			if(reject)
			{
				if (tempLine[i].Score*0.5f > (tempLine[j].Score + 0.01f) || length_i*0.5f > length_j)
				{
					tempLine.erase(tempLine.begin() + j);
					j--;
				}
				else if (tempLine[j].Score*0.5f > (tempLine[i].Score + 0.01f) || length_j*0.5f > length_i)
				{
					tempLine.erase(tempLine.begin() + i);
					i--;
					break;
				}

				if (tempLine[i].FittingScore * margin > tempLine[j].FittingScore)
				{
					tempLine.erase(tempLine.begin() + j);
					j--;
				}
				else if(tempLine[j].FittingScore * margin > tempLine[i].FittingScore)
				{
					tempLine.erase(tempLine.begin() + i);
					i--;
					break;
				}
			}
		}
	}

	lineNums = tempLine.size();
	for (int i = 0; i < lineNums; i++)
	{
		FittingResult[i] = tempLine[i];
	}
	tempLine.clear();
	
}

IMG_VVOID CVisLine::QuickSort(LINE_INFO2D *&ScoreResult, IMG_INT &lineNums, IMG_INT low, IMG_INT high)
{
	if (low < high)
	{
		int i, j;
		i = low - 1;
		j = low;
		while (j < high)
		{
			
			if (ScoreResult[j].dist < ScoreResult[high].dist)
				swap(ScoreResult[++i], ScoreResult[j]);
			j++;
			

		}
		swap(ScoreResult[++i], ScoreResult[high]);    
		int index = i;

		QuickSort(ScoreResult, lineNums, low, index - 1);
		QuickSort(ScoreResult, lineNums, index + 1, high);
	}
}

IMG_VVOID  CVisLine::ScoreInMask(LINE_INFO2D *&ScoreResult, IMG_INT &lineNums, EdgePointLine *&EdgeDetecResult, IMG_INT &edgeNums, IMG_UBBUF *&pMask, const IMG_REAL &ScoreAcceptDistance)
{
	IMG_REAL PointPer, LineDis, XDiff, YDiff, Denominator, KBrecord, DenoSquare, TempVote, angle;
	IMG_INT TempX, TempY, Distance, Count, FLAG, RoundTemp, ScoreSum, LineLength;
	IMG_INT *VoteNum, effect_seg_length;
	IMG_RCOORD startpt, endpt, pt;
	CVisMemPool pool;

	XDiff = m_LineInputPara.PointStart.x - m_LineInputPara.PointEnd.x;
	YDiff = m_LineInputPara.PointStart.y - m_LineInputPara.PointEnd.y;
	LineDis = pow(XDiff * XDiff + YDiff * YDiff, 0.5);

	for (IMG_INT i = 0; i < lineNums; i++)
	{
		pool.Push();
		effect_seg_length = 1;
		startpt.x = 0;
		startpt.y = ScoreResult[i].Slope*startpt.x + ScoreResult[i].b;
		endpt.x = pMask->size.width - 1;
		endpt.y = ScoreResult[i].Slope*endpt.x + ScoreResult[i].b;
		LineDis = ALIGN_DIST(startpt, endpt);
		LineLength = ceil(LineDis);
		//step: calculate Line's valid distance
		VoteNum = (IMG_INT*)pool.Malloc(sizeof(IMG_INT)*LineLength);
		VALIDATE_MALLOC(VoteNum);
		angle = atan(ScoreResult[i].Slope);
		for (IMG_INT j = 0; j < LineLength-1; j++)
		{
			pt.x = j*cos(angle);
			pt.y = j*sin(angle) + ScoreResult[i].b;
			if (pt.x >= 0 && pt.y >= 0 && pt.x < pMask->size.width - 2 && pt.y < pMask->size.height - 2)
			{
				if (pMask->ptr[(IMG_INT)(pt.x + 0.5) + (IMG_INT)(pt.y + 0.5)*pMask->linestep])
					effect_seg_length++;
			}

		}

		//VoteNum = (IMG_INT*)pool.Malloc(sizeof(IMG_INT) * ceil(LineDis)); //precomputation
		Denominator = pow(ScoreResult[i].Slope * ScoreResult[i].Slope + 1, 0.5);
		KBrecord = ScoreResult[i].Slope * ScoreResult[i].b;
		DenoSquare = Denominator * Denominator;

		//step: compute correspond point to the point in line within the accepted distance 
		for (IMG_INT j = 0; j < ceil(LineDis); j++)
			VoteNum[j] = 0;

		for (IMG_INT j = 0; j < edgeNums; j++)
		{
			if (abs(ScoreResult[i].Slope * EdgeDetecResult[j].xyDecimal.x - EdgeDetecResult[j].xyDecimal.y + ScoreResult[i].b) / Denominator <= ScoreAcceptDistance)
			{
				TempX = round((EdgeDetecResult[j].xyDecimal.x + ScoreResult[i].Slope * EdgeDetecResult[j].xyDecimal.y - KBrecord) / DenoSquare);
				TempY = round(ScoreResult[i].Slope * TempX + ScoreResult[i].b);
				TempVote = (EdgeDetecResult[j].xyDecimal.x + ScoreResult[i].Slope * EdgeDetecResult[j].xyDecimal.y - KBrecord) / DenoSquare - ScoreResult[i].PointStart.x;
				if ((TempVote < 0) || (pMask->ptr[TempY * pMask->size.width + TempX] == 0))
					continue;
				else
				{
					RoundTemp = round(TempVote);
					if (RoundTemp < ceil(LineDis))
					{
						VoteNum[RoundTemp] = 1;
						//if (TempVote - RoundTemp > 0 && (RoundTemp < ceil(LineDis) - 1))
						//	VoteNum[RoundTemp++] = 1;
					}
				}
			}
		}
		ScoreSum = 0;
		for (IMG_INT j = 0; j < ceil(LineDis); j++)
			ScoreSum += VoteNum[j];
		if(m_searchType != SEARCH_TYPE::GAUGE || m_fStep < 1.0f)
			ScoreResult[i].Score = (IMG_REAL)ScoreSum / effect_seg_length * 100.f;
		else
			ScoreResult[i].Score = (IMG_REAL)ScoreSum*m_fStep / effect_seg_length * 100.f;
		if (ScoreResult[i].Score > 100)ScoreResult[i].Score = 100;
		pool.Pop();
	}

}

IMG_VVOID CVisLine::LineFinalResult(LINE_INFO2D *&FinalFittingResult, IMG_INT &lineNums, EdgePointLine *&EdgePts, IMG_INT &ptNums, const IMG_REAL &ScoreAcceptDistance)
{
	CVisMemPool pool;
	IMG_REAL Xmin, Xmax, Xtemp, minAngle, maxAngle, fittingscore;
	vector <IMG_REAL> EdgePointsX;
	//vector <IMG_REAL>lineEdgeAngle;
	//IMG_INT lineNums = lineNums;
	IMG_INT PtNums = ptNums;
	IMG_UINT LineLen = ALIGN_DIST(m_LineInputPara.PointStart, m_LineInputPara.PointEnd);
	IMG_REAL *fitscore = (IMG_REAL *)pool.Malloc(LineLen * sizeof(IMG_REAL)), step = 1;
	IMG_REAL *PtLineEdgeGradient = (IMG_REAL *)pool.Malloc(LineLen * sizeof(IMG_REAL));
	VALIDATE_MALLOC(fitscore);
	vector<LINE_INFO2D>resLine;
	if (m_searchType == SEARCH_TYPE::GAUGE)step = m_fStep;

	for (int i = 0; i < lineNums; i++)
	{
		IMG_REAL LineEdgeGradient = 0.f;
		for (int j = 0; j < LineLen; j++)fitscore[j] = -1;
		for (int j = 0; j < LineLen; j++)PtLineEdgeGradient[j] = -1;
		double Denominator = pow(FinalFittingResult[i].Slope*FinalFittingResult[i].Slope + 1, 0.5);
		for (int j = 0; j < PtNums; j++)
		{
			double dis = abs(FinalFittingResult[i].Slope*EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + FinalFittingResult[i].b) / Denominator;
			if (dis <= ScoreAcceptDistance)
			{
				//LineEdgeGradient += (IMG_REAL)EdgePts[j].gradient;
				//lineEdgeAngle.push_back(EdgeDetecResult[j].angle);
				//Length++;
				if (FinalFittingResult[i].Slope < 0.01)
				{
					Xtemp = EdgePts[j].xyDecimal.x;
				}
				else
				{
					Xtemp = (EdgePts[j].xyDecimal.x / FinalFittingResult[i].Slope + EdgePts[j].xyDecimal.y - FinalFittingResult[i].b) / (FinalFittingResult[i].Slope + 1.f / FinalFittingResult[i].Slope);
				}
				EdgePointsX.push_back(Xtemp);
			}
		}
		fittingscore = 0;
		IMG_INT count = 0;
		for (int j = 0; j < ptNums; j++)
		{
			double dis = fabs(FinalFittingResult[i].Slope*EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + FinalFittingResult[i].b) / Denominator;
			if (dis < ScoreAcceptDistance)
			{
				IMG_REAL high = m_LineFittingPara.LineFittingSigma / 3 > 1 ? m_LineFittingPara.LineFittingSigma / 3 : 1;
				IMG_REAL low = m_LineFittingPara.LineFittingSigma > high + 0.1 ? m_LineFittingPara.LineFittingSigma : high + 0.1;
				fittingscore = VisAlign::Align_Sigmoid(dis, high, low);
				SYS_Assert(EdgePts[j].xyInteger.x >= 0 && EdgePts[j].xyInteger.x < LineLen);
				if (fittingscore > fitscore[EdgePts[j].xyInteger.x])
					fitscore[EdgePts[j].xyInteger.x] = fittingscore;
				if (EdgePts[j].gradient > PtLineEdgeGradient[EdgePts[j].xyInteger.x])
					PtLineEdgeGradient[EdgePts[j].xyInteger.x] = EdgePts[j].gradient;
			}
		}
		fittingscore = 0;
		for (int j = 0; j < LineLen; j++)
		{
			if(fitscore[j] > 0)fittingscore += fitscore[j];
		}
		if(step>=1.0f)fittingscore *= step;
		LineEdgeGradient = 0;
		for (int j = 0; j < LineLen; j++)
		{
			if (PtLineEdgeGradient[j] > 0)
			{
				LineEdgeGradient += PtLineEdgeGradient[j];
				count++;
			}
		}
		if (EdgePointsX.size() < 2)
		{
			continue;
		}
		//if (Length < 2)
		//{
		//	continue;
		//}
		Xmin = *min_element(EdgePointsX.begin(), EdgePointsX.end());
		Xmax = *max_element(EdgePointsX.begin(), EdgePointsX.end());
		FinalFittingResult[i].PointStart.x = Xmin;
		FinalFittingResult[i].PointStart.y = FinalFittingResult[i].PointStart.x*FinalFittingResult[i].Slope + FinalFittingResult[i].b;
		FinalFittingResult[i].PointEnd.x = Xmax;
		FinalFittingResult[i].PointEnd.y = FinalFittingResult[i].PointEnd.x*FinalFittingResult[i].Slope + FinalFittingResult[i].b;
		IMG_INT Length = ALIGN_DIST(FinalFittingResult[i].PointStart, FinalFittingResult[i].PointEnd);
		FinalFittingResult[i].EdgeGradient = LineEdgeGradient / (count+1e-5);
		if (m_searchType == SEARCH_TYPE::SOBEL_IPP)
		{
			if (m_sobelSize == SOBELMSKSIZE::kerSize3x3)
			{
				FinalFittingResult[i].EdgeGradient /= 4;
			}
			if (m_sobelSize == SOBELMSKSIZE::kerSize5x5)
			{
				FinalFittingResult[i].EdgeGradient /= 48;
			}
		}
		//if (m_fStep > 1.0f)FinalFittingResult[i].EdgeGradient *= m_fStep;
		FinalFittingResult[i].FittingScore = fittingscore / (Length+step+1e-5);
		EdgePointsX.clear();
		resLine.push_back(FinalFittingResult[i]);
	}

	lineNums = resLine.size();
	for (int i = 0; i < lineNums; i++)
	{
		FinalFittingResult[i] = resLine[i];
	}
	EdgePointsX.clear();
	resLine.clear();
}

IMG_VVOID  CVisLine::Score(LINE_INFO2D *&ScoreResult, IMG_INT &lineNums, EdgePointLine *&EdgeDetecResult, IMG_INT &edgeNums, IMG_REAL ScoreAcceptDistance)
{
	IMG_REAL LineDis, Denominator, KBrecord, DenoSquare, ScoreSum, TempVote, XDiff, YDiff;
	IMG_INT FloorTemp;
	IMG_INT *VoteNum;

	XDiff = m_LineInputPara.PointStart.x - m_LineInputPara.PointEnd.x;
	YDiff = m_LineInputPara.PointStart.y - m_LineInputPara.PointEnd.y;
	LineDis = pow(XDiff * XDiff + YDiff * YDiff, 0.5);
	for (IMG_INT i = 0; i < lineNums; i++)
	{
		VoteNum = new IMG_INT[(int)ceil(LineDis)];

		int testI = (int)ceil(LineDis);
		//VoteNum = (IMG_INT*)pool.Malloc(sizeof(IMG_INT) * ceil(LineDis));
		Denominator = pow(ScoreResult[i].Slope * ScoreResult[i].Slope + 1, 0.5);
		KBrecord = ScoreResult[i].Slope * ScoreResult[i].b;
		DenoSquare = Denominator * Denominator;

		for (IMG_INT j = 0; j < ceil(LineDis); j++)
			VoteNum[j] = 0;

		for (IMG_INT j = 0; j < edgeNums; j++)
		{
			if (abs(ScoreResult[i].Slope * EdgeDetecResult[j].xyDecimal.x - EdgeDetecResult[j].xyDecimal.y + ScoreResult[i].b) / Denominator <= ScoreAcceptDistance)
			{
				TempVote = (EdgeDetecResult[j].xyDecimal.x + ScoreResult[i].Slope * EdgeDetecResult[j].xyDecimal.y - KBrecord) / DenoSquare - ScoreResult[i].PointStart.x;
				if (TempVote < 0 || (int)round(TempVote) - (int)ceil(LineDis) >= 0)
					continue;
				else
				{
					FloorTemp = round(TempVote);
					VoteNum[FloorTemp] = 1;
					/*if (TempVote - FloorTemp > 0)
					{
						VoteNum[FloorTemp++] = 1;
					}*/

				}
			}
		}
		//assert(_CrtCheckMemory());

		ScoreSum = 0;
		for (IMG_INT j = 0; j < ceil(LineDis); j++)
			ScoreSum += (IMG_REAL)VoteNum[j];
		//ScoreResult[i].Score = (IMG_REAL)ScoreSum / ceil(LineDis) * 100;
		if (m_searchType != SEARCH_TYPE::GAUGE || m_fStep < 1.0f)
			ScoreResult[i].Score = (IMG_REAL)ScoreSum / (ceil(LineDis)) * 100.f;
		else
			ScoreResult[i].Score = (IMG_REAL)ScoreSum*m_fStep / (ceil(LineDis)) * 100.f;
		if (ScoreResult[i].Score > 100)ScoreResult[i].Score = 100;

		if (VoteNum)
		{
			delete[]VoteNum;
			VoteNum = nullptr;
		}
		

	}
}

IMG_VVOID  CVisLine::LineSelection(LINE_INFO2D *&ScoreResult, IMG_INT &lineNums, EdgePointLine *&EdgePts, IMG_INT &ptNums, const SELECTIONMODE &select, IMG_RCOORD rcoSelPtStart, IMG_RCOORD rcoSelPtEnd)
{
	IMG_INT currentLineNum = lineNums;
	if (lineNums < 1)return;
	LINE_INFO2D *tempLine = new LINE_INFO2D[lineNums];
	for (int i = 0; i < currentLineNum; i++)
	{
		tempLine[i] = ScoreResult[i];
	}
	for (int i = 0; i < currentLineNum; i++)
	{
		if (ScoreResult[i].Score < m_fScore)
		{
			ScoreResult[i] = ScoreResult[currentLineNum - 1];
			currentLineNum--;
			i--;
		}
	}
	if (currentLineNum < 1 )
	{
		for (int i = 0; i < lineNums - 1; i++)
		{
			if (tempLine[i].Score > tempLine[i + 1].Score)
			{
				tempLine[i + 1] = tempLine[i];
			}
		}
		currentLineNum = 1;
		ScoreResult[0] = tempLine[lineNums - 1];
	}
	delete[]tempLine; tempLine = nullptr;
	QuickSort(ScoreResult, currentLineNum, 0, currentLineNum - 1);
	if (m_edgeDir == EDGETYPE::BLACKCENTER ||m_edgeDir==EDGETYPE::WHITECENTER)
	{
		BlackAndWhiteChoice(ScoreResult, currentLineNum, m_edgeDir);
	}
	if (currentLineNum == 0)
	{
		lineNums = 0;
		return;
	}
	switch (select)
	{
	case SELECTIONMODE::all: {
		
		break;
	}
	case SELECTIONMODE::best: {
		IMG_REAL maxGrad = 0.0;
		IMG_INT index ;
		for (int i = 0; i < currentLineNum; i++)
		{
			if (ScoreResult[i].EdgeGradient > maxGrad)
			{
				maxGrad = ScoreResult[i].EdgeGradient;
				index = i;
			}
		}
		currentLineNum = 1;
		ScoreResult[0] = ScoreResult[index];
		break;
	}

	case SELECTIONMODE::highscore: {
		//vector<IMG_REAL> fittingDis;
		//vector<IMG_REAL> lineScore;
		//IMG_REAL tempDis; 
		IMG_REAL maxDis = 0.f;
		//for (int i = 0; i < currentLineNum; i++)
		//{
		//	lineScore.clear();
		//	tempDis = 0.f;
		//	IMG_REAL Denominator = pow(ScoreResult[i].Slope * ScoreResult[i].Slope + 1, 0.5);
		//	IMG_INT count = 0;
		//	for (int j = 0; j < ptNums; j++)
		//	{
		//		if (fabs(ScoreResult[i].Slope*EdgePts[j].xyDecimal.x + ScoreResult[i].b - EdgePts[j].xyDecimal.y) / Denominator < m_ScoreAcceptDistance)
		//		{
		//			tempDis = fabs(ScoreResult[i].Slope*EdgePts[j].xyDecimal.x + ScoreResult[i].b - EdgePts[j].xyDecimal.y);
		//			lineScore.push_back(tempDis);
		//		}
		//	}
		//	maxDis = *max_element(lineScore.begin(), lineScore.end());
		//	tempDis = 0.f;
		//	for (int k = 0; k < lineScore.size(); k++)
		//	{
		//		tempDis += (1.f / (1 + exp(lineScore[k] * lineScore[k]) / (m_LineFittingPara.LineFittingSigma*m_LineFittingPara.LineFittingSigma)));
		//	}
		//	tempDis /= lineScore.size();
		//	fittingDis.push_back(tempDis);
		//}
		IMG_INT index = 0; maxDis = 0.f;
		for (int i = 0; i < currentLineNum; i++)
		{
			if (ScoreResult[i].FittingScore > maxDis)
			{
				maxDis = ScoreResult[i].FittingScore;
				index = i;
			}
		}
		currentLineNum = 1;
		ScoreResult[0] = ScoreResult[index];
		//lineScore.clear();
		//fittingDis.clear();
		break;
	}

	case SELECTIONMODE::selectpoint: {
		IMG_REAL disSum = 1e+6;
		IMG_REAL tempsum;
		IMG_INT indexI;
		for (int i = 0; i < currentLineNum; i++)
		{
			tempsum = 0.f;
			tempsum += fabs(ScoreResult[i].Slope*rcoSelPtStart.x + ScoreResult[i].b - rcoSelPtStart.y) / pow(ScoreResult[i].Slope*ScoreResult[i].Slope + 1, 0.5);
			tempsum += fabs(ScoreResult[i].Slope*rcoSelPtEnd.x + ScoreResult[i].b - rcoSelPtEnd.y) / pow(ScoreResult[i].Slope*ScoreResult[i].Slope + 1, 0.5);
			if (tempsum < disSum)
			{
				disSum = tempsum;
				indexI = i;
			}
		}
		currentLineNum = 1;
		ScoreResult[0] = ScoreResult[indexI];
		break;
	}
	}
	
	lineNums = currentLineNum;
	return;
}

IMG_VVOID CVisLine::BlackAndWhiteChoice(LINE_INFO2D *&ScoreResult, IMG_INT &lineNums, const EDGETYPE &select)
{
	if (select != EDGETYPE::BLACKCENTER&&select != EDGETYPE::WHITECENTER)
	{
		return;
	}
	if (lineNums < 2 && m_searchType != SEARCH_TYPE::GAUGE)
	{
		lineNums = 0;
		return;
	}
	vector<LINE_INFO2D>lineFinal; lineFinal.clear();
	LINE_INFO2D tempLine;
	if (select == EDGETYPE::BLACKCENTER)
	{
		if (m_searchType != SEARCH_TYPE::GAUGE)
		{
			for (int i = 0; i < lineNums - 1; i++)
			{
				//if ((ScoreResult[i].edgeType == EDGETYPE::LIGHT2DARK&&ScoreResult[i + 1].edgeType == EDGETYPE::DARK2LIGHT&&m_scanDir == RECTSCANDIR::LEFTHAND)|| (ScoreResult[i].edgeType == EDGETYPE::DARK2LIGHT&&ScoreResult[i + 1].edgeType == EDGETYPE::LIGHT2DARK&&m_scanDir == RECTSCANDIR::RIGHTHAND))
				if ((ScoreResult[i].edgeType == EDGETYPE::LIGHT2DARK&&ScoreResult[i + 1].edgeType == EDGETYPE::DARK2LIGHT))
				{
					IMG_REAL start_dist = fabs(ScoreResult[i].PointStart.y - ScoreResult[i + 1].PointStart.y), end_dist = fabs(ScoreResult[i].PointEnd.y - ScoreResult[i + 1].PointEnd.y);
					if (m_MaxBlackWhiteCenterWidth < 0 || (m_MaxBlackWhiteCenterWidth > start_dist && m_MaxBlackWhiteCenterWidth > end_dist))
					{
						tempLine.PointStart.x = (ScoreResult[i].PointStart.x + ScoreResult[i + 1].PointStart.x) / 2;
						tempLine.PointStart.y = (ScoreResult[i].PointStart.y + ScoreResult[i + 1].PointStart.y) / 2;
						tempLine.PointEnd.x = (ScoreResult[i].PointEnd.x + ScoreResult[i + 1].PointEnd.x) / 2;
						tempLine.PointEnd.y = (ScoreResult[i].PointEnd.y + ScoreResult[i + 1].PointEnd.y) / 2;
						tempLine.Slope = (tempLine.PointEnd.y - tempLine.PointStart.y) / (tempLine.PointEnd.x - tempLine.PointStart.x+1e-10);
						tempLine.b = tempLine.PointEnd.y - tempLine.PointEnd.x*tempLine.Slope;
						tempLine.Score = (ScoreResult[i].Score + ScoreResult[i + 1].Score) / 2;
						tempLine.edgeType = EDGETYPE::BLACKCENTER;
						tempLine.EdgeGradient = (ScoreResult[i].EdgeGradient + ScoreResult[i + 1].EdgeGradient) / 2;
						tempLine.dist = (ScoreResult[i].dist + ScoreResult[i + 1].dist) / 2;
						tempLine.houghScore = (ScoreResult[i].houghScore + ScoreResult[i + 1].houghScore) / 2;
						tempLine.FittingScore = (ScoreResult[i].FittingScore + ScoreResult[i + 1].FittingScore) / 2;
						lineFinal.push_back(tempLine);
					}

				}
			}
		}
		else
		{
			for (int i = 0; i < lineNums; i++)
				lineFinal.push_back(ScoreResult[i]);
		}

	}
	if (select == EDGETYPE::WHITECENTER)
	{
		if (m_searchType != SEARCH_TYPE::GAUGE)
		{
			for (int i = 0; i < lineNums - 1; i++)
			{
				//if ((ScoreResult[i].edgeType == EDGETYPE::LIGHT2DARK&&ScoreResult[i + 1].edgeType == EDGETYPE::DARK2LIGHT&&m_scanDir == RECTSCANDIR::RIGHTHAND) || (ScoreResult[i].edgeType == EDGETYPE::DARK2LIGHT&&ScoreResult[i + 1].edgeType == EDGETYPE::LIGHT2DARK&&m_scanDir == RECTSCANDIR::LEFTHAND))
				if (ScoreResult[i].edgeType == EDGETYPE::DARK2LIGHT&&ScoreResult[i + 1].edgeType == EDGETYPE::LIGHT2DARK)
				{
					IMG_REAL start_dist = fabs(ScoreResult[i].PointStart.y - ScoreResult[i + 1].PointStart.y), end_dist = fabs(ScoreResult[i].PointEnd.y - ScoreResult[i + 1].PointEnd.y);
					if (m_MaxBlackWhiteCenterWidth < 0 || (m_MaxBlackWhiteCenterWidth > start_dist && m_MaxBlackWhiteCenterWidth > end_dist))
					{
						tempLine.PointStart.x = (ScoreResult[i].PointStart.x + ScoreResult[i + 1].PointStart.x) / 2;
						tempLine.PointStart.y = (ScoreResult[i].PointStart.y + ScoreResult[i + 1].PointStart.y) / 2;
						tempLine.PointEnd.x = (ScoreResult[i].PointEnd.x + ScoreResult[i + 1].PointEnd.x) / 2;
						tempLine.PointEnd.y = (ScoreResult[i].PointEnd.y + ScoreResult[i + 1].PointEnd.y) / 2;
						tempLine.Slope = (tempLine.PointEnd.y - tempLine.PointStart.y) / (tempLine.PointEnd.x - tempLine.PointStart.x);
						tempLine.b = tempLine.PointEnd.y - tempLine.PointEnd.x*tempLine.Slope;
						tempLine.Score = (ScoreResult[i].Score + ScoreResult[i + 1].Score) / 2;
						tempLine.edgeType = EDGETYPE::WHITECENTER;
						tempLine.EdgeGradient = (ScoreResult[i].EdgeGradient + ScoreResult[i + 1].EdgeGradient) / 2;
						tempLine.dist = (ScoreResult[i].dist + ScoreResult[i + 1].dist) / 2;
						lineFinal.push_back(tempLine);
					}
				}
			}
		}
		else
		{
			for (int i = 0; i < lineNums; i++)
				lineFinal.push_back(ScoreResult[i]);
		}

	}
	lineNums = lineFinal.size();
	for (int i = 0; i < lineNums; i++)
	{
		ScoreResult[i] = lineFinal[i];
	}
	lineFinal.clear();
	return;
}

IMG_VVOID CVisLine::LineIntersection(const IMG_LRCOORD &line1Start, const IMG_LRCOORD &line1End, const IMG_LRCOORD &line2Start, const IMG_LRCOORD &line2End, IMG_LRCOORD &Point)
{
	IMG_LREAL line1Slope, line2Slope, line1b, line2b;
	if (fabs(line2Start.x - line2End.x) < 1e-4)
	{
		line1Slope = (line1End.y - line1Start.y) / (line1End.x - line1Start.x);
		line1b = line1Start.y - line1Start.x*line1Slope;
		Point.x = (line2Start.x + line2End.x) / 2;
		Point.y = line1Slope*Point.x + line1b;
		return;
	}
	line1Slope = (line1End.y - line1Start.y) / (line1End.x - line1Start.x);
	line2Slope = (line2End.y - line2Start.y) / (line2End.x - line2Start.x);
	line1b = line1Start.y - line1Start.x*line1Slope;
	line2b = line2Start.y - line2Start.x*line2Slope;
	if (abs(line1Slope - line2Slope) < 0.1)
	{
		return;
	}
	Point.x = (line2b - line1b) / (line1Slope - line2Slope);
	Point.y = line1Slope*Point.x + line1b;
	return;
}

IMG_INT CVisLine::CoorConvert_Negative(IMG_RCOORD OriginPtInSrc, double Angle, IMG_RCOORD srcPoint, IMG_RCOORD &dstPoint)
{
	IMG_RCOORD PointChange;

	srcPoint.x = srcPoint.x - OriginPtInSrc.x;
	srcPoint.y = srcPoint.y - OriginPtInSrc.y;

	dstPoint.x = srcPoint.x*cos(-Angle) - srcPoint.y*sin(-Angle);
	dstPoint.y = srcPoint.y*cos(-Angle) + srcPoint.x*sin(-Angle);

	return 0;
}
#if 1
IMG_INT CVisLine::DelLineNorse(EdgePointLine *&EdgePts, IMG_INT &ptNums, int breakNums)
{
	IMG_INT i, j;
	IMG_REAL pt_distance_thred = m_fStep*m_fDelEdgeDis, dist, mindist;
	list <EdgePointLine *> source;
	vector<EdgePointLine> result, buffer(ptNums);
	for (i = 0; i < ptNums; i++) source.push_back(EdgePts+i);
	source.sort(compare_edge_ref);
	while (source.size() > 0)
	{
		buffer.clear();
		auto itor = source.begin();
		EdgePointLine *lastpt = *itor;
		buffer.push_back(*lastpt);
		source.erase(itor);
		while (1)
		{
			mindist = 1e10;
			itor = source.begin();
			auto itor2 = itor, itor_mindist = itor;
			//find nearest pt to lastpt
			while (itor2 != source.end())
			{		
				dist = ((*itor2)->xyDecimal.x - lastpt->xyDecimal.x)*((*itor2)->xyDecimal.x - lastpt->xyDecimal.x) + ((*itor2)->xyDecimal.y - lastpt->xyDecimal.y)*((*itor2)->xyDecimal.y - lastpt->xyDecimal.y);
				if (mindist > dist && VisAlign::Angle_Difference(lastpt->angle, (*itor2)->angle) < 60)
				{
					mindist = dist;
					itor_mindist = itor2;
				}
				if ((*itor2)->xyDecimal.x - lastpt->xyDecimal.x > pt_distance_thred) break;
				itor2++;
			}
			//if within threshold, push to buffer, else break out.
			if (mindist < pt_distance_thred*pt_distance_thred)
			{
				buffer.push_back(**itor_mindist);
				lastpt = *itor_mindist;
				itor = source.erase(itor_mindist);
			}
			else
			{
				break;
			}
		}
		if (buffer.size() >= m_iDelEdgeNums/m_fStep)
		{
			result.insert(result.end(), buffer.begin(), buffer.end());
		}
	}
	i = 0;
	for (auto itor = result.begin();itor != result.end(); itor++, i++)
	{
		EdgePts[i] = *itor;
	}
	ptNums = result.size();
	return 0;
}
#else
IMG_INT CVisLine::DelLineNorse(EdgePointLine *&EdgePts, IMG_INT &ptNums, int breakNums)
{
	int i = 0, j = 0;
	IMG_REAL pt_distance_thred;
	/*if (m_searchType == SEARCH_TYPE::GAUGE)
	{
		pt_distance_thred = sqrt(m_fDelEdgeDis*m_fDelEdgeDis + m_fStep*m_fStep);
	}
	else
	{
		pt_distance_thred = m_fDelEdgeDis;
	}*/
	pt_distance_thred = m_fStep*m_fDelEdgeDis;
	int iIndex, jIndex;
	vector<EdgePointLine>resEdges, tempEdge;
	vector<vector<EdgePointLine>>vecResEdges;
	bool *bMark = new bool[ptNums]();
	int count = 0;
	vector<int>vecCount;
	int coutLength = 0;
	for (i = 0; i < ptNums - 1; i++)
	{
		iIndex = i;
		tempEdge.clear();
		tempEdge.push_back(EdgePts[iIndex]);
		vecCount.clear();
		vecCount.push_back(iIndex);
		count = 0;
		coutLength = 0;
		//if (bMark[i])continue;
		for (j = i + 1; j < ptNums; j++)
		{

			jIndex = j;
			if (/*!bMark[jIndex] && */fabs(EdgePts[iIndex].xyDecimal.x - EdgePts[jIndex].xyDecimal.x) < pt_distance_thred &&
				P2Pdis(EdgePts[iIndex].xyDecimal, EdgePts[jIndex].xyDecimal) < pt_distance_thred &&
				fabs(EdgePts[iIndex].angle - EdgePts[jIndex].angle) < 60)
			{
				if (fabs(EdgePts[iIndex].xyDecimal.x - EdgePts[jIndex].xyDecimal.x) > m_fStep / 2.f)
				{
					coutLength++;
				}
				vecCount.push_back(jIndex);
				tempEdge.push_back(EdgePts[jIndex]);
				iIndex = jIndex;
				count = 0;
			}
		/*	else
			{
				count++;
				if (count < breakNums)continue;
				break;
			}*/
		}
		if (coutLength > m_iDelEdgeNums)
		{
			/*for (int k = 0; k < tempEdge.size(); k++)
			{
				bMark[vecCount[k]] = true;
			}*/
			//vecResEdges.push_back(tempEdge);
			resEdges.insert(resEdges.end(), tempEdge.begin(), tempEdge.end());
		}
	}
	sort(resEdges.begin(), resEdges.end(), compare_edge_val);
	resEdges.erase(unique(resEdges.begin(), resEdges.end()), resEdges.end());
	ptNums = resEdges.size();
	for (i = 0; i < ptNums; i++)
	{
		EdgePts[i] = resEdges[i];
	}
	delete[]bMark;
	return 0;
}
#endif
IMG_INT CVisLine::DelLineEdge(LINE_INFO2D *&FinalFittingResult, IMG_INT &lineNums, EdgePointLine *&EdgePts, IMG_INT &ptNums)
{
	IMG_INT PtNums = ptNums;
	IMG_INT tempNums = 0;
	int i, j, k;
	vector<vector<EdgePointLine>>allEdges(lineNums);
	vector<EdgePointLine>resEdges, tempEdge;
	bool flag = true;
	IMG_REAL pt_distance_thred;
	if (m_searchType == SEARCH_TYPE::GAUGE)
	{
		pt_distance_thred = sqrt(m_fDelEdgeDis*m_fDelEdgeDis + m_fStep*m_fStep);
	}
	else
	{
		pt_distance_thred = m_fDelEdgeDis;
	}
	//m_iDelEdgeNums = m_LineInputPara
	for (i = 0; i < lineNums; i++)
	{
		double Denominator = pow(FinalFittingResult[i].Slope*FinalFittingResult[i].Slope + 1,0.5);
		for (j = 0; j < PtNums; j++)
		{
			double dis = abs(FinalFittingResult[i].Slope*EdgePts[j].xyDecimal.x - EdgePts[j].xyDecimal.y + FinalFittingResult[i].b) / Denominator;
			if (dis <= m_ScoreAcceptDistance)
			{
				allEdges[i].push_back(EdgePts[j]);
			}
		}
		tempNums = allEdges[i].size();
		//QuickSort_edge(allEdges[i], 0, tempNums - 1);
		sort(allEdges[i].begin(), allEdges[i].end(), compare_edge_val);
		tempEdge.clear();
		if(allEdges[i].size()<2)continue;
		for (k = 0; k < allEdges[i].size() - 1; k++)
		{
			//if (P2Pdis(allEdges[i][k].xyDecimal, allEdges[i][k + 1].xyDecimal) < pt_distance_thred)
			if (fabs(allEdges[i][k].xyDecimal.x - allEdges[i][k + 1].xyDecimal.x) < pt_distance_thred)
			{
				tempEdge.push_back(allEdges[i][k]);
				flag = true;
			}
			else
			{
				flag = false;
				tempEdge.push_back(allEdges[i][k]);
				if (tempEdge.size() <= m_iDelEdgeNums)
				{
					tempEdge.clear();
					flag = true;
					continue;
				}
				else
				{
					for (int l = 0; l < tempEdge.size(); l++)
					{
						resEdges.push_back(tempEdge[l]);
					}
					tempEdge.clear();
				}
			}
			if (flag&&k == allEdges[i].size() - 2)
			{
				if (tempEdge.size() <= m_iDelEdgeNums)
				{
					tempEdge.clear();
					flag = true;
					continue;
				}
				else
				{
					//if (P2Pdis(allEdges[i][k].xyDecimal, allEdges[i][k + 1].xyDecimal) < pt_distance_thred)
					if (fabs(allEdges[i][k].xyDecimal.x - allEdges[i][k + 1].xyDecimal.x) < pt_distance_thred)
					{
						tempEdge.push_back(allEdges[i][k + 1]);
					}
					for (int l = 0; l < tempEdge.size(); l++)
					{
						resEdges.push_back(tempEdge[l]);
					}
				}
			}
		}
	}

	//sort(resEdges.begin(), resEdges.end());
	//QuickSort_edge(resEdges, 0, (int)resEdges.size() - 1);
	sort(resEdges.begin(), resEdges.end(), compare_edge_val);
	resEdges.erase(unique(resEdges.begin(), resEdges.end()), resEdges.end());
	ptNums = resEdges.size();
	for (i = 0; i < ptNums; i++)
	{
		EdgePts[i] = resEdges[i];
	}
	for (i = 0; i < lineNums; i++)
	{
		allEdges[i].clear();
	}
	resEdges.clear();
	tempEdge.clear();
	return 0;
}


IMG_REAL CVisLine::P2Pdis(IMG_RCOORD coor1, IMG_RCOORD coor2)
{
	IMG_REAL dis;
	dis = pow(pow(coor1.x - coor2.x, 2) + pow(coor1.y - coor2.y, 2), 0.5);
	return dis;
}

IMG_REAL CVisLine::P2LineDis(LINE_INFO2D line, IMG_RCOORD coor)
{
	IMG_REAL dis;
	double Denominator = pow(line.Slope*line.Slope + 1, 0.5);
	dis = abs(line.Slope*coor.x - coor.y + line.b) / Denominator;
	return dis;
}
