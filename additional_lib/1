#pragma once

//#include <ViType.h>
//#include <ipp.h>
//#include<mkl.h>
//#include "Vis_assist.h"
#include<time.h>
#include <VisAlign.h>
//#include "VisClock.h"

//#include<cmath>
#ifdef  CVISALIGN_EXPORTS
#define CVISALIGN_DLL_EXPORTS __declspec(dllexport)
#else
#define CVISALIGN_DLL_EXPORTS __declspec(dllimport)   
#endif

using namespace std;

#define RUN_RIGHT (0)
#define	IMAGE_ERROR (2)
#define	LINEWIDTH_ERROR (4)
#define	ROT_ERROR (6)
#define	GAUSSKER_ERROR (8)
#define	GAUSSFUN_ERROR (10)
#define	NOEDGE (12)
#define	OUTFOUND (14)
#define	SELECT_ERROR (16)


//enum class EDGETYPE {
//	ANY,
//	LITGHT2DARK,
//	DARK2LIGHT,
//	WHITECENTER,
//	BLACKCENTER
//};

enum class EdgePriorSelect {
	FIRST,	//顶端
	BEST,	//边缘强度最大
	NEARCENTER, //中心线附近
	ALL,
};

enum class GRADLEVEL_EDGE {
	//DARKER,
	DARK,
	NORMAL,
	LIGHT,
	//LIGHTER,
	USERINPUT
};

enum class GradMethod {
	EDGE_QUADRATIC,
	EDGE_GAUSS,
	EDGE_SIGMOID,
	EDGE_RISING
};
enum class FindEdgeOption {
	OPTION_NONE,
	OPTION_MEDIAN_TANDIR
};
typedef struct _RECTROIEDGE
{
	IMG_RCOORD LeftVertex;
	IMG_RCOORD SrcCenterCo;//the center coordinate of ROI in source image
	IMG_RCOORD DstCenterCo;//the center coordinate of ROI 
	IMG_SIZE RectangleSize;
	IMG_REAL RotationAngle;
}RECTROIEDGE;

class CVISALIGN_DLL_EXPORTS CVisEdge : public CViObject
{
public:

	CVisEdge();
	~CVisEdge();

	void SetImage(IMG_UBBUF *img, IMG_UBBUF *mask = nullptr);
	void SetLine(IMG_RCOORD lineStart, IMG_RCOORD lineEnd);
	void SetLineWidth(IMG_REAL halfWidth);
	void GetLineWidth(IMG_REAL &halfWidth);
	void SetPixelOffset(IMG_REAL offset);
	void SetGradKernal(IMG_INT kernal);
	IMG_INT GetGradKernal(void){return m_iGradKernal;}
	void SetGaussFilterPara(IMG_REAL sigmaWidth, IMG_REAL sigmaHeight, IMG_UINT kerWidth, IMG_UINT kerHeight);
	void SetEdgeDir(EDGETYPE edgeDir);
	void SetPriorSelect(EdgePriorSelect edgeSelect);
	void SetMaxBlackWhiteCenterWidth(IMG_REAL width) { m_MaxBlackWhiteCenterWidth = width; }
	void SetMinBlackWhiteCenterWidth(IMG_REAL width) { m_MinBlackWhiteCenterWidth = width; }
	void SetGRADLEVEL_EDGE(GRADLEVEL_EDGE gradLevel, IMG_INT minGrad = 0);
	void SetGradMethod(GradMethod gradMethod);
	GradMethod GetGradMethod(void){return m_gradMethod;}
	IMG_UINT GetEdgeNum(void){return m_ptNums;}
	//if you malloc outside with size of GetEdgeNum(), it won't malloc inside,
	//if you pass nullpointer, it would use "new" to malloc memory and pass it out. 
	//you need to "delete" edge point after you have used it, or you will get memory leakage.
	void GetEdgePts(IMG_RCOORD *&edgePts, IMG_INT &ptNums);
	void GetEdge(IMG_RCOORD *&edgePts, IMG_REAL *&edgeMag, IMG_REAL *&edgeAngle, IMG_INT &ptNums);
	void GetEdge(EDGE_INFORMATION *&edge, IMG_INT &ptNums);
	void SetFindEdgeOption(FindEdgeOption Option) { m_iOption = Option; }
	FindEdgeOption SetFindEdgeOption(void) { return m_iOption; }
	IMG_VVOID SetDebug(const IMG_WORD debugflag, const IMG_CHAR *debugpath);
	void GetDebug(IMG_UWORD &uwDebug) { uwDebug = m_uwDebug; }
	void SetUseRoi(bool flag) { m_useROI = flag; }

	void Serialize(CMEMPack &mp);
	IMG_INT FindEdgePts();
private:
	IMG_INT ROI_HORIZONTAL_ROTATION(const IMG_UBBUF &pSrc, const IMG_RCOORD &PointStart, const IMG_RCOORD &PointEnd, const IMG_REAL &NormalVari, RECTROIEDGE &RoiStruct, IMG_UBBUF &pubDst);
	IMG_WORD DSP_RTS_R_8uC1(const IMG_UBBUF &prbSrc, const IMG_RCOORD &prcoSrcCenter, IMG_UBBUF &prbDst, const IMG_RCOORD &prcoDstCenter, const IMG_REAL &rAngle, const IMG_SIZE &pszOp);
	IMG_WORD DSP_RTS_R_8uC1_Spec(const IMG_UBBUF &prbSrc, const IMG_RCOORD &prcoSrcCenter, IMG_UBBUF &prbDst, const IMG_RCOORD &prcoDstCenter, const int &nAngle_spec, const IMG_SIZE &pszOp);
	IMG_INT ROI_ROTATION_COORDINATE_COMPUTE_IN_SOURCEIMAG_SL(const IMG_REAL &rAngle, const IMG_RCOORD &SrcCenterCo, const IMG_RCOORD &DstCenterCo, const IMG_RCOORD &RoiCo, IMG_RCOORD &RealCo);
	IMG_INT GaussianFilter_2D(const IMG_UBYTE *src, const IMG_INT &roiWidth, const IMG_INT &roiHeight, const IMG_INT &kerWidth, const IMG_INT &kerHeight, const IMG_REAL &sigma_width, const IMG_REAL &sigma_height, IMG_UBYTE *&dst);
	IMG_INT GaussianFilter_dim1_fixed(const IMG_UBYTE *src, const IMG_INT &srcWidth, const IMG_REAL &sigma, const IMG_UINT &kernelSize, IMG_UBYTE *dst);
	IMG_VVOID GetGaussianKernel_dim1(IMG_REAL *&gaus, const IMG_UINT &size, const IMG_REAL &sigma);
	IMG_INT Plot_Horizontal_Profile(const IMG_UBBUF &ubbSrc, IMG_RBUF &rbProfile);
	IMG_INT Plot_Horizontal_Profile_Median(const IMG_UBBUF &ubbSrc, IMG_RBUF &rbProfile);
	IMG_INT Plot_Gradient_Profile(const IMG_RBUF &ubbProfile_gray, IMG_RBUF &rbGraProfile, const IMG_INT &kerSize);
	IMG_INT FindGravityPeak(const IMG_RBUF &srcBuf, const int &minThre, IMG_RCOORD *&EdgePts, IMG_REAL *&Magnitude, IMG_INT &edgeNums, const IMG_INT &kerSize);
	IMG_INT  FindRisingEdge(const IMG_RBUF &srcBuf, const IMG_RBUF &srcGradBuf, const int &minThre, IMG_RCOORD *&EdgePts, IMG_REAL *&Magnitude, IMG_INT &edgeNums);
	IMG_INT FittingGraPoints(const IMG_RBUF &rbProfile_gra, IMG_RCOORD *&EdgePts, IMG_INT &edgeNums, const GradMethod &gradMethod, const IMG_RBUF &gradProj);
	int SigmoidFitting(const IMG_RBUF &srcImg, const IMG_INT &edgePt, const IMG_INT &kernal, double &dstEdge);
	double SigmoidFun(const double &w, const double &x, const double &b, const double &c, const double &d);
	double LossSum(const double &w, const double &b, const double &c, const double &d, IMG_LRCOORD *&coorEdge, const IMG_INT &edgeNums);
	IMG_VVOID SearchNearCentPoint(IMG_RCOORD *srcPts, IMG_INT ptNums, const IMG_RCOORD &startPt, const IMG_RCOORD &endPt, IMG_INT &index);
	IMG_REAL Edge_Dir(IMG_UBBUF mImage, IMG_RCOORD *pt);
	double fast_exp(double y);

	double exp1(double x);

	void logInit(char *filename);
	void writeLog(char * msg, ...);
	void logfinish();
	void SaveOptionToHTMLLog(struct _HTMLLOGGING *pstLog);
	void OutputEdgeTable(IMG_RCOORD *prcoEdge, IMG_REAL *Magnitude, IMG_REAL *Angle, IMG_INT num_edge, IMG_CHAR *title);
	void OutputEdgeTable(vector<IMG_RCOORD> &pstEdge, IMG_REAL *Magnitude, IMG_REAL *Angle, IMG_CHAR *title);
	void DrawResultImage(CVisImage &canvas);
	void DrawChat(IMG_RBUF *data, CVisImage &canvas, IMG_UINT ptnum = 0, IMG_RCOORD *pt = nullptr);
	
private:
	IMG_UBBUF m_Img;          // 图像输入
	IMG_UBBUF m_Mask;
	IMG_RCOORD m_lineStart; // 输入直线起点
	IMG_RCOORD m_lineEnd; // 输入直线终点
	IMG_REAL m_normalVari; // 直线半宽（默认0）
	IMG_INT m_iGradKernal;         // 梯度核，默认3即1*3
	IMG_REAL m_dGaussSigmaWidth, m_dGaussSigmaHeight;
	IMG_INT m_dGaussKerWidth, m_dGaussKerHeight;
	IMG_REAL m_MaxBlackWhiteCenterWidth, m_MinBlackWhiteCenterWidth;

	EDGETYPE m_edgeDir;   // 边缘方向
	EdgePriorSelect m_edgeSelect;  // 偏好筛选
	GRADLEVEL_EDGE m_gradLevel;  // 梯度等级
	GradMethod m_gradMethod;
	IMG_INT m_iMinGrad;
	FindEdgeOption m_iOption;

	IMG_RCOORD *m_EdgePts;
	IMG_REAL *m_Magnitude;
	IMG_REAL *m_Angle;
	IMG_INT m_ptNums;
	IMG_REAL m_fOffset;
	IMG_WINDOW m_ROI;
	IMG_UWORD m_uwDebug;
	IMG_CHAR m_strDebugPath[MAX_FILE_NAME];
	struct  _HTMLLOGGING *m_pHtmlLog;
	bool m_useROI;
};
