#pragma once
#include<math.h>
#include <ViType.h>
#include <string.h>
#include"VisEdge.h"
#include"VisClock.h"
#include"Base.h"
#include"VisEdgeFilter.h"
#ifdef  VISSMOOTHFITTING_EXPORTS
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __declspec(dllimport) 
#endif
#define MAX_EQUATION_COEFF 10
#define ISZERO(x)	(fabs(x) < 1e-5 ? true : false)

namespace curvefitting
{
	enum ControlType
	{
		NOORDER = -1,
		ZEROORDER = 0,
		ONEORDER = 1,
		TWOORDER = 2
	};

	struct VIS_EQUATION
	{
		double equCoeff[MAX_EQUATION_COEFF];  // a+bx+cx^2+dx^3...
		IMG_INT equPara;    // 参数可用个数，3维4个系数
		IMG_LRCOORD limits;    // 参数范围
		VIS_EQUATION()
		{
			memset(equCoeff, 0, sizeof(double)*MAX_EQUATION_COEFF);
			equPara = 0;
			limits.x = 0.0;
		}
		void init(IMG_INT para)
		{
			memset(equCoeff, 0, sizeof(double)*MAX_EQUATION_COEFF);
			equPara = para;
		}
	};

	struct EDGEPARA
	{
		IMG_REAL m_normalVari; // 直线半宽（默认0）
		IMG_INT m_iGradKernal;         // 梯度核，默认3即1*3
		IMG_REAL m_dGaussSigmaWidth, m_dGaussSigmaHeight;
		IMG_INT m_dGaussKerWidth, m_dGaussKerHeight;

		EDGETYPE m_edgeDir;   // 边缘方向
		EdgePriorSelect m_edgeSelect;  // 偏好筛选
		GRADLEVEL_EDGE m_gradLevel;  // 梯度等级
		GradMethod m_gradMethod;
		IMG_INT m_iMinGrad;
		IMG_REAL m_fOffset;
		EDGEPARA()
		{
			m_fOffset = 0.f;
			m_normalVari = 0.f;
			m_iGradKernal = 3;
			m_dGaussSigmaWidth = m_dGaussSigmaHeight = 0.f;
			m_dGaussKerWidth = m_dGaussKerHeight = 0;
			m_edgeDir = EDGETYPE::ANY;
			m_edgeSelect = EdgePriorSelect::NEARCENTER;
			m_gradLevel = GRADLEVEL_EDGE::NORMAL;
			m_gradMethod = GradMethod::EDGE_QUADRATIC;
			m_iMinGrad = 10;
		}
	};

	enum VIS_CURVE_TYPE
	{
		B_SPLINE,
		NURBS
	};

	struct VIS_POINT_PAIR
	{
		IMG_LRCOORD edgePt;
		IMG_LRCOORD curvePt;
		IMG_LREAL ptDis;
		IMG_LREAL coeffVal;
		IMG_INT searchNums;
	};

	struct PARA_POINT
	{
		IMG_LREAL para;
		IMG_LRCOORD pt;
	};

	struct VIS_PARA_EQUATION
	{
		VIS_EQUATION xEqu;
		VIS_EQUATION yEqu;
		IMG_LRCOORD limits;    // 参数范围
		IMG_LRCOORD startPt, endPt;
		VIS_PARA_EQUATION()
		{
			limits.x = 0.0; limits.y = 0.0;
			startPt = { 0.0,0.0 }; endPt = { 0.0, 0.0 };
		}
	};
}
using namespace curvefitting;

class DLLEXPORT CVisCurveFitting
{
public:
	CVisCurveFitting();
	CVisCurveFitting(const CVisCurveFitting&curve);
	CVisCurveFitting& operator=(const CVisCurveFitting&curve);
	virtual~CVisCurveFitting();
	IMG_VVOID SetClosed(bool isClosed);
	bool GetClosed();
	IMG_INT SetInputPara(IMG_RCOORD *coor, IMG_INT nums, IMG_INT dims, VIS_CURVE_TYPE curveType = VIS_CURVE_TYPE::B_SPLINE, IMG_REAL *weight = nullptr, IMG_INT weightNums = 0);
	IMG_INT SetDebugMode(bool debug, char* path);
	IMG_VVOID SetImage(IMG_UBBUF img);
	IMG_VVOID SetMask(IMG_UBBUF* mask);
	IMG_VVOID SetControlType(curvefitting::ControlType type);
	IMG_VVOID SetEdgePara(EDGEPARA edgePara);
	IMG_VVOID SetEdgeSearLength(IMG_REAL len);
	IMG_VVOID GetCurvePts(IMG_INT regionSample, PARA_POINT *&coor, IMG_INT &nums, PARA_POINT *&upCoor, PARA_POINT *&downCoor, IMG_RCOORD &midVec);
	//IMG_VVOID SetCurveType(VIS_CURVE_TYPE curveType, IMG_REAL *weight = nullptr, IMG_INT nums = 0); // 类型为NURBS时后面两个参数有效
	IMG_VVOID SetEdgeControlPts(IMG_RCOORD *coor, IMG_INT nums);
	IMG_VVOID SetSampleInRegion(IMG_INT sample);
	IMG_INT SetCurveNode(IMG_INT nums);
	IMG_VVOID SetFittingPara(IMG_REAL sigma, IMG_REAL sigmaCont, IMG_UINT times, IMG_REAL precision);

	IMG_INT CurveFitting();
	IMG_INT ClosedCurveFitting();

	IMG_VVOID GetCoeffEquNums(IMG_INT &nums);
	IMG_VVOID GetCoeffEqu(VIS_PARA_EQUATION *&numeratorEqu, VIS_PARA_EQUATION *&denominatorEqu, IMG_INT nums);
	IMG_VVOID GetCurveNodeNums(IMG_INT &nums);
	IMG_VVOID GetCurveNode(IMG_REAL *&node);
	IMG_VVOID GetCurveWeightNums(IMG_INT &nums);
	IMG_VVOID GetCurveWeight(IMG_REAL *&weight);

	IMG_VVOID GetCurveEdge(IMG_INT regionSample, PARA_POINT *&coor, IMG_INT &nums);
	IMG_VVOID GetCurveEdge(IMG_INT regionSample, IMG_LREAL norLength, PARA_POINT *&coor, IMG_INT &nums, PARA_POINT *&upCoor, PARA_POINT *&downCoor, IMG_LRCOORD &meanUp, IMG_LRCOORD &meanDown);
	IMG_VVOID GetClosedCurveEdge(IMG_INT regionSample, IMG_LREAL norLength, PARA_POINT *&coor, IMG_INT &nums,
		PARA_POINT *&upCoor, PARA_POINT *&downCoor, IMG_LRCOORD &meanPt);
	IMG_VVOID GetCurveCorssLine(IMG_INT Sample, IMG_RCOORD startPt, IMG_RCOORD endPt, PARA_POINT *&coor, IMG_INT &nums);
	//IMG_VVOID GetCurveCorssArc(IMG_RCOORD startPt, IMG_RCOORD endPt, PARA_POINT *&coor, IMG_INT &nums);
	IMG_VVOID GetCurveCorssCircle(IMG_INT Sample, IMG_CIRCLE circle, PARA_POINT *&coor, IMG_INT &nums);
	IMG_VVOID GetCurveLength(PARA_POINT pt1, PARA_POINT pt2, IMG_INT regionSample, IMG_REAL &length);

	IMG_VVOID GetClosedCurveEdge(IMG_INT regionSample, curvefitting::PARA_POINT *&coor, IMG_INT &nums, IMG_REAL &length);
	IMG_VVOID GetClosedCurveCorssLine(IMG_INT Sample, IMG_RCOORD startPt, IMG_RCOORD endPt, curvefitting::PARA_POINT *&coor, IMG_INT &nums);
	IMG_VVOID GetClosedCurveCorssCircle(IMG_INT Sample, IMG_CIRCLE circle, curvefitting::PARA_POINT *&coor, IMG_INT &nums);
	IMG_VVOID GetClosedCurveLength(curvefitting::PARA_POINT pt1, curvefitting::PARA_POINT pt2, IMG_INT regionSample, IMG_REAL &length);
	IMG_REAL GetClosedCurveLength(IMG_REAL ItePrecision);
	IMG_REAL m_rCurveLength;
	IMG_REAL m_rEdgeLength;
private:
	bool m_bIsClosed;
	IMG_UBBUF m_ubbufSrc;
	IMG_UBBUF* m_ubbufMask;
	bool m_bDebug;
	char debugPath[256];
	//CVisClock m_clock;
	curvefitting::ControlType m_ContType;     // 约束条件，默认0阶约束 
	IMG_RCOORD *m_coorInput;   // 输入的控制点（基函数个数）
	IMG_INT m_iPtNums;  
	IMG_REAL m_xRange;
	IMG_REAL m_yRange;
	IMG_REAL m_xMin;
	IMG_REAL m_yMin;
	IMG_REAL *m_rNode;       // 根据控制点生成的节点数 
	IMG_INT m_iNodeNums;
	IMG_INT m_iDims;         // 曲线维数，默认3

	//IMG_INT  m_regionNum;    // 曲线节点区间数目（=m_iNodeNums - 2*(dims+1）+1）0000 1111
	//VIS_EQUATION **m_NodeFun;      // 节点函数，个数为（（dims+1）*每一维的基函数个数*区间数）
	//IMG_INT m_iFunBase;
	VIS_PARA_EQUATION *m_paraEqu;  // 曲线方程结果，分段函数
	VIS_PARA_EQUATION *m_deriEqu;
	IMG_INT m_iParaEquNums;       // 曲线方程个数
	VIS_CURVE_TYPE m_curveType;  // 需要生成的曲线类型，B-Spline或者NURBS（B-Spline是NURBS的特色形式，当权因子都为1时退化为B-Spline）
	//IMG_REAL *m_pCoorWeight;     // 曲线为NURBS时的权因子，个数和控制点相等
	//IMG_INT m_WeightNums;
	//VIS_PARA_EQUATION *m_paraEqu_deno;  // NURBS曲线的分母
	VIS_EQUATION *m_NodeFun;
	IMG_SIZE m_szNodeFun;
	IMG_RCOORD *m_pcoorEdgeCont;
	IMG_INT m_iEdgeCont;

	EDGEPARA m_edgePara;   // 边缘参数
	IMG_REAL m_rSearLen;   // 搜索的边缘长度
	IMG_INT m_regSample;   // 搜索边缘点的采样个数，每个区间内采样个数

	VIS_POINT_PAIR *m_ptPair; // 搜索到的点对以及拟合的参数
	IMG_INT m_ptPairNums;
	IMG_REAL *rFittingNode;
	IMG_INT m_iFittingNodeNums;
	IMG_REAL *pWeight;
	IMG_INT m_iWeightNums;
	//VIS_EQUATION *FittingBaseEqu;
	//IMG_INT m_FitEquWidth;
	//IMG_INT m_FitEquHeight;
	VIS_EQUATION *m_pDisEqu;
	IMG_INT m_iDisEquNums;

	IMG_REAL m_sigma;
	IMG_REAL m_contSigma;
	IMG_REAL m_addSigma;
	IMG_UINT m_iterNums;
	IMG_REAL m_precision;
	curvefitting::VIS_EQUATION *m_ClosedBaseFun;
	IMG_INT m_ClosedBaseFunNums;
private:

	IMG_INT NodeVector(IMG_REAL*NodeVector, IMG_INT nodeNums, IMG_INT dims, bool bRepNode);
	
	IMG_INT SearchPointPair(IMG_UBBUF &srcImg, VIS_PARA_EQUATION *&upEqu,/* VIS_PARA_EQUATION *&downEqu,*/ IMG_INT equNums);
	IMG_INT SearchPointPair_closed(IMG_UBBUF &srcImg, VIS_PARA_EQUATION *&upEqu/*, VIS_PARA_EQUATION *&downEqu*/, IMG_INT equNums);

	IMG_REAL ComputeVecDis(IMG_RCOORD srcStart, IMG_RCOORD srcEndt, IMG_RCOORD dstStart, IMG_RCOORD dstEnd);  // 左手定则，计算矢量距离
	IMG_REAL BaseFunction(IMG_INT index, IMG_INT dims, IMG_REAL*NodeVector, IMG_INT nodeNums, IMG_REAL input);
	IMG_INT WeightFunction(VIS_POINT_PAIR *&pointPair, const IMG_INT ptPairNums, IMG_REAL **pBaseFunVal, IMG_INT baseFunNums,
		IMG_INT dataNums, IMG_REAL &Sigma, IMG_REAL &SigmaCont, IMG_REAL &addSigma, const IMG_UINT &IteMaxTimes, const IMG_REAL &ItePrecision);
	IMG_INT WeightFunction(curvefitting::VIS_POINT_PAIR *&pointPair, const IMG_INT ptPairNums,
		IMG_REAL &Sigma, IMG_REAL &SigmaCont, IMG_REAL &addSigma, const IMG_UINT &IteMaxTimes, const IMG_REAL &ItePrecision);
	bool LineCrossLine(IMG_RCOORD line1Start, IMG_RCOORD line1End, IMG_RCOORD line2Start, IMG_RCOORD line2End, IMG_RCOORD &dst);
	bool PointInLine(IMG_RCOORD lineStart, IMG_RCOORD lineEnd, IMG_RCOORD pt);
	IMG_INT AddEdgeControlPts(const IMG_RCOORD *coor, const IMG_INT &nums);
	double Pt2PtDis(const IMG_LRCOORD &pt1, const IMG_LRCOORD &pt2);
	void clear();
	IMG_INT PointPairFilter(VIS_POINT_PAIR *pointPair, IMG_INT &ptPairNums);
	VIS_POINT_PAIR GetBaseCurveNearest(VIS_POINT_PAIR *pointPair, IMG_INT ptPairNums);
	bool ptOnLine(VIS_POINT_PAIR linePt1, VIS_POINT_PAIR linePt2, VIS_POINT_PAIR *pointPair, IMG_INT &ptPairNums, VIS_POINT_PAIR &dstPt);
};
