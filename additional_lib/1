// CVisAlignSearch.cpp : Defines the exported functions for the DLL application.
//


#include <fstream>
#include <iostream>
#include "VisAlignSearch.h"
#include "VisAlignGeneral.h"
#include "VisAlignHtmlLog.h"
#include "VisMath.h"
#include <sec.h>
#include <assert.h>
#include <stdarg.h>
#include <direct.h>
#include <io.h>
#include"VisNURBSCurve.h"
#include <algorithm>

using namespace std;
using namespace VisAlign;
extern std::timed_mutex g_logIndexLock;
IMG_ULWORD g_MasterSearchLogIndex = 0;
thread_local IMG_ULWORD g_SearchLogIndex = 0;
thread_local FILE *fp_log;
thread_local CVisClock *g_pstClock = nullptr;
IMG_WORD ALIGN_MallocForCoarseSearchVoting(IMG_SIZE *pszOpsize, ALIGN_SEARCH_OPTION *pstSrchOpt, CVisMemPool &mem_pool);
IMG_CHAR *VisAlign::VIS_ALIGN_Version(void);
IMG_WORD coarse_search_kernel(	IMG_UBBUF				*pubbEpbuf,
								//
								IMG_COORD			*pcoSoff,
								IMG_WBUF			*pwbDir,
								IMG_COORD			*pcoDiroff,
								IMG_SIZE			*pszOpsize,
								CVisAlignRecordTable		*pstEptable,
								ALIGN_SRCH_RESULT	*psrOptable,
								ALIGN_SEARCH_OPTION	*pstSrchOpt,
								ALIGN_INPUT_TYPE	InputType,			// 1 = buffer; 2 = BGA
								ALIGN_VOTING_INFORMATION	*pstVotingInfo,
								IMG_REAL			rScale,				 // search for the obj having this scale
								IMG_UWORD			uwScaleLoopIndex,
								IMG_UWORD			*puwNextObjID,
								HTMLLOGGING				*pstLog);

IMG_VVOID Align_OutputTableInHTML(HTMLLOGGING *m_pHtmlLog, ALIGN_SRCH_RESULT *result, IMG_CHAR *title)
{
	CVisMemPool pool;
	HTMLLOGGING_TABLE_DATA stTable;
	HL_Printf(m_pHtmlLog, "Obj Num: %d\n", result->size);
	HL_InitTableData(&stTable);
	stTable.title = title;
	stTable.tablelinewidth = 0;
	stTable.column = 7;
	stTable.fontweight = FW_Medium;
	stTable.tablealign = TX_CENTER;
	stTable.tablewidth = 50;
	stTable.tablelinewidth = 1;
	stTable.bgColorOddLine = 0x9fff9f;
	stTable.formatstring = "%.6f";
	stTable.datatype = DT_REAL;
	stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
	stTable.heading[0] = "ID";
	stTable.heading[1] = "PosX";
	stTable.heading[2] = "PosY";
	stTable.heading[3] = "Scale";
	stTable.heading[4] = "Rotation";
	stTable.heading[5] = "Fitting Score";
	stTable.heading[6] = "Matching Score";
	HL_CreateTableHeader(m_pHtmlLog, &stTable);
	for (int i = 0; i < result->size; i++)
	{
		char value[7][20];
		if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
		else		stTable.bgColorOddLine = 0xffffcf;
		_snprintf(value[0], sizeof(value[0]), "%d", result->ptr[i].uwID);
		_snprintf(value[1], sizeof(value[1]), "%.3f", result->ptr[i].rco.x);
		_snprintf(value[2], sizeof(value[2]), "%.3f", result->ptr[i].rco.y);
		_snprintf(value[3], sizeof(value[3]), "%.6f", result->ptr[i].scale);
		_snprintf(value[4], sizeof(value[4]), "%.6f", result->ptr[i].rotation);
		_snprintf(value[5], sizeof(value[5]), "%.3f", result->ptr[i].rLikeScore);
		_snprintf(value[6], sizeof(value[6]), "%.3f", result->ptr[i].rMatched);
		HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
	}
	HL_CloseTable(m_pHtmlLog);
	HL_Printf(m_pHtmlLog, "\n");
}
CVisAlignSearch::CVisAlignSearch()
{
	m_AlignResult.Reset();
	m_pHtmlLog = nullptr;
}

CVisAlignSearch::~CVisAlignSearch()
{
}

/**
* @brief <B>Description:</B><br> calculate the distance between searched point 
* and normal line
* @param x x-coordinate of searched point
* @param y y-coordinate of searched point
* @param line normal line struct
*/
IMG_LREAL CVisAlignSearch::FeatEdgeNormalDistance(IMG_LRCOORD *edge, IMG_LRCOORD *feature, IMG_REAL feature_dir)
{
	IMG_LREAL distance;
	LINEAR_GENERNAL_EQUATION line;
	IMG_LREAL	cose, sine;
	cose = cos(D2R*(feature_dir + 90));
	sine = sin(D2R*(feature_dir + 90));

	line.a = sine;
	line.b = -cose;
	line.c = -feature->x*sine + feature->y*cose;

	IMG_LREAL numerator = (IMG_REAL)fabsf(line.a * edge->x + line.b * edge->y + line.c);
	IMG_LREAL denominator = (IMG_REAL)sqrt((double)(line.a * line.a) + (double)(line.b * line.b));
	distance = numerator / denominator;
	return distance;
}

IMG_LREAL CVisAlignSearch::FeatEdgeTangentDistance(IMG_LRCOORD *edge, IMG_LRCOORD *feature, IMG_REAL feature_dir)
{
	IMG_LREAL distance;
	LINEAR_GENERNAL_EQUATION line;
	IMG_LREAL	cose, sine;
	cose = cos(D2R*(feature_dir));
	sine = sin(D2R*(feature_dir));

	line.a = sine;
	line.b = -cose;
	line.c = -feature->x*sine + feature->y*cose;

	IMG_LREAL numerator = (IMG_REAL)fabsf(line.a * edge->x + line.b * edge->y + line.c);
	IMG_LREAL denominator = (IMG_REAL)sqrt((double)(line.a * line.a) + (double)(line.b * line.b));
	distance = numerator / denominator;
	return distance;
}


/**
* @brief <B>Description:</B><br> Read learnOption
*/
//IMG_VVOID CVisAlignSearch::SetLearnOption(ALIGN_LEARN_OPTION &stOption)
//{
//	m_LearnOption.LearnInput(stOption);
//#ifdef DEBUG
//	m_LearnOption.learnInput.wPreprocKernelSize = 3;		//高斯核
//	m_LearnOption.learnInput.ulPreprocParam = 3;		//高斯sigma
//
//	m_LearnOption.learnInput.ulReduction = 2;		//0,1,2三层
//	m_LearnOption.learnInput.ulHighestLayer = 0;	//从第0层开始
//
//	m_LearnOption.learnInput.ulEdgeThreshold = 100;	//edge threshold
//#endif // DEBUG
//}

/**
* @brief <B>Description:</B><br> GetGaussianKernel(1 dimension)
* @param gaus Gaussian kernal
* @param[in] size Kernal size
* @param[in] sigma Filter sigma
*/
IMG_VVOID CVisAlignSearch::__GetGaussianKernel_dim1(IMG_WORD *&gaus, const IMG_INT size, const double sigma)
{
	const double PII = 4.0*atan(1.0); //圆周率π赋值  
	IMG_INT center = size / 2;
	IMG_LREAL sum = 0;
	for (IMG_INT i = 0; i < size; i++)
	{
		gaus[i] = (1 / (sqrt(2 * PII)*sigma))*exp(-((i - center)*(i - center)) / (2 * sigma*sigma)) * 10;		//less than 1
		sum += gaus[i];
	}
	//for (IMG_INT i = 0; i<size; i++)
	//{
	//	gaus[i] /= sum;
	//}
}

/**
* @brief <B>Description:</B><br> GetGaussianKernel(2 dimension)
* @param gaus Gaussian kernal
* @param[in] size Kernal size
* @param[in] sigma Filter sigma
*/
IMG_VVOID CVisAlignSearch::__GetGaussianKernel_dim2(IMG_LREAL **gaus, const IMG_INT size, const double sigma)
{
	const double PIII = 4.0*atan(1.0); //圆周率π赋值  
	IMG_INT center = size / 2;
	IMG_LREAL sum = 0;
	for (IMG_INT i = 0; i < size; i++)
	{
		for (IMG_INT j = 0; j < size; j++)
		{
			gaus[i][j] = (1 / (2 * PIII*sigma*sigma))*exp(-((i - center)*(i - center) + (j - center)*(j - center)) / (2 * sigma*sigma));
			sum += gaus[i][j];
		}
	}
	for (IMG_INT i = 0; i < size; i++)
	{
		for (IMG_INT j = 0; j < size; j++)
		{
			gaus[i][j] /= sum;
		}
	}
	return;
}

/**
* @brief <B>Description:</B><br> Do gaussian filter
* @param pSrc pointer to source image
* @param roiSize roiSize
* @param pDst pointer to destination image
* @param size preprocess kernal size
* @param sigma preprocess kernal sigma
*/
IMG_INT CVisAlignSearch::preprocess(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;
	//init var
	IMG_UBBUF ubbufSrc = stAlignExData.ubBufSrc;
	IMG_UBBUF ubbufGaussian = stAlignExData.ubBufGaussian;
	IMG_UBYTE *pSrc = ubbufSrc.ptr;
	IppiSize roiSize = { ubbufGaussian.size.width,ubbufGaussian.size.height };
	IMG_UBYTE *pDst = ubbufGaussian.ptr;
	VIS_ALIGN_RECORD *pstRec = m_AlignRecord->GetRecord();
	IMG_INT kernel_size = pstRec->wPreprocessKSize;// m_LearnOption.LearnInput().wPreprocKernelSize;
	IMG_REAL sigma = pstRec->rPreprocessGaussianSigma;// m_LearnOption.LearnInput().ulPreprocParam;
	CVisImage image;
	if (pSrc == NULL)
	{
		status = ippStsNoMemErr;
		goto exit;
	}
	IMG_WORD wProc, wKernel;
	IMG_REAL rParam;
	wProc = pstRec->wPreprocessType;
	wKernel = pstRec->wPreprocessKSize;
	rParam = pstRec->rPreprocessGaussianSigma;
	if (wProc == 0)return status;
	image.SetImage(ubbufSrc);
	switch (wProc)
	{
	case ALIGN_LRN_PREPROCESS_DILATE:
		image.Dilation(wKernel);
		break;
	case ALIGN_LRN_PREPROCESS_ERODE:
		image.Erosion(wKernel);
		break;
	case ALIGN_LRN_PREPROCESS_OPEN:
		image.Opening(wKernel, wKernel);
		break;
	case ALIGN_LRN_PREPROCESS_CLOSE:
		image.Closing(wKernel, wKernel);
		break;
	case ALIGN_LRN_PREPROCESS_GAUSSIAN:
		image.FilterGaussian(wKernel, rParam);
		break;
	default:
		THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
		break;
	}
	IMG_UBBUF buf = (IMG_UBBUF)(image);
	for (size_t i = 0; i < buf.size.height; i++)
	{
		memcpy(ubbufGaussian.ptr + i*ubbufGaussian.linestep, buf.ptr + buf.linestep*i, buf.size.width);
	}

//	//begin
//	if (kernel_size > 0 && sigma > 0)
//	{
//		IMG_INT srcStep = sizeof(IMG_UBYTE) * ubbufSrc.linestep;
//		IMG_INT dstStep = ubbufGaussian.linestep;
//
//		IMG_LREAL **gaus = (IMG_LREAL **)pool.Malloc(sizeof(IMG_LREAL *) * kernel_size);//new IMG_LREAL *[kernel_size];
//		if (gaus == NULL)
//		{
//			status = ippStsNoMemErr;
//			goto exit;
//		}
//		for (IMG_INT i = 0; i < kernel_size; i++)
//		{
//			gaus[i] = (IMG_LREAL *)pool.Malloc(sizeof(IMG_LREAL) * kernel_size);
//		}
//		__GetGaussianKernel_dim2(gaus, kernel_size, sigma);
//		IppiSize  kernelSize = { kernel_size,kernel_size };
//		IppiSize gaussize = { kernel_size,kernel_size };
//		//IMG_WORD kernel[9];
//		IMG_WORD *kernel = (IMG_WORD*)pool.Malloc(sizeof(IMG_WORD)* kernel_size* kernel_size);
//		for (IMG_INT i = 0; i < kernel_size; i++)
//		{
//			for (IMG_INT j = 0; j < kernel_size; j++)
//			{
//				kernel[i*kernel_size + j] = gaus[i][j] * 32767;		//-32767 ~ 32767
//			}
//		}
//		/*for (IMG_INT i = 0; i<kernel_size; i++)
//		{
//			for (IMG_INT j = 0; j<kernel_size; j++)
//			{
//				printf("%d,", kernel[i*kernel_size + j]);
//			}
//		}*/
//		IMG_INT divisor = 32767;//归一化
//		IMG_UBYTE *pBuffer = NULL;                /* Pointer to the work buffer */
//		IppiFilterBorderSpec* pSpec = NULL;   /* context structure */
//		IMG_INT iTmpBufSize = 0, iSpecSize = 0;   /* Common work buffer kernel_size */
//		IppiBorderType borderType = ippBorderConst;
//		IMG_UBYTE borderValue = 0;
//		IMG_INT numChannels = 1;
//
//		status = ippiFilterBorderGetSize(kernelSize, roiSize, ipp8u, ipp16s, numChannels, &iSpecSize, &iTmpBufSize);
//		if (status < 0)	goto exit_proc;
//
//		pSpec = (IppiFilterBorderSpec *)pool.Malloc(iSpecSize);
//		pBuffer = (IMG_UBYTE *)pool.Malloc(iTmpBufSize);
//		if (!pSpec || !pBuffer)
//		{
//			status = ippStsNoMemErr;
//			goto exit_proc;
//		}
//
//		status = ippiFilterBorderInit_16s(kernel, kernelSize, divisor, ipp8u, numChannels, ippRndNear, pSpec);
//		if (status < 0)	goto exit_proc;
//
//		status = ippiFilterBorder_8u_C1R(pSrc, srcStep, pDst, dstStep, roiSize, borderType, &borderValue, pSpec, pBuffer);
//		if (status < 0)	goto exit_proc;
//
//		//set var
//
//	exit_proc:
//		//pool.PFree(pBuffer);
//		//pool.PFree(pSpec);
//		//pool.PFree(kernel);
//		//pool.PFree(gaus);
//		goto exit;
//	}
//	//else
//	//{
//	//	IMG_UINT i;
//	//	for (i = 0; i < roiSize.height; i++)
//	//	{
//	//		memcpy(pDst + i*ubbufGaussian.linestep, pSrc + i*ubbufSrc.linestep, roiSize.width);
//	//	}
//	//}
exit:
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "gaussianFilterStatus: %s\n", ippGetStatusString(status));
	}
	if(status != OK)
	{
		THROW_VIS_EXCEPTION(status);
	}	
	return status;
}

/**
* @brief <B>Description:</B><br> Do pyramid
* @param pSrc pointer to source image
* @param roiSize roiSize
* @param pPyrStruct save pyramid struct
* @param pPyrImage save pyramid image
* @param level pyramid total levels
*/
IMG_INT CVisAlignSearch::pyramid(CVisAlignSearchInterData &stAlignExData)
{
	IppStatus   status = ippStsNoErr;
	/*
	CVisMemPool pool;
	//init var
	IMG_UBYTE* pSrc = stAlignExData.PyrSrc();
	IppiSize roiSize = stAlignExData.PyrRoiSize();
	IppiPyramid*  pPyrStruct = stAlignExData.PyrStruct();
	IMG_UBYTE **  pPyrImage = stAlignExData.PyrImage();
	VIS_ALIGN_RECORD *pstRec = m_AlignRecord->GetRecord();
	IMG_INT level = pstRec->ulHighestLayer+pstRec->ulNumOfLayer;// m_LearnOption.LearnInput().ulReduction;//m_SearchOption.Pyramid_level();
	
	//IMG_LREAL sigma = 3;
	IMG_INT srcStep = roiSize.width * sizeof(IMG_UBYTE);
	IMG_REAL      rate = 2.f;                  // Neighbour levels ratio
	const IMG_UINT kernel_size = 7;
	IMG_WORD kernel[kernel_size] = { 6,12,17,20,17,12,6 };		// Separable symmetric kernel of odd length



	//IMG_WORD *kernel = (IMG_WORD *)pool.PMalloc(3 * sizeof(IMG_WORD));
	//__GetGaussianKernel_dim1(kernel, 3, sigma);	// preserved

	IMG_INT i = 0;

	IMG_INT pyrBufferSize = 0;
	IMG_INT pyrStructSize = 0;
	IMG_UBYTE       *pPyrBuffer = NULL;
	IMG_UBYTE       *pPyrStrBuffer = NULL;

	IMG_INT      pyrLStateSize = 0;
	IMG_INT      pyrLBufferSize = 0;
	IMG_UBYTE   *pPyrLStateBuf = NULL;
	IMG_UBYTE   *pPyrLBuffer = NULL;

	if (!pSrc) { status = ippStsNoMemErr; goto exit; }
	// Computes the temporary work buffer size
	status = ippiPyramidGetSize(&pyrStructSize, &pyrBufferSize, level, roiSize, rate);
	if (status < 0) goto exit;

	pPyrBuffer = (IMG_UBYTE*)pool.Malloc(pyrBufferSize * sizeof(IMG_UBYTE));
	pPyrStrBuffer = (IMG_UBYTE*)pool.PMalloc(pyrStructSize * sizeof(IMG_UBYTE));	//not pop
	VALIDATE_MALLOC(pPyrStrBuffer);
	if ((pyrBufferSize && !pPyrBuffer) || (pyrStructSize && !pPyrStrBuffer)) {
		status = ippStsNoMemErr; goto exit_proc;
	}

	// Initializes Gaussian structure for pyramids
	//pPyrStruct = (IppiPyramid*)pool.PMalloc(level * sizeof(IppiPyramid));	
	status = ippiPyramidInit(&pPyrStruct, level, roiSize, rate, pPyrStrBuffer, pPyrBuffer);
	if (status < 0) goto exit_proc;

	// ????????????????Correct maximum scale level 
	level = pPyrStruct->level;

	// Allocate structures to calculate pyramid layers
	status = ippiPyramidLayerDownGetSize_8u_C1R(roiSize, rate, kernel_size, &pyrLStateSize, &pyrLBufferSize);
	if (status < 0) goto exit_proc;

	pPyrLStateBuf = (IMG_UBYTE*)pool.Malloc(pyrLStateSize * sizeof(IMG_UBYTE));
	pPyrLBuffer = (IMG_UBYTE*)pool.Malloc(pyrLBufferSize * sizeof(IMG_UBYTE));
	if ((pyrLStateSize && !pPyrLStateBuf) || (pyrLBufferSize && !pPyrLBuffer)) { status = ippStsNoMemErr; goto exit; }

	// Initialize the structure for creating a lower pyramid layer
	status = ippiPyramidLayerDownInit_8u_C1R((IppiPyramidDownState_8u_C1R**)&pPyrStruct->pState, roiSize, rate, kernel, kernel_size, IPPI_INTER_LINEAR, pPyrLStateBuf, pPyrLBuffer);
	if (status < 0) goto exit_proc;

	// Allocate pyramid layers
	pPyrImage = pPyrStruct->pImage;
	pPyrImage[0] = pSrc;
	pPyrStruct->pStep[0] = srcStep;

	for (i = 1; i <= level; i++)
	{
	//	pPyrImage[i] = (IMG_UBYTE*)pool.PMalloc((ubbufReduction[i].size.width) * (ubbufReduction[i].size.height) * sizeof(IMG_UBYTE));
		VALIDATE_MALLOC(pPyrImage[i]);
		//pPyrStruct->pStep[i] = (ubbufReduction[i].size.width) * sizeof(IMG_UBYTE);
		if (!pPyrImage[i]) { status = ippStsNoMemErr; goto exit_proc; }
	}

	// Perform downsampling of the image with 5x5 Gaussian kernel
	for (i = 1; i <= level; i++)
	{
		//status = ippiPyramidLayerDown_8u_C1R(pPyrImage[i - 1], pPyrStruct->pStep[i - 1], pPyrStruct->pRoi[i - 1], pPyrImage[i], pPyrStruct->pStep[i], ubbufReduction[i].size, (IppiPyramidDownState_8u_C1R*)pPyrStruct->pState);
		if (status < 0) goto exit_proc;

	}

exit_proc:
	//pool.PFree(pPyrBuffer);
	//pool.PFree(pPyrStrBuffer);
	//pool.PFree(pPyrLStateBuf);
	//pool.PFree(pPyrLBuffer);
	goto exit;

exit:
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "pyramidStatus: %s\n", ippGetStatusString(status));
	}
	if (status == OK)
	{
		//set var
		stAlignExData.PyrStruct(pPyrStruct);
		stAlignExData.PyrImage(pPyrImage);
	}
	else
	{
		THROW_VIS_EXCEPTION(status);
	}
	*/
	return status;
}

/**
* @brief <B>Description:</B><br> sobel filter(8u16s)
* @param pSrc pointer to source image
* @param roiSize roiSize
* @param KernalSize kernal size(should be 3 or 5)
* @param pDst pointer to destination image
* @param pAngle save gradient angle
* @param srcImgStep step of src image
*/
//IMG_VVOID CVisAlignSearch::__SobelFilter_8u16s_C1_3x3or5x5(CVisMemPool &pool, IMG_UBYTE * pSrc, IppiSize roiSize, IMG_INT KernalSize,IMG_WORD *&pDst, IMG_REAL *&pAngle, IMG_INT srcImgStep)
//{
//	;
//	IppiMaskSize mask;// = ippMskSize3x3;
//	if (KernalSize == 3)
//	{
//		mask = ippMskSize3x3;
//	}
//	else
//	{
//		if (KernalSize == 5)
//		{
//			mask = ippMskSize5x5;
//		}
//		else
//		{
//			THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
//		}
//	}
//	IppiBorderType bordertype = ippBorderRepl; //Border is replicated from the edge pixels
//	IMG_WORD *pHoriz, *pVert;
//	IMG_INT srcStep = srcImgStep * sizeof(IMG_UBYTE);
//	IMG_INT dstStep = roiSize.width * sizeof(IMG_WORD);
//	IMG_INT angleStep = roiSize.width * sizeof(IMG_REAL);
//	IMG_INT bufferSize;
//	IMG_INT bufLen = roiSize.width * roiSize.height;
//	IppStatus statusVert, statusHoriz, status;
//	IMG_UBYTE *pBuffer;
//	IppNormType normType = ippNormL2;//input gradient magnitude
//	IMG_UBBUF bufSrc;
//	IMG_WBUF wbufMagH, wbufMagV, wbufMag;
//	IMG_RBUF rbufAngle;
//	IppStatus sts;
//
//	pVert = (IMG_WORD *)pool.Malloc(sizeof(IMG_WORD)*bufLen);
//	pHoriz = (IMG_WORD *)pool.Malloc(sizeof(IMG_WORD)*bufLen);
//	//pAngle = (IMG_REAL *)pool.PMalloc(sizeof(IMG_REAL)*bufLen);		//not pop
//	//pDst = (IMG_WORD *)pool.PMalloc(sizeof(IMG_WORD)*bufLen);		//not pop
//
//	sts = ippiGradientVectorGetBufferSize(roiSize, mask, ipp16s, 1, &bufferSize);
//	pBuffer = (IMG_UBYTE *)pool.Malloc(bufferSize);
//	sts = ippiGradientVectorSobel_8u16s_C1R(pSrc, srcStep, pVert, dstStep, pHoriz, dstStep, pDst, dstStep, pAngle, angleStep, roiSize, mask, normType, bordertype, NULL, pBuffer);
//	
//	bufSrc.ptr = pSrc;
//	bufSrc.size = { roiSize.width, roiSize.height };
//	bufSrc.linestep = srcStep;
//	wbufMagV.ptr = pVert;
//	wbufMagV.size = { roiSize.width,roiSize.height };
//	wbufMagV.linestep = srcStep;
//	wbufMagH.ptr = pHoriz;
//	wbufMagH.size = { roiSize.width, roiSize.height };
//	wbufMagH.linestep = srcStep;
//	wbufMag.ptr = pDst;
//	wbufMag.size = { roiSize.width, roiSize.height };
//	wbufMag.linestep = srcStep;
//	rbufAngle.ptr = pAngle;
//	rbufAngle.size = { roiSize.width, roiSize.height };
//	rbufAngle.linestep = srcStep;
//	//pool.PFree(pVert);
//	//pool.PFree(pHoriz);
//	//pool.PFree(pBuffer);
//}

/**
* @brief <B>Description:</B><br> edge detection(using parabola fitting)
* @param srcRoi pointer to source image
* @param roiRows roiSize.height
* @param roiCols roiSize.width
* @param threshold set threshold
* @param dstRoi gradient magnitude
* @param dstRoiE gradient magnitude(binary)
* @param angAll gradient angle
* @param edgeArray save subpixel edge information
* @param k edge count
*/
IMG_INT CVisAlignSearch::edgeExtract_dstRoi(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus   status = ippStsNoErr;
	////init var
	IMG_UBBUF *srcRoi = stAlignExData.EdSrcBuffer();
	IMG_INT roiRows = srcRoi->size.height;
	IMG_INT roiCols = srcRoi->size.width;
	ALIGN_SEARCH_OPTION *pstSrchOpt = m_SearchOption.GetSearchPara();
	IMG_INT threshold = pstSrchOpt->uwEdgeThd;// m_LearnOption.LearnInput().ulEdgeThreshold;
	IMG_WBUF dstRoi = stAlignExData.EdDst();
	IMG_UBBUF dstRoiE = stAlignExData.EdDstRoiE();
	IMG_RBUF angAll = stAlignExData.EdAngle();
	EDGE_INFORMATION *edgeArray = stAlignExData.pEdgeArray();
	IMG_UINT k = stAlignExData.EdgeNum();//记录边缘点的个数
	CVisAlignRecordTable *pstTable = nullptr;
	VIS_ALIGN_RECORD *pstRecord = m_AlignRecord->GetRecord();
	IMG_LWORD lwVoteLevel = m_SearchOption.GetSearchPara()->ubRedFactor;
	IppiSize dstRoiSize = { roiCols,roiRows };

	//dstRoi = (IMG_WORD *)pool.PMalloc(dstRoiSize.width*dstRoiSize.height * sizeof(IMG_WORD));
	//VALIDATE_MALLOC(dstRoi);

	//angAll = (IMG_REAL *)pool.PMalloc(dstRoiSize.width*dstRoiSize.height * sizeof(IMG_REAL));
	//VALIDATE_MALLOC(angAll);


	if (lwVoteLevel < 0 || lwVoteLevel >= pstRecord->ulNumOfLayer) lwVoteLevel = pstRecord->ulNumOfLayer - 1;
	pstTable = pstRecord->ptr + lwVoteLevel;



	Align_EdgeDetection(srcRoi, stAlignExData.pubbufEdMask, threshold, pstTable->ubKernel, &dstRoiE, &dstRoi, &angAll, edgeArray, k);
	stAlignExData.EdDst(dstRoi);
	stAlignExData.EdAngle(angAll);
	stAlignExData.pEdgeArray(edgeArray);
	stAlignExData.EdgeNum(k);
exit:
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "edgeDetectStatus: %s\n", ippGetStatusString(status));
	}
	return status;

}

static IMG_VVOID CreateVotingInputBuffer(CVisAlignSearchInterData &stAlignExData, CVisMemPool &pool, IMG_UBBUF &ubbEpbuf, IMG_WBUF &wbDir)
{
	IMG_WORD		status = OK;
	IMG_INT 		i, index;
	IMG_UBYTE 		*pubEdge;
	IMG_WORD		*pwDir;
	IMG_SIZE 		szOp = stAlignExData.EdSrcBuffer()->size;
	EDGE_INFORMATION *edgeinfo = stAlignExData.pEdgeArray();
	ubbEpbuf.size = szOp;
	ubbEpbuf.linestep = szOp.width;
	ubbEpbuf.ptr = (IMG_UBYTE *)pool.Malloc((size_t)szOp.width*szOp.height);
	if(ubbEpbuf.ptr == nullptr) 
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
	}
	memset(ubbEpbuf.ptr, 0, (size_t)szOp.width*szOp.height);
	wbDir.size = szOp;
	wbDir.linestep = szOp.width;
	wbDir.ptr = (IMG_WORD *)pool.Malloc(sizeof(IMG_WORD)*(size_t)szOp.width*szOp.height);
	if(wbDir.ptr == nullptr)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
	}
	memset(wbDir.ptr, 0, sizeof(IMG_WORD)*(size_t)szOp.width*szOp.height);
	for(i = 0; i<stAlignExData.EdgeNum(); i++)
	{
		assert(edgeinfo[i].coPos.x > 0 && edgeinfo[i].coPos.x < szOp.width && 
				edgeinfo[i].coPos.y >= 0 && edgeinfo[i].coPos.y < szOp.height);
		BUF_OFF(pubEdge, &ubbEpbuf, &edgeinfo[i].coPos);
		*pubEdge = 255;
		BUF_OFF(pwDir, &wbDir, &edgeinfo[i].coPos);
		assert(edgeinfo[i].angle > -0.5 && edgeinfo[i].angle < 360.5);
		*pwDir = (IMG_WORD)(edgeinfo[i].angle+0.5);
	}
	return ;
}
IMG_VVOID CVisAlignSearch::coarse_search(CVisAlignSearchInterData &stAlignExData)
{

	IMG_WORD				state;
	IMG_UBBUF 				ubbEdgeMap, ubbSrc;
	IMG_WBUF 				wbDir;
	IMG_COORD 				coZero = {0};
	IMG_SIZE 				szOp = stAlignExData.EdSrcBuffer()->size;
	CVisAlignRecordTable 		*pstEptable = nullptr;
	ALIGN_SRCH_RESULT 		*psrOptable = nullptr;
	ALIGN_SEARCH_OPTION		*pstSrchOpt = m_SearchOption.GetSearchPara();
	ALIGN_INPUT_TYPE		InputType = ALIGN_BUFFER;
	IMG_REAL				rScale = 1;
	IMG_UWORD				uwScaleLoopIndex = 0;
	IMG_UWORD				uwNextObjID = pstSrchOpt->uwIDStart;
	CVisMemPool				pool;
	VIS_ALIGN_RECORD		*pstRecord = nullptr;
	IMG_LWORD				lwVoteLevel = pstSrchOpt->ubRedFactor;
	IMG_REAL				rMinAngle, rMaxAngle;

	//pstSrchOpt->uwDebug = 5;
	// generate buf for coarse search
	CreateVotingInputBuffer(stAlignExData, pool, ubbEdgeMap, wbDir);

	// generate intermeidate buffer for coarse search
	state = ALIGN_MallocForCoarseSearchVoting(&szOp, pstSrchOpt, pool);
	if(state != OK) THROW_VIS_EXCEPTION(state);

	//perform coarse search
	pstRecord = m_AlignRecord->GetRecord();
	psrOptable = m_AlignResult.Result();

	if(lwVoteLevel < 0 || lwVoteLevel >= pstRecord->ulNumOfLayer) lwVoteLevel = pstRecord->ulNumOfLayer-1;
	pstEptable = pstRecord->ptr+lwVoteLevel;

	if (stAlignExData.EdgeNum() < pstSrchOpt->rCoarseAcceptLevel*pstEptable->uwNumOfVoteFeature)
	{
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("number of image edge point is less than valid object");
		}
		goto end;
	}


	if (pstEptable->ubVoteRotationIndependent && fabs(pstSrchOpt->rMinAngle-pstSrchOpt->rMaxAngle) > 1e-5f)
	{
		rMinAngle = pstSrchOpt->rMinAngle - pstRecord->rOrientation;
		rMaxAngle = pstSrchOpt->rMaxAngle - pstRecord->rOrientation;
		pstSrchOpt->rMinAngle = (rMinAngle + rMaxAngle) / 2;
		pstSrchOpt->rMaxAngle = (rMinAngle + rMaxAngle) / 2;
	}
	else
	{
		pstSrchOpt->rMinAngle -= pstRecord->rOrientation;
		pstSrchOpt->rMaxAngle -= pstRecord->rOrientation;
	}

	if (fabs(pstSrchOpt->rMaxScale - pstSrchOpt->rMinScale)*pstEptable->rMaxVoteLength < 2 || pstEptable->ubSpAScaleIndependent)
	{
		rScale = (pstSrchOpt->rMaxScale + pstSrchOpt->rMinScale) / 2;
		state = coarse_search_kernel(&ubbEdgeMap, &coZero, &wbDir, &coZero, &szOp, pstEptable,
			psrOptable, pstSrchOpt, InputType, NULL, rScale, uwScaleLoopIndex, &uwNextObjID);
	}
	else
	{
		if (pstSrchOpt->rMinScale < 1 && pstSrchOpt->rMaxScale > 1)
		{
			rScale = 1;
			state = coarse_search_kernel(&ubbEdgeMap, &coZero, &wbDir, &coZero, &szOp, pstEptable,
				psrOptable, pstSrchOpt, InputType, NULL, rScale, uwScaleLoopIndex, &uwNextObjID);
		}
		IMG_REAL rVector = pstEptable->rMaxVoteLength*pstSrchOpt->rMinScale;
		rScale = pstSrchOpt->rMinScale;
		do 
		{
			state = coarse_search_kernel(&ubbEdgeMap, &coZero, &wbDir, &coZero, &szOp, pstEptable,
				psrOptable, pstSrchOpt, InputType, NULL, rScale, uwScaleLoopIndex, &uwNextObjID);
			uwScaleLoopIndex++;
			if (fabs(rVector + 2 - pstEptable->rMaxVoteLength) > 1)
				rVector += 2;
			else
				rVector += 4;
			rScale = rVector / pstEptable->rMaxVoteLength;
		} while (rScale < pstSrchOpt->rMaxScale);
	}
	for (IMG_INT i = 0; i < psrOptable->size; i++)psrOptable->ptr[i].ulRecTimestamp = pstRecord->ulTimeStamp;
	if (pstEptable->ubVoteRotationIndependent && fabs(pstSrchOpt->rMinAngle - pstSrchOpt->rMaxAngle) > 1e-5f)
	{
		pstSrchOpt->rMinAngle = rMinAngle;
		pstSrchOpt->rMaxAngle = rMaxAngle;
	}
	else
	{
		pstSrchOpt->rMinAngle += pstRecord->rOrientation;
		pstSrchOpt->rMaxAngle += pstRecord->rOrientation;
	}

	if(state != OK) THROW_VIS_EXCEPTION(state);
end:
	if (stAlignExData.uwDebug & 1)
	{
		char objfile[FILENAME_MAX_LENGTH], *p;
		IMG_UINT level = lwVoteLevel + stAlignExData.highest_level;
		ubbSrc = stAlignExData.ubbufReduction[level];
		/*
		ubbSrc.ptr = stAlignExData.pPyrImage[level];
		ubbSrc.size.width = stAlignExData.pPyrStruct->pRoi[level].width;
		ubbSrc.size.height = stAlignExData.pPyrStruct->pRoi[level].height;
		ubbSrc.linestep = ubbSrc.size.width;
		*/
		HL_Printf(m_pHtmlLog, "Coarse Search obj num %d\n", psrOptable->size);
		if (stAlignExData.uwDebug & 4)
		{
			for (int i = 0; i < psrOptable->size && i < 100; i++)
			{
				if (ubbSrc.size.width > JPG_SIZE_LIMITATION || ubbSrc.size.height > JPG_SIZE_LIMITATION)
				{
					_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Search_coarse_obj_%03d.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, i);
				}
				else
				{
					_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Search_coarse_obj_%03d.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, i);
				}
				//_snprintf(objfile, sizeof(objfile), "Search_coarse_obj_%02d.png", i);
				//printf("<%d> ID %d pos %f, %f, scale %f, rotation %f, score %f\n", i, psrOptable->ptr[i].uwID, psrOptable->ptr[i].rco.x, psrOptable->ptr[i].rco.y, psrOptable->ptr[i].scale, psrOptable->ptr[i].rotation, psrOptable->ptr[i].rVoteScore);
				writeLog("ID %d\n", psrOptable->ptr[i].uwID);
				Align_DrawObjInImage(&ubbSrc, psrOptable->ptr + i, pstEptable, 2, 7, objfile);
				p = strrchr(objfile, '\\')-10;
				HL_InsertImage(m_pHtmlLog, p);
				writeLog("\n");
			}
		}
		Align_OutputTableInHTML(m_pHtmlLog, psrOptable, "Coarse Search Result");
	}
	return ;
}

/**
* @brief <B>Description:</B><br> Read record.
*/
IMG_VVOID CVisAlignSearch::SetRecord(CVisAlignRecord *pstRec)
{
	m_AlignRecord= pstRec;
}

/**
* @brief <B>Description:</B><br> backmatch,match feature points
* @param cur_level current pyramid level of backmatch \n
* @param Other-Params Please reference to related vars in CVisAlignSearchInterData
* \n
* @return num_matchedPoints,匹配到的点数.
*/
IMG_INT CVisAlignSearch::back_match(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;

	IMG_UINT		tid = GetCurrentThreadId();
	IMG_INT			i,j,k;
	IMG_INT 		num_template = stAlignExData.Num_template();
	IMG_INT 		num_feat = stAlignExData.Num_blockPoints();
	IMG_REAL 		alpha = stAlignExData.pstObj->scale;
	IMG_OBJ			*pstObj = stAlignExData.pstObj;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	//IppiPyramid 	*pPyrStruct = stAlignExData.PyrStruct();
	//IMG_UBYTE 		**pPyrImage = stAlignExData.PyrImage();
	IMG_BOOL		one2one_match = stAlignExData.Bkmode_one2one();
	IMG_INT			cur_level = stAlignExData.current_level, min_distance_index;

	ALIGN_SEARCH_OPTION *pstSrchOpt = stAlignExData.pstOption;
	IMG_REAL		edgeVariation = pstSrchOpt->rElasticity * 2*pow(0.5, stAlignExData.current_level)+1;
	IMG_REAL		angleTolerance = pstSrchOpt->ubAngleMatchTolerance;
	IMG_REAL		edgeThreshold = pstSrchOpt->uwEdgeThd;// m_LearnOption.LearnInput().ulEdgeThreshold;
	IMG_REAL		*prC= nullptr, *rotateMat = nullptr, *templateMat = nullptr;
	BACK_MATCH_INFO &backmatch_info = stAlignExData.backmatch_info;
	IMG_INT			EdgeVariation_width = (IMG_INT)(edgeVariation+.5) * 2 + 5;		//1 -> 3*3 blockRoi
	const IMG_REAL  MIN_TANGENT_FEATURE_DISTANCE = 2;
	IMG_UWORD uwPhaseInv = stAlignExData.pstOption->uwPhaseInv;

	IppiSize				block_roi = { EdgeVariation_width,EdgeVariation_width };

	EDGE_INFORMATION		*blockEdgeInforarray = (EDGE_INFORMATION *)pool.Malloc(sizeof(EDGE_INFORMATION)*block_roi.height*(size_t)block_roi.width);


	IMG_WBUF		pwMag = stAlignExData.pEdDstMag;
	IMG_RBUF		prAngle = stAlignExData.pEdAngle;

	IMG_UBBUF bufSrc, bufMask;
	IMG_WBUF bufMag;
	IMG_RBUF bufAngle;

	/*
	if ( !rotateMat || !templateMat || !inputAngleMat || !classifyMat)
	{
		status = ippStsNoMemErr;
		goto exit;
	}
	*/
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Enter backmatch. level %d obj %d", cur_level, pstObj->uwID);
		writeLog("Elasticity %.2f\n", edgeVariation);
		writeLog("Edge detect ROI size %d\n", EdgeVariation_width);
	}
	//begin
	{
		//cblas_sgemm() vars init
		//IMG_REAL beta = 1;
		//IMG_INT m = 2, k = 2;

		//vars for block search match

		Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_info.backmatch_pairs);
		backmatch_info.matched_edge_num = 0;
		num_feat = num_template;

		//begin block search match

		for (j = 0; j < num_template; j++)
		{
			//judge if translated_feat[i]&translated_feat[num_template+i] is inside?
			IMG_LRCOORD translated_feat = backmatch_info.backmatch_pairs[j].translated_feat;
			BACK_MATCH_PAIR *pair = backmatch_info.backmatch_pairs+j;
			pair->translated_feat_before_fitting.x = pair->translated_feat.x;
			pair->translated_feat_before_fitting.y = pair->translated_feat.y;
			pair->translated_feat_angle_before_fitting = pair->translated_feat_angle;

			pair->origin_feature = pstTable->pstSpA + j;
			pair->matched_edge_num = 0;
			block_roi = { EdgeVariation_width,EdgeVariation_width };
			//if ((translated_feat.y - edgeVariation - 1) >= 0 && (translated_feat.x - edgeVariation - 1) >= 0 && 
			//	(translated_feat.y - edgeVariation - 1) <= (ubbufReduction[cur_level].size.height - 1) && 
			//	(translated_feat.x - edgeVariation - 1) <= (ubbufReduction[cur_level].size.width - 1))
			{
				//calculate line equation: ax+by+c = 0
				//LINEAR_GENERNAL_EQUATION 	line;
				IMG_INT 					xoff, yoff;
				IMG_UBYTE 					*pSrc = nullptr, *pMask=nullptr;
				IMG_LREAL					normal_distance, tangent_distance, distance, min_distance;
				IMG_REAL					angle_difference, feat_angle = pair->translated_feat_angle;
				//IMG_LREAL					cose, sine;
				IMG_LRCOORD					edge_off;
				IMG_LREAL					angle_score, distance_score, feat_score;


				//cose = cos(D2R*(feat_angle+90));
				//sine = sin(D2R*(feat_angle+90));

				//line.a = sine;
				//line.b = -cose;
				//line.c = -translated_feat.x*sine + translated_feat.y*cose;

				//block edge detect
				IMG_UINT 				subpixelCnt;
				//blockEdgeDetect(auto fill boarder 3*3 -> 5*5)

				xoff = (IMG_INT)(translated_feat.x - edgeVariation +0.5);
				yoff = (IMG_INT)(translated_feat.y - edgeVariation +0.5);
				if (xoff < 0)xoff = 0;
				if (yoff < 0)yoff = 0;
				if (xoff + block_roi.width >= stAlignExData.ubbufReduction[cur_level].size.width)block_roi.width = stAlignExData.ubbufReduction[cur_level].size.width - 1 - xoff;
				if (yoff + block_roi.height >= stAlignExData.ubbufReduction[cur_level].size.height)block_roi.height = stAlignExData.ubbufReduction[cur_level].size.height - 1 - yoff;
				//if (xoff + block_roi.width >= ubbufReduction[cur_level].size.width - 2)block_roi.width = ubbufReduction[cur_level].size.width - 1 - xoff - 2;
				//if (yoff + block_roi.height >= ubbufReduction[cur_level].size.height - 2)block_roi.height = ubbufReduction[cur_level].size.height - 1 - yoff - 2;
				if (block_roi.width <= 0 || block_roi.height <= 0)continue;
				pSrc = stAlignExData.ubbufReduction[cur_level].ptr +  (size_t)yoff*(stAlignExData.ubbufReduction[cur_level].linestep) + (IMG_UINT)xoff;
				if (stAlignExData.pubMask)
					pMask = stAlignExData.ubbufMaskReduction[cur_level].ptr + (size_t)yoff*(stAlignExData.ubbufMaskReduction[cur_level].linestep) + (IMG_UINT)xoff;
				else
					pMask = nullptr;
				if (stAlignExData.pstOption->ubExactMatch)
				{
					edgeThreshold = pair->origin_feature->uwEdgeMag * .7f;
				}
				else
				{
					edgeThreshold = pstSrchOpt->uwEdgeThd;
				}
				if (stAlignExData.coarse_level == stAlignExData.current_level)
				{
					IMG_UINT linestep = pwMag.linestep;
					IMG_WORD *mag = pwMag.ptr + yoff*(size_t)linestep + xoff;
					IMG_REAL *angle = prAngle.ptr + yoff*(size_t)linestep + xoff;
					bufSrc.ptr = pSrc;
					bufSrc.size = { block_roi.width, block_roi.height };
					bufSrc.linestep = linestep;
					bufMask = bufSrc;
					bufMask.ptr = pMask;
					bufMag.ptr = mag;
					bufMag.size = { block_roi.width, block_roi.height };
					bufMag.linestep = linestep;
					bufAngle.ptr = angle;
					bufAngle.size = { block_roi.width, block_roi.height };
					bufAngle.linestep = linestep;
					//subpixelCnt = __blockEdgeDetect(stAlignExData, pool, mag, linestep, angle, linestep, block_roi, edgeThreshold, blockEdgeInforarray);
					subpixelCnt = Align_BlockEdgeDetection(pool, &bufMag, &bufAngle, edgeThreshold, pstTable->ubKernel, blockEdgeInforarray);
				}
				else
				{
					IMG_UINT linestep = stAlignExData.ubbufReduction[cur_level].linestep;
					bufSrc.ptr = pSrc;
					bufSrc.size = { block_roi.width, block_roi.height };
					bufSrc.linestep = linestep;
					bufMask = bufSrc;
					bufMask.ptr = pMask;

					//subpixelCnt = __blockEdgeDetect(stAlignExData, pool, pSrc, (ubbufReduction[cur_level].size.width), block_roi, edgeThreshold, blockEdgeInforarray);
					subpixelCnt = Align_BlockEdgeDetection(pool, &bufSrc, edgeThreshold, pstTable->ubKernel, blockEdgeInforarray);
				}
				feat_score = 0;
				min_distance = 1e10;
				for (i = 0; i < subpixelCnt; i++)
				{
					edge_off.x = blockEdgeInforarray[i].rcoPos.x + xoff;
					edge_off.y = blockEdgeInforarray[i].rcoPos.y + yoff;
					if (pMask)
					{
						if (pMask[(IMG_UINT)blockEdgeInforarray[i].rcoPos.x + (IMG_UINT)blockEdgeInforarray[i].rcoPos.y*(size_t)bufMask.linestep] == 0)continue;
					}
					if (uwPhaseInv == 1)
					{
						angle_difference = Angle_Difference_PhaseInv(blockEdgeInforarray[i].angle, feat_angle);
					}
					else
					{
						angle_difference = Angle_Difference(blockEdgeInforarray[i].angle, feat_angle);
					}
					normal_distance = FeatEdgeNormalDistance(&edge_off, &translated_feat, feat_angle);
					tangent_distance = FeatEdgeTangentDistance(&edge_off, &translated_feat, feat_angle);
					distance = ALIGN_DIST(edge_off, translated_feat);
					IMG_REAL test = sqrt(normal_distance*normal_distance + tangent_distance*tangent_distance);
					if (fabs(test - distance) > 1e-2 && fabs(pstObj->scale) < 10 && fabs(pstObj->scale) > 0.01)
					{
						THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
					}
					//angle_score = Align_Sigmoid(angle_difference, 10.0, 20.0);
					//distance_score = Align_Sigmoid(distance, 1.0, edgeVariation);
					//feat_score = angle_score*distance_score;

					if (angle_difference < angleTolerance && normal_distance < edgeVariation+1)
					{
						if (one2one_match)
						{
							angle_score = Align_Sigmoid(angle_difference, 10.0, 20.0);
							distance_score = Align_Sigmoid(distance, 1.0, edgeVariation);
							if (tangent_distance < MIN_TANGENT_FEATURE_DISTANCE)
							{
								if (pair->matched_edge_num < 1)
								{
									pair->matched_edge[0].coPos.x = blockEdgeInforarray[i].coPos.x + xoff;
									pair->matched_edge[0].coPos.y = blockEdgeInforarray[i].coPos.y + yoff;
									pair->matched_edge[0].rcoPos.x = blockEdgeInforarray[i].rcoPos.x + xoff;
									pair->matched_edge[0].rcoPos.y = blockEdgeInforarray[i].rcoPos.y + yoff;
									pair->matched_edge[0].gradient = blockEdgeInforarray[i].gradient;
									pair->matched_edge[0].angle = blockEdgeInforarray[i].angle;
									pair->matched_normal_distance[0] = normal_distance;
									pair->matched_distance[0] = distance;
									pair->score[0] = feat_score = angle_score*distance_score;
									pair->matched_edge_num++;
									//num_matchedPoints++;
								}
								else
								{
									if (angle_score*distance_score > feat_score)
									{
										feat_score = angle_score*distance_score;
										pair->matched_edge[0].coPos.x = blockEdgeInforarray[i].coPos.x + xoff;
										pair->matched_edge[0].coPos.y = blockEdgeInforarray[i].coPos.y + yoff;
										pair->matched_edge[0].rcoPos.x = blockEdgeInforarray[i].rcoPos.x + xoff;
										pair->matched_edge[0].rcoPos.y = blockEdgeInforarray[i].rcoPos.y + yoff;
										pair->matched_edge[0].gradient = blockEdgeInforarray[i].gradient;
										pair->matched_edge[0].angle = blockEdgeInforarray[i].angle;
										pair->matched_normal_distance[0] = normal_distance;
										pair->matched_distance[0] = distance;
										pair->score[0] = feat_score = angle_score*distance_score;
									}
								}
							}
						}
						else
						{
							if (distance < 1)
							{
								if (distance < min_distance)
								{
									pair->matched_edge[0].coPos.x = blockEdgeInforarray[i].coPos.x + xoff;
									pair->matched_edge[0].coPos.y = blockEdgeInforarray[i].coPos.y + yoff;
									pair->matched_edge[0].rcoPos.x = blockEdgeInforarray[i].rcoPos.x + xoff;
									pair->matched_edge[0].rcoPos.y = blockEdgeInforarray[i].rcoPos.y + yoff;
									pair->matched_edge[0].gradient = blockEdgeInforarray[i].gradient;
									pair->matched_edge[0].angle = blockEdgeInforarray[i].angle;
									pair->matched_normal_distance[0] = normal_distance;
									pair->score[0] = 0;
									pair->matched_distance[0] = distance;
									//num_matchedPoints -= pair->matched_edge_num - 1;
									pair->matched_edge_num=1;
								}
							}
							else
							{
								if (pair->matched_edge_num < MAX_MATCH_PT_NUM)
								{
									if (min_distance > 1)
									{
										pair->matched_edge[pair->matched_edge_num].coPos.x = blockEdgeInforarray[i].coPos.x + xoff;
										pair->matched_edge[pair->matched_edge_num].coPos.y = blockEdgeInforarray[i].coPos.y + yoff;
										pair->matched_edge[pair->matched_edge_num].rcoPos.x = blockEdgeInforarray[i].rcoPos.x + xoff;
										pair->matched_edge[pair->matched_edge_num].rcoPos.y = blockEdgeInforarray[i].rcoPos.y + yoff;
										pair->matched_edge[pair->matched_edge_num].gradient = blockEdgeInforarray[i].gradient;
										pair->matched_edge[pair->matched_edge_num].angle = blockEdgeInforarray[i].angle;
										pair->matched_normal_distance[pair->matched_edge_num] = normal_distance;
										pair->score[pair->matched_edge_num] = 0;
										pair->matched_distance[pair->matched_edge_num] = distance;
										pair->matched_edge_num++;
										//num_matchedPoints++;
									}
								}
							}
							if (min_distance > distance)
							{
								min_distance = distance;
								min_distance_index = pair->matched_edge_num - 1;
							}
						}
					}
				}
				//for (i = 0; i < pair->matched_edge_num; i++)
				//{
				//	g_log.Printf(tid, "test", 0, "[%d]%f %f <=> [%d]%f %f score %f", j, translated_feat.x, translated_feat.y, i, pair->matched_edge[i].rcoPos.x, pair->matched_edge[i].rcoPos.y, pair->score[i]);
				//}
				//pool.PFree(blockEdgeInforarray);
			}
			if (pair->matched_edge_num > 3)
			{
				IMG_REAL distance;
				IMG_INT index;
				EDGE_INFORMATION edge;
				if (min_distance_index != 0)
				{
					edge = pair->matched_edge[min_distance_index];
					pair->matched_edge[min_distance_index] = pair->matched_edge[0];
					pair->matched_edge[0] = edge;
				}
				for (i = 1, index = 1; i < pair->matched_edge_num; i++)
				{
					distance = ALIGN_DIST(pair->matched_edge[i].rcoPos, pair->matched_edge[0].rcoPos);
					if (distance < 1.5)
					{
						if (index != i)
						{
							pair->matched_edge[index] = pair->matched_edge[i];
						}
						index++;
					}
				}
				pair->matched_edge_num = index;
			}
			backmatch_info.matched_edge_num += pair->matched_edge_num;
		}
		if (stAlignExData.uwDebug & 1)
		{
			//cout << endl << "num_matchedPoints = " << num_matchedPoints << endl << "num_feat =  " << num_feat << endl;
			HL_Printf(m_pHtmlLog, "num_matchedPoints = %d\n", backmatch_info.matched_edge_num);
			HL_Printf(m_pHtmlLog, "num_feat = %d\n", num_feat);
			HL_Printf(m_pHtmlLog, "proportion:%f\n", ((IMG_REAL)backmatch_info.matched_edge_num / num_feat));
		}
		//set var
	}
exit:
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("backMatchStatus: %s\n", ippGetStatusString(status));
	}
	return status;
}

IMG_INT CVisAlignSearch::back_match_segment(CVisAlignSearchInterData &stAlignExData, ALIGN_REC_SEGMENT *segInput, IMG_INT segNums)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;

	IMG_UINT		tid = GetCurrentThreadId();
	IMG_INT			i, j, k, index;
	IMG_INT 		num_template = stAlignExData.Num_template();
	IMG_INT 		num_feat = stAlignExData.Num_blockPoints();
	IMG_REAL 		alpha = stAlignExData.pstObj->scale;
	IMG_OBJ			*pstObj = stAlignExData.pstObj;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	//IppiPyramid 	*pPyrStruct = stAlignExData.PyrStruct();
	//IMG_UBYTE 		**pPyrImage = stAlignExData.PyrImage();
	IMG_BOOL		one2one_match = stAlignExData.Bkmode_one2one();
	IMG_INT			cur_level = stAlignExData.current_level;

	ALIGN_SEARCH_OPTION *pstSrchOpt = m_SearchOption.GetSearchPara();
	IMG_REAL		edgeVariation = pstSrchOpt->rElasticity * 2 * pow(0.5, stAlignExData.current_level) + 1;
	IMG_REAL		angleTolerance = pstSrchOpt->ubAngleMatchTolerance;
	IMG_REAL		edgeThreshold = pstSrchOpt->uwEdgeThd;// m_LearnOption.LearnInput().ulEdgeThreshold;
	IMG_REAL		*prC = nullptr, *rotateMat = nullptr, *templateMat = nullptr;
	BACK_MATCH_INFO &backmatch_info = stAlignExData.backmatch_info;
	IMG_INT			EdgeVariation_width = (IMG_INT)(edgeVariation + .5) * 2 + 5;		//1 -> 3*3 blockRoi
	const IMG_REAL  MIN_TANGENT_FEATURE_DISTANCE = 2;
	IMG_UWORD uwPhaseInv = m_SearchOption.GetPhaseInv();
	IMG_REAL *distanceSeg = (IMG_REAL*)pool.PMalloc(sizeof(IMG_REAL)*segNums);
	IMG_RCOORD *pointSeg = (IMG_RCOORD*)pool.PMalloc(sizeof(IMG_RCOORD)*segNums);
	IMG_REAL *angleSeg = (IMG_REAL*)pool.PMalloc(sizeof(IMG_REAL)*segNums);
	IMG_BOOL bVal;
	//IppiSize				block_roi = { EdgeVariation_width,EdgeVariation_width };

	//EDGE_INFORMATION		*blockEdgeInforarray = (EDGE_INFORMATION *)pool.Malloc(sizeof(EDGE_INFORMATION)*block_roi.height*(size_t)block_roi.width);


	//IMG_WBUF		pwMag = stAlignExData.pEdDstMag;
	//IMG_RBUF		prAngle = stAlignExData.pEdAngle;

	//IMG_UBBUF bufSrc;
	//IMG_WBUF bufMag;
	//IMG_RBUF bufAngle;

	/*
	if ( !rotateMat || !templateMat || !inputAngleMat || !classifyMat)
	{
	status = ippStsNoMemErr;
	goto exit;
	}
	*/
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Enter backmatch. level %d obj %d", cur_level, pstObj->uwID);
		writeLog("Elasticity %.2f\n", edgeVariation);
		writeLog("Edge detect ROI size %d\n", EdgeVariation_width);
	}
	//begin
	{
		//cblas_sgemm() vars init
		//IMG_REAL beta = 1;
		//IMG_INT m = 2, k = 2;

		//vars for block search match

		Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_info.backmatch_pairs);
		backmatch_info.matched_edge_num = 0;
		num_feat = num_template;

		vector<vector<PARA_POINT>>vec_vecParaPts;
		vector<PARA_POINT>vec_tmpParaPts;
		ALIGN_REC_SEGMENT *tempSeg;
		for (i = 0; i < segNums; i++)
		{
			
			if (segInput[i].seg_type == ALIGN_REC_BSPLINE_SEGMENT)
			{
				tempSeg = segInput + i;
				if (tempSeg->curve.num_points == 0)
				{
					vec_tmpParaPts.clear();
					continue;
				}
				IMG_RCOORD *tmpCoor = new IMG_RCOORD[tempSeg->curve.num_points];
				for (j = 0; j < tempSeg->curve.num_points; j++)
				{
					tmpCoor[j] = tempSeg->curve.control_points[j];
				}
				CVisNURBSCurve nurbsCurve(tempSeg->curve.isClosed);
				nurbsCurve.SetInputPara(tmpCoor, tempSeg->curve.num_points, tempSeg->curve.dims);
				nurbsCurve.GetCurvePts(200, vec_tmpParaPts);

				if (vec_tmpParaPts.size() > 0)
				{
					vec_vecParaPts.push_back(vec_tmpParaPts);
				}
				vec_tmpParaPts.clear();
				if (tmpCoor)
				{
					delete[]tmpCoor;
					tmpCoor = nullptr;
				}
			}
		}
		//begin block search match
		int curveIndex = 0;
		double maxDist = 1e7;
		double tmpDist = 0;
		int ptIndex = 0;
		for (j = 0; j < num_template; j++)
		{
			//judge if translated_feat[i]&translated_feat[num_template+i] is inside?
			IMG_LRCOORD translated_feat = backmatch_info.backmatch_pairs[j].translated_feat;
			BACK_MATCH_PAIR *pair = backmatch_info.backmatch_pairs + j;
			pair->translated_feat_before_fitting.x = pair->translated_feat.x;
			pair->translated_feat_before_fitting.y = pair->translated_feat.y;
			pair->translated_feat_angle_before_fitting = pair->translated_feat_angle;

			pair->origin_feature = pstTable->pstSpA + j;
			pair->matched_edge_num = 0;
			maxDist = 1e7;
			//block_roi = { EdgeVariation_width,EdgeVariation_width };
			//if ((translated_feat.y - edgeVariation - 1) >= 0 && (translated_feat.x - edgeVariation - 1) >= 0 && 
			//	(translated_feat.y - edgeVariation - 1) <= (ubbufReduction[cur_level].size.height - 1) && 
			//	(translated_feat.x - edgeVariation - 1) <= (ubbufReduction[cur_level].size.width - 1))
			{
				//calculate line equation: ax+by+c = 0
				//LINEAR_GENERNAL_EQUATION 	line;
				//IMG_INT 					xoff, yoff;
				//IMG_UBYTE 					*pSrc = nullptr;
				IMG_LREAL					normal_distance, tangent_distance, distance, min_distance;
				IMG_REAL					tempAngle, segAngle, angle_difference, feat_angle = pair->translated_feat_angle;
				//IMG_LREAL					cose, sine;
				IMG_LRCOORD					edge_off, segEdge;
				IMG_LREAL					angle_score, distance_score, feat_score;
				//ALIGN_REC_SEGMENT *tempSeg;
				curveIndex = 0;
				for (k = 0; k < segNums; k++)
				{
					tempSeg = segInput + k;
					maxDist = 1e7;
					switch (tempSeg->seg_type)
					{
					case ALIGN_REC_LINE_SEGMENT:
						IMG_RCOORD pt[2], dstPt;
						pt[0] = tempSeg->start; pt[1] = tempSeg->end;
						bVal = VisMath::MATH_Pt2SegmentPedal(pt, { (IMG_REAL)translated_feat.x, (IMG_REAL)translated_feat.y }, dstPt);
						if (bVal)
						{
							pointSeg[k] = dstPt;
							angleSeg[k] = atan2(tempSeg->end.y - tempSeg->start.y, tempSeg->end.x - tempSeg->start.x) / D2R - 90;
							if (angleSeg[k] < 0)angleSeg[k] += 360;
							distanceSeg[k] = sqrt((translated_feat.x - dstPt.x)*(translated_feat.x - dstPt.x) + (translated_feat.y - dstPt.y)*(translated_feat.y - dstPt.y));
						}
						else
						{
							distanceSeg[k] = 1e7;
						}
						break;
					case ALIGN_REC_ARC_SEGMENT:
						IMG_RCOORD ptArc[3], dstArcPt;
						ptArc[0] = tempSeg->start; ptArc[1] = tempSeg->center[0]; ptArc[2] = tempSeg->end;
						bVal = VisMath::MATH_Pt2ArcPedal(ptArc, { (IMG_REAL)translated_feat.x, (IMG_REAL)translated_feat.y }, dstArcPt);
						if (bVal)
						{
							pointSeg[k] = dstArcPt;
							angleSeg[k] = atan2(tempSeg->center[0].y - dstArcPt.y, tempSeg->center[0].x - dstArcPt.x) / D2R;
							if (angleSeg[k] < 0)angleSeg[k] += 360;
							distanceSeg[k] = sqrt((translated_feat.x - dstArcPt.x)*(translated_feat.x - dstArcPt.x) + (translated_feat.y - dstArcPt.y)*(translated_feat.y - dstArcPt.y));
						}
						else
						{
							distanceSeg[k] = 1e7;
						}
						break;
					case ALIGN_REC_BSPLINE_SEGMENT:
						vec_tmpParaPts = vec_vecParaPts[curveIndex];
						
						for (int mm = 0; mm < vec_tmpParaPts.size(); mm++)
						{
							tmpDist = sqrt((translated_feat.x - vec_tmpParaPts[mm].pt.x)*(translated_feat.x - vec_tmpParaPts[mm].pt.x) + 
								(translated_feat.y - vec_tmpParaPts[mm].pt.y)*(translated_feat.y - vec_tmpParaPts[mm].pt.y));
							if (tmpDist < maxDist)
							{
								maxDist = tmpDist;
								ptIndex = mm;
							}
						}
						pointSeg[k].x = (float)vec_tmpParaPts[ptIndex].pt.x;
						pointSeg[k].y = (float)vec_tmpParaPts[ptIndex].pt.y;
						angleSeg[k] = vec_tmpParaPts[ptIndex].angle;
						distanceSeg[k] = (float)maxDist;
						curveIndex++;
						vec_tmpParaPts.clear();
						break;
					default:
						THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
						break;

					}
				}
				ippsMinIndx_32f(distanceSeg, segNums, &tempAngle, &index);
				segAngle = angleSeg[index];
				segEdge.x = (IMG_LREAL)pointSeg[index].x; segEdge.y = (IMG_LREAL)pointSeg[index].y;
				
				angle_difference = Angle_Difference_PhaseInv(segAngle, feat_angle);
				normal_distance = FeatEdgeNormalDistance(&segEdge, &translated_feat, feat_angle);
				tangent_distance = FeatEdgeTangentDistance(&segEdge, &translated_feat, feat_angle);
				distance = ALIGN_DIST(segEdge, translated_feat);
				IMG_REAL test = sqrt(normal_distance*normal_distance + tangent_distance*tangent_distance);
				if ((distanceSeg[index] < 1e3 && fabs(test - distance) > 1e-2) && fabs(pstObj->scale) < 10 && fabs(pstObj->scale) > 0.01)
				{
					THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
				}
				if (angle_difference < angleTolerance && normal_distance < edgeVariation + 1)
				{
					angle_score = Align_Sigmoid(angle_difference, 10.0, 20.0);
					distance_score = Align_Sigmoid(distance, 1.0, edgeVariation);
					if (tangent_distance < MIN_TANGENT_FEATURE_DISTANCE)
					{
						if (pair->matched_edge_num < 1)
						{
							pair->matched_edge[0].coPos.x = segEdge.x;
							pair->matched_edge[0].coPos.y = segEdge.y;
							pair->matched_edge[0].rcoPos.x = segEdge.x;
							pair->matched_edge[0].rcoPos.y = segEdge.y;
							pair->matched_edge[0].gradient = 50;
							pair->matched_edge[0].angle = segAngle;
							pair->matched_normal_distance[0] = normal_distance;
							pair->matched_distance[0] = distance;
							pair->score[0] = feat_score = angle_score*distance_score;
							pair->matched_edge_num++;
							//num_matchedPoints++;
						}
						else
						{
							if (angle_score*distance_score > feat_score)
							{
								feat_score = angle_score*distance_score;
								pair->matched_edge[0].coPos.x = segEdge.x;
								pair->matched_edge[0].coPos.y = segEdge.y;
								pair->matched_edge[0].rcoPos.x = segEdge.x;
								pair->matched_edge[0].rcoPos.y = segEdge.y;
								pair->matched_edge[0].gradient = 50;
								pair->matched_edge[0].angle = segAngle;
								pair->matched_normal_distance[0] = normal_distance;
								pair->matched_distance[0] = distance;
								pair->score[0] = feat_score = angle_score*distance_score;
							}
						}
					}					
				}

			}
			backmatch_info.matched_edge_num += pair->matched_edge_num;
		}
		if (stAlignExData.uwDebug & 1)
		{
			//cout << endl << "num_matchedPoints = " << num_matchedPoints << endl << "num_feat =  " << num_feat << endl;
			HL_Printf(m_pHtmlLog, "num_matchedPoints = %d\n", backmatch_info.matched_edge_num);
			HL_Printf(m_pHtmlLog, "num_feat = %d\n", num_feat);
			HL_Printf(m_pHtmlLog, "proportion:%f\n", ((IMG_REAL)backmatch_info.matched_edge_num / num_feat));
		}
		//set var
	}
exit:
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("backMatchStatus: %s\n", ippGetStatusString(status));
	}
	return status;
}

IMG_INT CVisAlignSearch::iterationfit(CVisAlignSearchInterData &stAlignExData)
{
	IMG_BOOL angle = fabs(stAlignExData.pstOption->rMaxAngle - stAlignExData.pstOption->rMinAngle) < 1e-6 || stAlignExData.pstTable->ubSpARotationIndependent;
	IMG_BOOL scale = fabs(stAlignExData.pstOption->rMaxScale - stAlignExData.pstOption->rMinScale) < 1e-6 || stAlignExData.pstTable->ubSpAScaleIndependent;
	if (stAlignExData.pstOption->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
	{
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Ellipse mode Fitting");
		}
		return iterationfit_ellipse(stAlignExData);
	}
	else if(angle && scale)
	{
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Fixed angle and scale mode Fitting");
		}
		return iterationfit_fixanglescale(stAlignExData);
	}
	else if (angle)
	{
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Fixed angle mode Fitting");
		}
		return iterationfit_fixangle(stAlignExData);
	}
	else if (scale)
	{
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Fixed scale mode Fitting");
		}
		return iterationfit_fixscale(stAlignExData);

	}
	//else if(stAlignExData.pstOption->ubFittingOption == )
	else
	{
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Normal Fitting");
		}
		return iterationfit_RTS(stAlignExData);
	}
}

/**
* @brief <B>Description:</B><br> do fitting to get S,sinTheta,cosTheta
*	X_offset,Y_offset,fitting score and MSE. (final level of pyramid)
* @param Other-Params Please reference to related vars in CVisAlignSearchInterData
*/
IMG_INT CVisAlignSearch::iterationfit_RTS(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;

	//init var
	IMG_INT i, j, k, m;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	IMG_INT 	num_feat = pstTable->uwNumOfSpAFeature;
	IMG_FEATUREPT *pstSpA = pstTable->pstSpA;
	BACK_MATCH_INFO &backmatch = stAlignExData.backmatch_info;
	BACK_MATCH_PAIR *backmatch_pairs = stAlignExData.backmatch_info.backmatch_pairs;
	IMG_OBJ	*pstObj = stAlignExData.pstObj;
	IMG_LREAL	*prWB = nullptr;//stAlignExData.CharBtir();
	IMG_INT 	num_matchedPoints = backmatch.matched_edge_num;//stAlignExData.Num_matchedPoints();
	IMG_INT 	num_template = stAlignExData.Num_template();
	IMG_UINT	eqx, eqy;
	IMG_LREAL 	mse = 0, fitscore = 0, matched, sum_weight;
	IMG_LREAL fitting_sigma;
	IMG_LREAL edget_variance = stAlignExData.pstOption->rElasticity / pow(2, stAlignExData.current_level) + 2;
	IMG_LREAL cose, sine;
	const IMG_UINT	NumOfUnknown = 4;
	FILE *fp = nullptr;
	HTMLLOGGING_TABLE_DATA stTable;
	IMG_CHAR pathname[FILENAME_MAX_LENGTH];

	//begin
	{
		//vars for fitting
		IMG_LREAL lastsum = 0, nowsum = 0;
		IMG_INT iter_t = 0;
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Start Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
				pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);

			IMG_CHAR title[40];
			_snprintf(title, sizeof(title), "Fitting of Obj ID %d", pstObj->uwID);
			HL_InitTableData(&stTable);
			stTable.title = title;
			stTable.tablelinewidth = 0;
			stTable.column = 7;
			stTable.fontweight = FW_Medium;
			stTable.tablealign = TX_CENTER;
			stTable.tablewidth = 50;
			stTable.tablelinewidth = 1;
			stTable.bgColorOddLine = 0x90B0FF;
			stTable.formatstring = "%.6f";
			stTable.datatype = DT_REAL;
			stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
			stTable.heading[0] = "No.";
			stTable.heading[1] = "PosX";
			stTable.heading[2] = "PosY";
			stTable.heading[3] = "Scale";
			stTable.heading[4] = "Rotation";
			stTable.heading[5] = "Fitting Score";
			stTable.heading[6] = "MSE";
			HL_CreateTableHeader(m_pHtmlLog, &stTable);
			
		}
		//var to cal mse and fitScore
		/*
		vector<IMG_REAL> distanceVec;
		for (IMG_INT a = 0; a < num_matchedPoints + 1; a++)
		{
			distanceVec.push_back(pDistanceVecArray[a]);
		}
		*/

		//matrix vars
		IMG_LREAL *error_weight = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error_weight
		for ( i = 0, j = 0, k = 0; i < num_feat; i++)
		{
			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			{
				error_weight[k++] = backmatch_pairs[i].origin_feature->rWeighting * (1 / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
			}
		}
		assert(k == backmatch.matched_edge_num);
		//for (i = 0; i < num_matchedPoints; i++)
		//{
		//	error_weight[i] = 1;
		//}


		IMG_LREAL *prB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		// Record "B" in "wAX = wB" and "AX-B"
		memset(prB, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL * Xtemp = (IMG_LREAL *)pool.Malloc(NumOfUnknown * sizeof(IMG_LREAL));		//extract 0~3 elements in prWB
		IMG_LREAL *error = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error, 0, num_matchedPoints* sizeof(IMG_LREAL));
		IMG_LREAL *error_iter = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error_iter, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *prWA, *prA, *prWABack, *prwBBack;
		prWA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));		//wA
		prA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prWABack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prWB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB
		prwBBack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB

		if (stAlignExData.Bkmode_one2one())
		{
			fitting_sigma = ((edget_variance) / 6.0);
			if (stAlignExData.pstOption->rFittingSigma > 0) fitting_sigma = stAlignExData.pstOption->rFittingSigma;
		}
		else
		{
			fitting_sigma = ((edget_variance /*+ 2.0*/) / 3.0);
		}
		//fitting
		do {
			pool.Push();
			lastsum = nowsum;
			nowsum = 0;
			cose = cos(pstObj->rotation*D2R);
			sine = sin(pstObj->rotation*D2R);

			memset(prWA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prWB, 0, num_matchedPoints* sizeof(IMG_LREAL));
			

			//if (stAlignExData.Bkmode_one2one())
			//{
			//	fitting_sigma = 0.3;
			//}
			//else
			//{
			//	fitting_sigma = 1+;
			//}
			IMG_UINT feat_class;// = backmatch_pairs[i].origin_feature->ubOutMain;
												//construct "A"
			for (i = 0, k = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prA[k] = backmatch_pairs[i].matched_edge[j].rcoPos.x;
						prA[k + 1] = backmatch_pairs[i].matched_edge[j].rcoPos.y;
						prA[k + 2] = 1.0;
						prA[k + 3] = 0.0;
						k = k + NumOfUnknown;
					}
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prA[k] = backmatch_pairs[i].matched_edge[j].rcoPos.y;
						prA[k + 1] = -backmatch_pairs[i].matched_edge[j].rcoPos.x;
						prA[k + 2] = 0.0;
						prA[k + 3] = 1.0;
						k = k + NumOfUnknown;
					}
				}
			}

			//construct "wA"
			for (i = 0, k = 0, m = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0 )
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prWA[k] = backmatch_pairs[i].matched_edge[j].rcoPos.x * error_weight[m];
						prWA[k + 1] = backmatch_pairs[i].matched_edge[j].rcoPos.y * error_weight[m];
						prWA[k + 2] = 1.0* error_weight[m];
						prWA[k + 3] = 0.0;
						k = k + NumOfUnknown; m++;
					}
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prWA[k] = backmatch_pairs[i].matched_edge[j].rcoPos.y * error_weight[m];
						prWA[k + 1] = -backmatch_pairs[i].matched_edge[j].rcoPos.x * error_weight[m];
						prWA[k + 2] = 0.0;
						prWA[k + 3] = 1.0* error_weight[m];
						k = k + NumOfUnknown; m++;
					}
				}
			}
			memcpy(prWABack, prWA, k * sizeof(IMG_LREAL));

			//construct "B"
			eqx = eqy = 0;
			for (i = 0, j = 0, k = 0; i < num_feat; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0 )
				{
					//prB[j] = matchedPointPosMat[i].x;
					for(j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
					{
						prB[k++] = pstSpA[i].rco.x;
					}
					eqx+=backmatch_pairs[i].matched_edge_num;
				}
				else 
				{
					for(j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
					{
						prB[k++] = pstSpA[i].rco.y;
					}
					eqy+=backmatch_pairs[i].matched_edge_num;
				}
			}
			if (eqx == 0 || eqy == 0)
			{
				pstObj->rLikeScore = -1;
				if (stAlignExData.uwDebug & 1)
				{
					HL_CloseTable(m_pHtmlLog);
					writeLog("equation x or y lost all points");
				}
				pool.Pop();
				break;
			}
			//construct "wB"
			for (i = 0, j = 0; i < num_feat; i++)
			{
				for (k = 0; k < backmatch_pairs[i].matched_edge_num; k++)
				{
					prWB[j] = prB[j] * error_weight[j] ;
					prwBBack[j] = prWB[j];
					j++;
				}
			}

			//for (i = 0; i < backmatch.matched_edge_num; i++)
			//{
			//	prWB[i] = prB[i] * error_weight[i]/ backmatch_pairs[i].matched_edge_num;
			//}

			//fitting X in "wAX = wB"
			try
			{
				IMG_UWORD debug = 0;
				IMG_LRBUF rbufA, rbufB, rbufX, rbufW;
				IMG_LREAL iter_mse;

				rbufA.ptr = prA;
				rbufA.size.width = NumOfUnknown;
				rbufA.size.height = num_matchedPoints;
				rbufA.linestep = NumOfUnknown;
				rbufB.ptr = prB;
				rbufB.size.width = 1;
				rbufB.size.height = num_matchedPoints;
				rbufB.linestep = 1;
				rbufW.ptr = error_weight;
				rbufW.size.width = 1;
				rbufW.size.height = num_matchedPoints;
				rbufW.linestep = 1;
				rbufX.ptr = Xtemp;
				rbufX.size.width = 1;
				rbufX.size.height = NumOfUnknown;
				rbufX.linestep = 1;
				IMG_CHAR title[80];
				if (stAlignExData.uwDebug & 4) debug = 1;
				_snprintf(title, sizeof(title), "Level %d OBJ ID %d iter %d", stAlignExData.current_level, pstObj->uwID, iter_t);
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
				VisMath::MATH_SetLogTitle(title);
				VisMath::MATH_SetDebug(debug, pathname);
				VisMath::MATH_SolveAXB(&rbufA, &rbufB, &rbufX, &rbufW, &iter_mse);
				//printf("iter_mse = %f\n", iter_mse);
			}
			catch (CVisException &e)
			{
				//something wrong in fitting;
			}
			//LAPACKE_dgels(LAPACK_ROW_MAJOR, 'N', backmatch.matched_edge_num, NumOfUnknown, 1, prWA, NumOfUnknown, prWB, 1);

			//Xtemp[0] = prWB[0];
			//Xtemp[1] = prWB[1];
			//Xtemp[2] = prWB[2];
			//Xtemp[3] = prWB[3];

			pstObj->rotation = atan2(Xtemp[1], Xtemp[0]) / D2R;
			pstObj->scale = 1 / sqrt(Xtemp[1] * Xtemp[1] + Xtemp[0] * Xtemp[0]);

			pstObj->rco.x = (Xtemp[3] * Xtemp[1] - Xtemp[2] * Xtemp[0]) / (Xtemp[1] * Xtemp[1] + Xtemp[0] * Xtemp[0]);
			pstObj->rco.y = -(Xtemp[3] * Xtemp[0] + Xtemp[2] * Xtemp[1]) / (Xtemp[1] * Xtemp[1] + Xtemp[0] * Xtemp[0]);

			cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, backmatch.matched_edge_num, 1, NumOfUnknown, 1, prA, NumOfUnknown, Xtemp, 1, -1, prB, 1);

			//cal error ^ 2
			for (i = 0; i < num_matchedPoints; i++)
			{
				error[i] = prB[i] * prB[i];
				nowsum = error[i] + nowsum;
			}
			cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, backmatch.matched_edge_num, 1, NumOfUnknown, 1, prWA, NumOfUnknown, Xtemp, 1, -1, prwBBack, 1);

			//update error_weight
			for (i = 0, k = 0; i < num_feat; i++)
			{
				for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
				{
					//error_iter[k] = 0.5 / (-0.5 + exp((error[k]) / (fitting_sigma*fitting_sigma)));
					error_iter[k] = 1 / (1 - exp(-1 / (fitting_sigma*fitting_sigma)) + exp((error[k] - 1) / (fitting_sigma*fitting_sigma)));
					error_weight[k] = pstSpA[i].rWeighting * (error_iter[k] / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
					k++;
				}
			}
			//for (i = 0; i < num_matchedPoints; i++)
			//{

			//	error_weight[i] = pstSpA[i].ubWeighting * 1.0 / (1 + exp((error[i]) / (fitting_sigma*fitting_sigma)));
			//	//cout << error_weight[i] << endl;
			//}
			//cal fitting score and mse
			IMG_LREAL total_weight, origin_weight, max_weight, sum_weight, min_mse = 0, sum_mse = 0;
			total_weight = 0;
			sum_weight = 0;
			for(i = 0, j = 0, k = 0; i<num_feat; i++)
			{
				total_weight += pstSpA[i].rWeighting;
				max_weight = 0;
				min_mse = 0;
				for(j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
				{
					if (max_weight < error_iter[k]*pstSpA[i].rWeighting)
					{
						max_weight = error_iter[k]*pstSpA[i].rWeighting;
						min_mse = error[k];
					}
					k++;
				}
				sum_weight += max_weight;
				sum_mse += min_mse;
			}	
			fitscore = sum_weight / total_weight;
			mse  = sum_mse;
			pstObj->rLikeScore = fitscore;
			pstObj->rMSE = mse;
			if (stAlignExData.uwDebug & 1)
			{
				char value[7][20];
				if (iter_t % 2)		stTable.bgColorOddLine = 0xafffff;
				else			stTable.bgColorOddLine = 0xcfffff;
				_snprintf(value[0], sizeof(value[0]), "%d", iter_t);
				_snprintf(value[1], sizeof(value[1]), "%.3f", pstObj->rco.x);
				_snprintf(value[2], sizeof(value[2]), "%.3f", pstObj->rco.y);
				_snprintf(value[3], sizeof(value[3]), "%.6f", pstObj->scale);
				_snprintf(value[4], sizeof(value[4]), "%.6f", pstObj->rotation);
				_snprintf(value[5], sizeof(value[5]), "%.3f", pstObj->rLikeScore);
				_snprintf(value[6], sizeof(value[6]), "%.3f", pstObj->rMSE);
				HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
				//writeLog("x = %f, y = %f, rotation = %f, scale = %f, fitscore[%d] = %f， mse[%d] = %f\n", 
				//	pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, iter_t, fitscore, iter_t, nowsum);
			}

			iter_t++;
			//cout << "迭代次数" << iter_t << endl;
			//cout << "sum:" << nowsum << "  ..." << lastsum << endl;
			pool.Pop();
		} while (abs(nowsum - lastsum) > 0.02 && iter_t <20);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			writeLog("fitting sigma = %f", fitting_sigma);
		}

		Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_pairs);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			HL_Printf(m_pHtmlLog, "\n");
			//
			//fp = fopen("backmatch.txt", "at");
			//if (fp)		fprintf(fp, "--------------Obj ID:%d----------------\n", pstObj->uwID);
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)
			//	{
			//		fprintf(fp, "A/B\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prA[k], prA[k + 1], prA[k + 2], prA[k + 3], prB[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "wA/wB\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prWABack[k], prWABack[k + 1], prWABack[k + 2], prWABack[k + 3], prwBBack[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "\nResult: \n% 12.6f % 12.6f % 12.6f % 12.6f\n", Xtemp[0], Xtemp[1], Xtemp[2], Xtemp[3]);
			//	}
			//}
		}
		//cal matching score
		matched = sum_weight = 0;
		if (stAlignExData.uwDebug & 4/* && fp != nullptr*/)
		{
			IMG_CHAR title[80];
			IMG_CHAR *heading[22];
			heading[0] = "FeatID";
			heading[1] = "SrcX";
			heading[2] = "SrcY";
			heading[3] = "SrcAngle";
			heading[4] = "SrcMag";
			heading[5] = "TransXBeforeFit";
			heading[6] = "TransYBeforeFit";
			heading[7] = "TransAngleBeforeFit";
			heading[8] = "TransXAfterFit";
			heading[9] = "TransYAfterFit";
			heading[10] = "TransAngleAfterFit";
			heading[11] = "ImageX";
			heading[12] = "ImageY";
			heading[13] = "ImageAngle";
			heading[14] = "ImageMag";
			heading[15] = "NormalDistBeforeFit";
			heading[16] = "NormalDistAfterFit";
			heading[17] = "Weight/NumOfPt";
			heading[18] = "Error";
			heading[19] = "WeightedError";
			heading[20] = "AXBError";
			heading[21] = "Sigma";
			if(stAlignExData.Bkmode_one2one())
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04dO.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);
			else
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04d.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);

			_snprintf(title, sizeof(title), "Fitting point info of Obj ID %d at level %d\n", pstObj->uwID, stAlignExData.current_level);
			fp = fopen(pathname, "at");
			if (fp)
			{
				fprintf(fp, "%s", title);
				for (i = 0; i < 22; i++)
				{
					fprintf(fp, "%s\t", heading[i]);
				}
				fprintf(fp, "\n");
			}
			//fprintf(fp, "--------------Obj ID:%d----------------\n", pstObj->uwID);
			//fprintf(fp, "featID\t x\t y\t angle\t tran_x\t tran_y\t img_x\t img_y\t ndist\t dist\t error\t weight\t eweight\t sigma\t e\t error\n");
		}
		for(i = 0, k = 0; i<num_feat; i++)
		{
			IMG_LREAL dist = 1e10, mindist = 1e10;
			IMG_LREAL angle, anglediff;
			char value[22][20];
			for(j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
			{
				//angle = atan2(backmatch_pairs[i].matched_edge[j].rcoPos.y-backmatch_pairs[i].translated_feat.y, backmatch_pairs[i].matched_edge[j].rcoPos.x-backmatch_pairs[i].translated_feat.x)/D2R;
				//anglediff = pstSpA[i].angle - angle;
				IMG_LRCOORD lrco = { backmatch_pairs[i].matched_edge[j].rcoPos.x, backmatch_pairs[i].matched_edge[j].rcoPos.y};
				dist = FeatEdgeNormalDistance(&lrco, &backmatch_pairs[i].translated_feat, backmatch_pairs[i].translated_feat_angle);
				if(mindist > dist)
					mindist = dist;
				if (stAlignExData.uwDebug & 4)
				{
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.x);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.y);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].angle);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].gradient);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", backmatch_pairs[i].matched_normal_distance[j]);
					_snprintf(value[16], sizeof(value[11]), "%.3f", dist);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting / backmatch_pairs[i].matched_edge_num);
					_snprintf(value[18], sizeof(value[13]), "%.6f", error_iter[k]);
					_snprintf(value[19], sizeof(value[14]), "%.6f", error_weight[k]);
					_snprintf(value[20], sizeof(value[15]), "%.6f", error[k]);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}
				k++;
			}
			if (backmatch_pairs[i].matched_edge_num == 0)
			{
				_snprintf(value[0], sizeof(value[0]), "%d", i);
				_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
				_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
				_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
				_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
				_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
				_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
				_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
				_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
				_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
				_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
				_snprintf(value[11], sizeof(value[7]), "%9.2f", -1.0f);
				_snprintf(value[12], sizeof(value[8]), "%9.2f", -1.0f);
				_snprintf(value[13], sizeof(value[9]), "%9.2f", -1.0f);
				_snprintf(value[14], sizeof(value[9]), "%9.2f", -1.0f);
				_snprintf(value[15], sizeof(value[10]), "%9.2f", -1.0f);
				_snprintf(value[16], sizeof(value[11]), "%9.2f", -1.0f);
				_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting);
				_snprintf(value[18], sizeof(value[13]), "%.6f", -1.0f);
				_snprintf(value[19], sizeof(value[14]), "%.6f", -1.0f);
				_snprintf(value[20], sizeof(value[15]), "%.6f", -1.0f);
				_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
				if (fp)
				{
					for (int k1 = 0; k1 < 22; k1++)
					{
						fprintf(fp, "%s\t", value[k1]);
					}
					fprintf(fp, "\n");
				}
			}
			//if (stAlignExData.uwDebug & 1)
			//{
			//	//if (fp)fprintf(fp, "___________________________________\n");
			//}
			if(mindist < stAlignExData.pstOption->rElasticity+1)
			{
				matched += pstSpA[i].rWeighting;
			}
			sum_weight += pstSpA[i].rWeighting;
		}
		if (stAlignExData.uwDebug & 4)
		{
			IMG_CHAR *p = strrchr(pathname, '\\')-10;
			//HL_CloseTable(m_pHtmlLog);
			if (fp)
			{
				fclose(fp);
				HL_Printf(m_pHtmlLog, "\n");
				HL_InsertObject(m_pHtmlLog, "Backmatchinfo", p);
			}
			HL_Printf(m_pHtmlLog, "\n");
		}
		pstObj->rMatched = matched*100.0f/sum_weight;
		//if (stAlignExData.uwDebug & 1)
		//{
		//	fclose(fp);
		//}
	}

exit:
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Final Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f, matching score = %f\n", 
			pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, pstObj->rLikeScore, pstObj->rMatched);
		writeLog("fittingStatus: %s\n", ippGetStatusString(status));
	}
	return status;
}

IMG_INT CVisAlignSearch::iterationfit_fixangle(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;

	//init var
	IMG_INT i, j, k, m;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	IMG_INT 	num_feat = pstTable->uwNumOfSpAFeature;
	IMG_FEATUREPT *pstSpA = pstTable->pstSpA;
	BACK_MATCH_INFO &backmatch = stAlignExData.backmatch_info;
	BACK_MATCH_PAIR *backmatch_pairs = stAlignExData.backmatch_info.backmatch_pairs;
	IMG_OBJ	*pstObj = stAlignExData.pstObj;
	IMG_LREAL	*prWB = nullptr;//stAlignExData.CharBtir();
	IMG_INT 	num_matchedPoints = backmatch.matched_edge_num;//stAlignExData.Num_matchedPoints();
	IMG_INT 	num_template = stAlignExData.Num_template();
	IMG_INT		eqx, eqy;
	IMG_LREAL 	mse = 0, fitscore = 0, matched, sum_weight;
	IMG_LREAL fitting_sigma;
	IMG_LREAL edget_variance = stAlignExData.pstOption->rElasticity / pow(2, stAlignExData.current_level) + 2;
	IMG_LREAL cose, sine;
	const IMG_UINT	NumOfUnknown = 3;
	FILE *fp = nullptr;
	HTMLLOGGING_TABLE_DATA stTable;
	IMG_CHAR pathname[FILENAME_MAX_LENGTH];


	//begin
	{
		//vars for fitting
		IMG_LREAL lastsum = 0, nowsum = 0;
		IMG_INT iter_t = 0;
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Start Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
				pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);

			IMG_CHAR title[40];
			_snprintf(title, sizeof(title), "Fitting of Obj ID %d", pstObj->uwID);
			HL_InitTableData(&stTable);
			stTable.title = title;
			stTable.tablelinewidth = 0;
			stTable.column = 7;
			stTable.fontweight = FW_Medium;
			stTable.tablealign = TX_CENTER;
			stTable.tablewidth = 50;
			stTable.tablelinewidth = 1;
			stTable.bgColorOddLine = 0x90B0FF;
			stTable.formatstring = "%.6f";
			stTable.datatype = DT_REAL;
			stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
			stTable.heading[0] = "No.";
			stTable.heading[1] = "PosX";
			stTable.heading[2] = "PosY";
			stTable.heading[3] = "Scale";
			stTable.heading[4] = "Rotation";
			stTable.heading[5] = "Fitting Score";
			stTable.heading[6] = "MSE";
			HL_CreateTableHeader(m_pHtmlLog, &stTable);
			
		}

		//var to cal mse and fitScore
		/*
		vector<IMG_REAL> distanceVec;
		for (IMG_INT a = 0; a < num_matchedPoints + 1; a++)
		{
		distanceVec.push_back(pDistanceVecArray[a]);
		}
		*/

		//matrix vars
		IMG_LREAL *error_weight = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error_weight
		for (i = 0, j = 0, k = 0; i < num_feat; i++)
		{
			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			{
				error_weight[k++] = backmatch_pairs[i].origin_feature->rWeighting * (1 / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
			}
		}
		assert(k == backmatch.matched_edge_num);
		//for (i = 0; i < num_matchedPoints; i++)
		//{
		//	error_weight[i] = 1;
		//}


		IMG_LREAL *prB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		// Record "B" in "wAX = wB" and "AX-B"
		memset(prB, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL * Xtemp = (IMG_LREAL *)pool.Malloc(NumOfUnknown * sizeof(IMG_LREAL));		//extract 0~3 elements in prWB
		IMG_LREAL *error = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *error_iter = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error_iter, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *prWA, *prA, *prWABack, *prwBBack;
		prWA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));		//wA
		prA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prWABack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prWB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB
		prwBBack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB

		if (stAlignExData.Bkmode_one2one())
		{
			fitting_sigma = ((edget_variance) / 6.0);
			if (stAlignExData.pstOption->rFittingSigma > 0) fitting_sigma = stAlignExData.pstOption->rFittingSigma;
		}
		else
		{
			fitting_sigma = ((edget_variance /*+ 2.0*/) / 3.0);
		}
		do {
			pool.Push();
			lastsum = nowsum;
			nowsum = 0;
			cose = cos(pstObj->rotation*D2R);
			sine = sin(pstObj->rotation*D2R);

			memset(prWA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prWB, 0, num_matchedPoints * sizeof(IMG_LREAL));


			//if (stAlignExData.Bkmode_one2one())
			//{
			//	fitting_sigma = 0.3;
			//}
			//else
			//{
			//	fitting_sigma = 1+;
			//}
			IMG_UINT feat_class;// = backmatch_pairs[i].origin_feature->ubOutMain;
								//construct "A"
			for (i = 0, k = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prA[k] = cose*backmatch_pairs[i].matched_edge[j].rcoPos.x+sine*backmatch_pairs[i].matched_edge[j].rcoPos.y;
						prA[k + 1] = -cose;
						prA[k + 2] = -sine;
						k = k + NumOfUnknown;
					}
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prA[k] = -sine*backmatch_pairs[i].matched_edge[j].rcoPos.x + cose*backmatch_pairs[i].matched_edge[j].rcoPos.y;
						prA[k + 1] = sine;
						prA[k + 2] = -cose;
						k = k + NumOfUnknown;
					}
				}
			}

			//construct "wA"
			for (i = 0, k = 0, m = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prWA[k] = (cose*backmatch_pairs[i].matched_edge[j].rcoPos.x + sine*backmatch_pairs[i].matched_edge[j].rcoPos.y) * 
									error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 1] = -cose * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 2] = -sine * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						k = k + NumOfUnknown; m++;
					}
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						prWA[k] = (-sine*backmatch_pairs[i].matched_edge[j].rcoPos.x + cose*backmatch_pairs[i].matched_edge[j].rcoPos.y) * 
									error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 1] =  sine * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 2] = -cose * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						k = k + NumOfUnknown; m++;
					}
				}
			}
			memcpy(prWABack, prWA, k * sizeof(IMG_LREAL));

			//construct "B"
			eqx = eqy = 0;
			for (i = 0, j = 0, k = 0; i < num_feat; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					//prB[j] = matchedPointPosMat[i].x;
					for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
					{
						prB[k++] = pstSpA[i].rco.x;
					}
					eqx+=backmatch_pairs[i].matched_edge_num;
				}
				else
				{
					for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
					{
						prB[k++] = pstSpA[i].rco.y;
					}
					eqy+=backmatch_pairs[i].matched_edge_num;
				}
			}
			//construct "wB"
			for (i = 0, j = 0; i < num_feat; i++)
			{
				for (k = 0; k < backmatch_pairs[i].matched_edge_num; k++)
				{
					prWB[j] = prB[j] * error_weight[j] / backmatch_pairs[i].matched_edge_num;
					prwBBack[j] = prWB[j];
					j++;
				}
			}
			if (eqx == 0 || eqy == 0)
			{
				pstObj->rLikeScore = -1;
				pool.Pop();
				if (stAlignExData.uwDebug & 1)
				{
					HL_CloseTable(m_pHtmlLog);
					writeLog("equation x or y lost all points");
				}
				goto exit;
			}
			//for (i = 0; i < backmatch.matched_edge_num; i++)
			//{
			//	prWB[i] = prB[i] * error_weight[i]/ backmatch_pairs[i].matched_edge_num;
			//}

			//fitting X in "wAX = wB"
			LAPACKE_dgels(LAPACK_ROW_MAJOR, 'N', backmatch.matched_edge_num, NumOfUnknown, 1, prWA, NumOfUnknown, prWB, 1);

			Xtemp[0] = prWB[0];
			Xtemp[1] = prWB[1];
			Xtemp[2] = prWB[2];
			Xtemp[3] = prWB[3];

			pstObj->scale = 1 / prWB[0];

			pstObj->rco.x = prWB[1]/prWB[0];
			pstObj->rco.y = prWB[2]/prWB[0];

			cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, backmatch.matched_edge_num, 1, NumOfUnknown, 1, prA, NumOfUnknown, Xtemp, 1, -1, prB, 1);

			//cal error ^ 2
			for (i = 0; i < num_matchedPoints; i++)
			{
				error[i] = prB[i] * prB[i];
				nowsum = error[i] + nowsum;
			}

			//update error_weight
			for (i = 0, k = 0; i < num_feat; i++)
			{
				for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
				{
					//error_iter[k] = 0.5 / (-0.5 + exp((error[k]) / (fitting_sigma*fitting_sigma)));
					error_iter[k] = 1 / (1 - exp(-1 / (fitting_sigma*fitting_sigma)) + exp((error[k] - 1) / (fitting_sigma*fitting_sigma)));
					error_weight[k] = pstSpA[i].rWeighting * (error_iter[k] / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
					k++;
				}
			}
			//for (i = 0; i < num_matchedPoints; i++)
			//{

			//	error_weight[i] = pstSpA[i].ubWeighting * 1.0 / (1 + exp((error[i]) / (fitting_sigma*fitting_sigma)));
			//	//cout << error_weight[i] << endl;
			//}
			//cal fitting score and mse
			IMG_LREAL total_weight, origin_weight, max_weight, sum_weight, min_mse = 0, sum_mse = 0;
			total_weight = 0;
			sum_weight = 0;
			for (i = 0, j = 0, k = 0; i<num_feat; i++)
			{
				total_weight += pstSpA[i].rWeighting;
				max_weight = 0;
				min_mse = 0;
				for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
				{
					if (max_weight < error_iter[k]*pstSpA[i].rWeighting)
					{
						max_weight = error_iter[k]*pstSpA[i].rWeighting;
						min_mse = error[k];
					}
					k++;
				}
				sum_weight += max_weight;
				sum_mse += min_mse;
			}
			fitscore = sum_weight / total_weight;
			mse = sum_mse;
			pstObj->rLikeScore = fitscore;
			pstObj->rMSE = mse;
			if (stAlignExData.uwDebug & 1)
			{
				char value[7][20];
				if (iter_t % 2)		stTable.bgColorOddLine = 0xafffff;
				else			stTable.bgColorOddLine = 0xcfffff;
				_snprintf(value[0], sizeof(value[0]), "%d", iter_t);
				_snprintf(value[1], sizeof(value[1]), "%.3f", pstObj->rco.x);
				_snprintf(value[2], sizeof(value[2]), "%.3f", pstObj->rco.y);
				_snprintf(value[3], sizeof(value[3]), "%.6f", pstObj->scale);
				_snprintf(value[4], sizeof(value[4]), "%.6f", pstObj->rotation);
				_snprintf(value[5], sizeof(value[5]), "%.3f", pstObj->rLikeScore);
				_snprintf(value[6], sizeof(value[6]), "%.3f", pstObj->rMSE);
				HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
				//writeLog("x = %f, y = %f, rotation = %f, scale = %f, fitscore[%d] = %f， mse[%d] = %f\n",
				//	pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, iter_t, fitscore, iter_t, nowsum);
			}

			iter_t++;
			//cout << "迭代次数" << iter_t << endl;
			//cout << "sum:" << nowsum << "  ..." << lastsum << endl;
			pool.Pop();
		} while (abs(nowsum - lastsum) > 0.02 && iter_t <20);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			writeLog("fitting sigma = %f", fitting_sigma);
		}																						//fitting

		Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_pairs);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			HL_Printf(m_pHtmlLog, "\n");
			//
			//fp = fopen("backmatch.txt", "at");
			//if (fp)		fprintf(fp, "--------------Obj ID:%d----------------\n", pstObj->uwID);
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)
			//	{
			//		fprintf(fp, "A/B\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prA[k], prA[k + 1], prA[k + 2], prA[k + 3], prB[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "wA/wB\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prWABack[k], prWABack[k + 1], prWABack[k + 2], prWABack[k + 3], prwBBack[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "\nResult: \n% 12.6f % 12.6f % 12.6f % 12.6f\n", Xtemp[0], Xtemp[1], Xtemp[2], Xtemp[3]);
			//	}
			//}

		}
		//cal matching score
		matched = sum_weight = 0;
		if (stAlignExData.uwDebug & 4 /*&& fp != nullptr*/)
		{
			IMG_CHAR title[80];
			IMG_CHAR *heading[22];
			heading[0] = "FeatID";
			heading[1] = "SrcX";
			heading[2] = "SrcY";
			heading[3] = "SrcAngle";
			heading[4] = "SrcMag";
			heading[5] = "TransXBeforeFit";
			heading[6] = "TransYBeforeFit";
			heading[7] = "TransAngleBeforeFit";
			heading[8] = "TransXAfterFit";
			heading[9] = "TransYAfterFit";
			heading[10] = "TransAngleAfterFit";
			heading[11] = "ImageX";
			heading[12] = "ImageY";
			heading[13] = "ImageAngle";
			heading[14] = "ImageMag";
			heading[15] = "NormalDistBeforeFit";
			heading[16] = "NormalDistAfterFit";
			heading[17] = "Weight/NumOfPt";
			heading[18] = "Error";
			heading[19] = "WeightedError";
			heading[20] = "AXBError";
			heading[21] = "Sigma";
			if (stAlignExData.Bkmode_one2one())
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04dO.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);
			else
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04d.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);

			_snprintf(title, sizeof(title), "Fitting point info of Obj ID %d at level %d\n", pstObj->uwID, stAlignExData.current_level);
			fp = fopen(pathname, "at");
			if (fp)
			{
				fprintf(fp, "%s", title);
				for (i = 0; i < 22; i++)
				{
					fprintf(fp, "%s\t", heading[i]);
				}
				fprintf(fp, "\n");
			}
		}
		for (i = 0, k = 0; i<num_feat; i++)
		{
			IMG_LREAL dist = 1e10, mindist = 1e10;
			IMG_LREAL angle, anglediff;
			char value[22][20];
			for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
			{
				//angle = atan2(backmatch_pairs[i].matched_edge[j].rcoPos.y-backmatch_pairs[i].translated_feat.y, backmatch_pairs[i].matched_edge[j].rcoPos.x-backmatch_pairs[i].translated_feat.x)/D2R;
				//anglediff = pstSpA[i].angle - angle;
				IMG_LRCOORD lrco = { backmatch_pairs[i].matched_edge[j].rcoPos.x, backmatch_pairs[i].matched_edge[j].rcoPos.y };
				dist = FeatEdgeNormalDistance(&lrco, &backmatch_pairs[i].translated_feat, backmatch_pairs[i].translated_feat_angle);
				if (mindist > dist)
					mindist = dist;
				if (stAlignExData.uwDebug & 4)
				{
					if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
					else			stTable.bgColorOddLine = 0xffffcf;
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.x);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.y);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].angle);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].gradient);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", backmatch_pairs[i].matched_normal_distance[j]);
					_snprintf(value[16], sizeof(value[11]), "%.3f", dist);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting / backmatch_pairs[i].matched_edge_num);
					_snprintf(value[18], sizeof(value[13]), "%.6f", error_iter[k]);
					_snprintf(value[19], sizeof(value[14]), "%.6f", error_weight[k]);
					_snprintf(value[20], sizeof(value[15]), "%.6f", error[k]);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}
				k++;
				if (backmatch_pairs[i].matched_edge_num == 0)
				{
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", -1.0f);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", -1.0f);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", -1.0f);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", -1.0f);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", -1.0f);
					_snprintf(value[16], sizeof(value[11]), "%9.2f", -1.0f);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting );
					_snprintf(value[18], sizeof(value[13]), "%.6f", -1.0f);
					_snprintf(value[19], sizeof(value[14]), "%.6f", -1.0f);
					_snprintf(value[20], sizeof(value[15]), "%.6f", -1.0f);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}
			}
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)fprintf(fp, "___________________________________\n");
			//}
			if (mindist < stAlignExData.pstOption->rElasticity + 1)
			{
				matched += pstSpA[i].rWeighting;
			}
			sum_weight += pstSpA[i].rWeighting;
		}
		if (stAlignExData.uwDebug & 4)
		{
			IMG_CHAR *p = strrchr(pathname, '\\')-10;
			//HL_CloseTable(m_pHtmlLog);
			if (fp)
			{
				fclose(fp);
				HL_Printf(m_pHtmlLog, "\n");
				HL_InsertObject(m_pHtmlLog, "Backmatchinfo", p);
			}
			HL_Printf(m_pHtmlLog, "\n");
		}
		pstObj->rMatched = matched*100.0f / sum_weight;
		//if (stAlignExData.uwDebug & 1)
		//{
		//	fclose(fp);
		//}
	}

exit:
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Final Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n", 
			pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);
		writeLog("fittingStatus: %s\n", ippGetStatusString(status));
	}
	return status;
}

IMG_INT CVisAlignSearch::iterationfit_fixscale(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;

	//init var
	IMG_INT i, j, k, m;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	IMG_INT 	num_feat = pstTable->uwNumOfSpAFeature;
	IMG_FEATUREPT *pstSpA = pstTable->pstSpA;
	BACK_MATCH_INFO &backmatch = stAlignExData.backmatch_info;
	BACK_MATCH_PAIR *backmatch_pairs = stAlignExData.backmatch_info.backmatch_pairs;
	IMG_OBJ	*pstObj = stAlignExData.pstObj;
	IMG_LREAL	*prWB = nullptr;//stAlignExData.CharBtir();
	IMG_UINT 	num_matchedPoints = backmatch.matched_edge_num;//stAlignExData.Num_matchedPoints();
	IMG_INT 	num_template = stAlignExData.Num_template();
	IMG_INT		eqx, eqy;
	IMG_LREAL 	scale = stAlignExData.pstObj->scale;
	IMG_LREAL 	mse = 0, fitscore = 0, matched, sum_weight;
	IMG_LREAL fitting_sigma;
	IMG_LREAL edget_variance = stAlignExData.pstOption->rElasticity / pow(2, stAlignExData.current_level) + 2;
	IMG_LREAL cose, sine;
	IMG_REAL angle_feat;

	const IMG_UINT	NumOfUnknown = 3;
	FILE *fp = nullptr;
	HTMLLOGGING_TABLE_DATA stTable;
	IMG_CHAR pathname[FILENAME_MAX_LENGTH];


	//begin
	{
		//vars for fitting
		IMG_LREAL lastsum = 0, nowsum = 0;
		IMG_INT iter_t = 0;
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Start Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
				pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);
			IMG_CHAR title[40];
			_snprintf(title, sizeof(title), "Fitting of Obj ID %d", pstObj->uwID);
			HL_InitTableData(&stTable);
			stTable.title = title;
			stTable.tablelinewidth = 0;
			stTable.column = 7;
			stTable.fontweight = FW_Medium;
			stTable.tablealign = TX_CENTER;
			stTable.tablewidth = 50;
			stTable.tablelinewidth = 1;
			stTable.bgColorOddLine = 0x90B0FF;
			stTable.formatstring = "%.6f";
			stTable.datatype = DT_REAL;
			stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
			stTable.heading[0] = "No.";
			stTable.heading[1] = "PosX";
			stTable.heading[2] = "PosY";
			stTable.heading[3] = "Scale";
			stTable.heading[4] = "Rotation";
			stTable.heading[5] = "Fitting Score";
			stTable.heading[6] = "MSE";
			HL_CreateTableHeader(m_pHtmlLog, &stTable);

		}

		//var to cal mse and fitScore
		/*
		vector<IMG_REAL> distanceVec;
		for (IMG_INT a = 0; a < num_matchedPoints + 1; a++)
		{
		distanceVec.push_back(pDistanceVecArray[a]);
		}
		*/

		//matrix vars
		IMG_LREAL *error_weight = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error_weight
		for (i = 0, j = 0, k = 0; i < num_feat; i++)
		{
			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			{
				error_weight[k++] = backmatch_pairs[i].origin_feature->rWeighting * (1 / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
			}
		}
		assert(k == backmatch.matched_edge_num);
		//for (i = 0; i < num_matchedPoints; i++)
		//{
		//	error_weight[i] = 1;
		//}


		IMG_LREAL *prB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		// Record "B" in "wAX = wB" and "AX-B"
		memset(prB, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL * Xtemp = (IMG_LREAL *)pool.Malloc(NumOfUnknown * sizeof(IMG_LREAL));		//extract 0~3 elements in prWB
		IMG_LREAL *error = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *error_iter = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error_iter, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *prA, *prWeight, *prA2, *prB2;
		//prWA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));		//wA
		prA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prA2 = (IMG_LREAL *)pool.Malloc(num_matchedPoints * 4 * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prB2 = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"

		//prWABack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		//prWB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB
		//prwBBack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB
		prWeight = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));

		if (stAlignExData.Bkmode_one2one())
		{
			fitting_sigma = ((edget_variance) / 6.0);
			if (stAlignExData.pstOption->rFittingSigma > 0) fitting_sigma = stAlignExData.pstOption->rFittingSigma;
		}
		else
		{
			fitting_sigma = ((edget_variance /*+ 2.0*/) / 3.0);
		}
																						//fitting
		do {
			pool.Push();
			lastsum = nowsum;
			nowsum = 0;
			//memset(prWA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			//memset(prWB, 0, num_matchedPoints * sizeof(IMG_LREAL));

			IMG_LREAL newton_iter_err = 1e10;
			IMG_LREAL X0[3], X[3], *w, *p, *q, iter_mse;
			IMG_RCOORD dst, src;
			IMG_LRBUF rbufA, rbufB, rbufW, rbufX;
			IMG_UINT newton_iter = 0, feat_class, quadrant, q0, q1;
			X0[0] = pstObj->rco.x;
			X0[1] = pstObj->rco.y;
			X0[2] = pstObj->rotation*D2R;
			do 
			{
				cose = cos(X0[2]);
				sine = sin(X0[2]);
				rbufA.size = { (IMG_INT)NumOfUnknown, (IMG_INT)num_matchedPoints };
				rbufA.ptr = prA;
				rbufA.linestep = NumOfUnknown;
				rbufB.size = { 1, (IMG_INT)num_matchedPoints };
				rbufB.ptr = prB;
				rbufB.linestep = 1;
				rbufX.ptr = X;
				rbufX.size = { 1, NumOfUnknown };
				rbufX.linestep = 1;
				rbufW.ptr = prWeight;
				rbufW.size = { 1, (IMG_INT)num_matchedPoints };
				rbufW.linestep = 1;

				k = 0;
				p = rbufA.ptr;
				q = rbufB.ptr;
				w = rbufW.ptr;

				q0 = q1 = 0;
				for (i = 0; i < num_template; i++)
				{
					feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
					//if ((X0[2] > -PI / 4 && X0[2] < PI / 4) || (X0[2] > 7 / 4 * PI && X0[2] < 2 * PI) ||
					//	(X0[2]>3*PI/4 && X0[2] < 5*PI/4) || (X0[2]<-3 * PI / 4 && X0[2] > -5 * PI / 4))
					//{
					//	quadrant = 0;
					//}
					//else
					//{
					//	quadrant = 1;
					//}
					angle_feat = backmatch_pairs[i].origin_feature->angle*D2R + X0[2];
					while (angle_feat > 2 * PI) angle_feat -= 2 * PI;
					while (angle_feat < 0)angle_feat += 2 * PI;
					//if ((angle_feat > -PI / 4 && angle_feat < PI / 4) || (angle_feat > 7 * PI / 4 && angle_feat < 2 * PI) ||
					//	(angle_feat > 3 * PI / 4 && angle_feat < 5 * PI / 4) || (angle_feat<-3 * PI / 4 && angle_feat > -5 * PI / 4))
					//if((fabs(cos(angle_feat)) < fabs(sin(angle_feat)) && fabs(cose) > fabs(sine)) || (fabs(cos(angle_feat)) > fabs(sin(angle_feat)) && fabs(cose) < fabs(sine)))
					if(feat_class % 2)
					{
						quadrant = 1;
						q1++;
					}
					else
					{
						quadrant = 0;
						q0++;
					}
					src = backmatch_pairs[i].origin_feature->rco;
					//if ((feat_class % 2 == 0 /*&& quadrant == 0*/) /*|| (feat_class % 2 == 1 && quadrant == 1)*/)
					if (quadrant == 0)
					{
						for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
						{
							dst = backmatch_pairs[i].matched_edge[j].rcoPos;
							p[0] = -cose / scale;
							p[1] = -sine / scale;
							p[2] = -sine*(dst.x - X0[0]) / scale + cose*(dst.y - X0[1]) / scale;
							q[0] = -(-src.x + cose*(dst.x - X0[0]) / scale + sine*(dst.y - X0[1]) / scale);
							w[0] = error_weight[k];// / backmatch_pairs[i].matched_edge_num;
							k++;
							p += rbufA.linestep;
							q += rbufB.linestep;
							w += rbufW.linestep;
						}
					}
					else
					{
						for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
						{
							dst = backmatch_pairs[i].matched_edge[j].rcoPos;
							p[0] = sine / scale;
							p[1] = -cose / scale;
							p[2] = -cose*(dst.x - X0[0]) / scale - sine*(dst.y - X0[1]) / scale;
							q[0] = -(-src.y - sine*(dst.x - X0[0]) / scale + cose*(dst.y - X0[1]) / scale);
							w[0] = error_weight[k];// / backmatch_pairs[i].matched_edge_num;
							k++;
							p += rbufA.linestep;
							q += rbufB.linestep;
							w += rbufW.linestep;
						}
					}
				}
				if (k != num_matchedPoints) THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_SIZE, "k mismatch num_matchedPoints");
				try
				{
					IMG_UWORD debug = 0;
					IMG_CHAR title[80];
					if (stAlignExData.uwDebug & 4) debug = 1;
					_snprintf(title, sizeof(title), "OBJ ID %d MainIter %d, NewtonIter %d", pstObj->uwID, iter_t, newton_iter);
					_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
					VisMath::MATH_SetLogTitle(title);
					VisMath::MATH_SetDebug(debug, pathname);
					VisMath::MATH_SolveAXB(&rbufA, &rbufB, &rbufX, &rbufW, &iter_mse);
					//printf("iter_mse = %f\n", iter_mse);
				}
				catch (CVisException &e)
				{
					//something wrong in fitting;
				}
				if (fabs(X[0]) > 1e4 || fabs(X[1]) > 1e4 || fabs(X[2]) > 1e4)
				{
					if (stAlignExData.uwDebug & 1)
					{
						HL_Printf(m_pHtmlLog, "fitting overflow, exit iteriation\n");
					}
					break;
				}
				X0[0] += X[0];
				X0[1] += X[1];
				X0[2] += X[2];
				//printf("result = %f, %f, %f/ %f, %f, %f\n", X[0], X[1], X[2], X0[0], X0[1], X0[2]);

				newton_iter_err = sqrt(X[0] * X[0] + X[1] * X[1] + X[2] * X[2]) / 3;
				newton_iter++;
				
			} while (newton_iter_err > 1e-6 && newton_iter < 20);
			//printf("iter finish\n");
			pstObj->rotation = X0[2]/D2R;

			pstObj->rco.x = X0[0];
			pstObj->rco.y = X0[1];

			cose = cos(X0[2]);
			sine = sin(X0[2]);

			rbufA.ptr = prA2;
			rbufA.size = { 4, (IMG_INT)num_matchedPoints };
			rbufA.linestep = 4;
			rbufB.ptr = prB2;
			rbufB.size = { 1, (IMG_INT)num_matchedPoints };
			rbufB.linestep = 1;
			k = 0;
			p = rbufA.ptr;
			q = rbufB.ptr;
			w = rbufW.ptr;
			eqx = eqy = 0;
			for (i = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				src = backmatch_pairs[i].origin_feature->rco;
				//if ((X0[2] > -PI / 4 && X0[2] < PI / 4) || (X0[2] > 7 / 4 * PI && X0[2] < 2 * PI) ||
				//	(X0[2] > 3 * PI / 4 && X0[2] < 5 * PI / 4) || (X0[2]<-3 * PI / 4 && X0[2] > -5 * PI / 4))
				//{
				//	quadrant = 0;
				//}
				//else
				//{
				//	quadrant = 1;
				//}
				angle_feat = backmatch_pairs[i].origin_feature->angle*D2R + X0[2];
				while (angle_feat > 2 * PI) angle_feat -= 2 * PI;
				while (angle_feat < 0)angle_feat += 2 * PI;
				//if ((angle_feat > -PI / 4 && angle_feat < PI / 4) || (angle_feat > 7 / 4 * PI && angle_feat < 2 * PI) ||
				//	(angle_feat > 3 * PI / 4 && angle_feat < 5 * PI / 4) || (angle_feat<-3 * PI / 4 && angle_feat > -5 * PI / 4))
				if(feat_class % 2 == 0)
				{
					quadrant = 0;
				}
				else
				{
					quadrant = 1;
				}
				//if ((feat_class % 2 == 0 && quadrant == 0) || (feat_class % 2 == 1 && quadrant == 1))
				if(quadrant == 0)
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
					{
						dst = backmatch_pairs[i].matched_edge[j].rcoPos;
						w[0] = 1;// backmatch_pairs[i].origin_feature->rWeighting / backmatch_pairs[i].matched_edge_num;
						p[0] = scale*src.x*w[0];
						p[1] = -scale*src.y*w[0];
						p[2] = 1 * w[0];
						p[3] = 0 * w[0];
						q[0] = dst.x*w[0];
						k++;
						p += rbufA.linestep;
						q += rbufB.linestep;
						w += rbufW.linestep;
					}
					eqx+=backmatch_pairs[i].matched_edge_num;
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
					{
						dst = backmatch_pairs[i].matched_edge[j].rcoPos;
						w[0] = 1;// backmatch_pairs[i].origin_feature->rWeighting / backmatch_pairs[i].matched_edge_num;
						p[0] = scale*src.y*w[0];
						p[1] = scale*src.x*w[0];
						p[2] = 0 * w[0];
						p[3] = 1 * w[0];
						q[0] = dst.y*w[0];
						k++;
						p += rbufA.linestep;
						q += rbufB.linestep;
						w += rbufW.linestep;
					}
					eqy+=backmatch_pairs[i].matched_edge_num;
				}
			}
			if (eqx == 0 || eqy == 0)
			{
				pstObj->rLikeScore = -1;
				pool.Pop();
				if (stAlignExData.uwDebug & 1)
				{
					HL_CloseTable(m_pHtmlLog);
					writeLog("equation x or y lost all points");
				}
				goto exit;
			}
			Xtemp[0] = cose;
			Xtemp[1] = sine;
			Xtemp[2] = X0[0];
			Xtemp[3] = X0[1];
			cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, backmatch.matched_edge_num, 1, 4, 1, prA2, 4, Xtemp, 1, -1, prB2, 1);

			//cal error ^ 2
			for (i = 0, k = 0; i < num_feat; i++)
			{
				IMG_LREAL min_err = 1e10;
				for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++, k++)
				{
					error[k] = prB2[k] * prB2[k];
					nowsum += error[k];
				}
			}
			if (k != num_matchedPoints) THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_SIZE, "k mismatch num_matchedPoints");


			//update error_weight
			for (i = 0, k = 0; i < num_feat; i++)
			{
				for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
				{
					//error_iter[k] = (1+exp(-1/fitting_sigma/fitting_sigma)) / (1 + exp((error[k]-1) / (fitting_sigma*fitting_sigma)));
					error_iter[k] = 1 / (1 - exp(-1 / (fitting_sigma*fitting_sigma)) + exp((error[k] - 1) / (fitting_sigma*fitting_sigma)));
					error_weight[k] = pstSpA[i].rWeighting * (error_iter[k] / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
					k++;
				}
			}
			//for (i = 0; i < num_matchedPoints; i++)
			//{

			//	error_weight[i] = pstSpA[i].ubWeighting * 1.0 / (1 + exp((error[i]) / (fitting_sigma*fitting_sigma)));
			//	//cout << error_weight[i] << endl;
			//}
			//cal fitting score and mse
			IMG_LREAL total_weight, origin_weight, max_weight, sum_weight, min_mse = 0, sum_mse = 0;
			total_weight = 0;
			sum_weight = 0;
			for (i = 0, j = 0, k = 0; i<num_feat; i++)
			{
				total_weight += pstSpA[i].rWeighting;
				max_weight = 0;
				min_mse = 0;
				for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
				{
					if (max_weight < error_iter[k]*pstSpA[i].rWeighting)
					{
						max_weight = error_iter[k]*pstSpA[i].rWeighting;
						min_mse = error[k];
					}
					k++;
				}
				sum_weight += max_weight;
				sum_mse += min_mse;
			}
			fitscore = sum_weight / total_weight;
			mse = sum_mse;
			pstObj->rLikeScore = fitscore;
			pstObj->rMSE = mse;
			if (stAlignExData.uwDebug & 1)
			{
				char value[7][20];
				if (iter_t % 2)		stTable.bgColorOddLine = 0xafffff;
				else			stTable.bgColorOddLine = 0xcfffff;
				_snprintf(value[0], sizeof(value[0]), "%d", iter_t);
				_snprintf(value[1], sizeof(value[1]), "%.3f", pstObj->rco.x);
				_snprintf(value[2], sizeof(value[2]), "%.3f", pstObj->rco.y);
				_snprintf(value[3], sizeof(value[3]), "%.6f", pstObj->scale);
				_snprintf(value[4], sizeof(value[4]), "%.6f", pstObj->rotation);
				_snprintf(value[5], sizeof(value[5]), "%.3f", pstObj->rLikeScore);
				_snprintf(value[6], sizeof(value[6]), "%.3f", pstObj->rMSE);
				HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
				//writeLog("x = %f, y = %f, rotation = %f, scale = %f, fitscore[%d] = %f， mse[%d] = %f\n",
				//	pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, iter_t, fitscore, iter_t, nowsum);
			}

			iter_t++;
			//cout << "迭代次数" << iter_t << endl;
			//cout << "sum:" << nowsum << "  ..." << lastsum << endl;
			pool.Pop();
		} while (abs(nowsum - lastsum) > 0.02 && iter_t <20);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			writeLog("fitting sigma = %f", fitting_sigma);
		}

		Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_pairs);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			HL_Printf(m_pHtmlLog, "\n");
			//
			//fp = fopen("backmatch.txt", "at");
			//if (fp)		fprintf(fp, "--------------Obj ID:%d----------------\n", pstObj->uwID);
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)
			//	{
			//		fprintf(fp, "A/B\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prA[k], prA[k + 1], prA[k + 2], prA[k + 3], prB[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "wA/wB\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prWABack[k], prWABack[k + 1], prWABack[k + 2], prWABack[k + 3], prwBBack[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "\nResult: \n% 12.6f % 12.6f % 12.6f % 12.6f\n", Xtemp[0], Xtemp[1], Xtemp[2], Xtemp[3]);
			//	}
			//}

		}
		//cal matching score
		matched = sum_weight = 0;
		if (stAlignExData.uwDebug & 4 /*&& fp != nullptr*/)
		{
			IMG_CHAR title[80];
			IMG_CHAR *heading[22];
			heading[0] = "FeatID";
			heading[1] = "SrcX";
			heading[2] = "SrcY";
			heading[3] = "SrcAngle";
			heading[4] = "SrcMag";
			heading[5] = "TransXBeforeFit";
			heading[6] = "TransYBeforeFit";
			heading[7] = "TransAngleBeforeFit";
			heading[8] = "TransXAfterFit";
			heading[9] = "TransYAfterFit";
			heading[10] = "TransAngleAfterFit";
			heading[11] = "ImageX";
			heading[12] = "ImageY";
			heading[13] = "ImageAngle";
			heading[14] = "ImageMag";
			heading[15] = "NormalDistBeforeFit";
			heading[16] = "NormalDistAfterFit";
			heading[17] = "Weight/NumOfPt";
			heading[18] = "Error";
			heading[19] = "WeightedError";
			heading[20] = "AXBError";
			heading[21] = "Sigma";
			if (stAlignExData.Bkmode_one2one())
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04dO.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);
			else
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04d.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);

			_snprintf(title, sizeof(title), "Fitting point info of Obj ID %d at level %d\n", pstObj->uwID, stAlignExData.current_level);
			fp = fopen(pathname, "at");
			if (fp)
			{
				fprintf(fp, "%s", title);
				for (i = 0; i < 22; i++)
				{
					fprintf(fp, "%s\t", heading[i]);
				}
				fprintf(fp, "\n");
			}
		}
		for (i = 0, k = 0; i<num_feat; i++)
		{
			IMG_LREAL dist = 1e10, mindist = 1e10;
			IMG_LREAL angle, anglediff;
			char value[22][20];

			for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
			{
				//angle = atan2(backmatch_pairs[i].matched_edge[j].rcoPos.y-backmatch_pairs[i].translated_feat.y, backmatch_pairs[i].matched_edge[j].rcoPos.x-backmatch_pairs[i].translated_feat.x)/D2R;
				//anglediff = pstSpA[i].angle - angle;
				IMG_LRCOORD lrco = { backmatch_pairs[i].matched_edge[j].rcoPos.x, backmatch_pairs[i].matched_edge[j].rcoPos.y };
				dist = FeatEdgeNormalDistance(&lrco, &backmatch_pairs[i].translated_feat, backmatch_pairs[i].translated_feat_angle);
				if (mindist > dist)
					mindist = dist;
				if (stAlignExData.uwDebug & 4)
				{
					if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
					else			stTable.bgColorOddLine = 0xffffcf;
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.x);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.y);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].angle);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].gradient);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", backmatch_pairs[i].matched_normal_distance[j]);
					_snprintf(value[16], sizeof(value[11]), "%.3f", dist);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting / backmatch_pairs[i].matched_edge_num);
					_snprintf(value[18], sizeof(value[13]), "%.6f", error_iter[k]);
					_snprintf(value[19], sizeof(value[14]), "%.6f", error_weight[k]);
					_snprintf(value[20], sizeof(value[15]), "%.6f", error[k]);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}
				k++;
				if (backmatch_pairs[i].matched_edge_num == 0)
				{
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", -1.0f);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", -1.0f);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", -1.0f);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", -1.0f);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", -1.0f);
					_snprintf(value[16], sizeof(value[11]), "%9.2f", -1.0f);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting );
					_snprintf(value[18], sizeof(value[13]), "%.6f", -1.0f);
					_snprintf(value[19], sizeof(value[14]), "%.6f", -1.0f);
					_snprintf(value[20], sizeof(value[15]), "%.6f", -1.0f);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}
			}
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)fprintf(fp, "___________________________________\n");
			//}
			if (mindist < stAlignExData.pstOption->rElasticity + 1)
			{
				matched += pstSpA[i].rWeighting;
			}
			sum_weight += pstSpA[i].rWeighting;
		}
		if (stAlignExData.uwDebug & 4)
		{
			IMG_CHAR *p = strrchr(pathname, '\\')-10;
			//HL_CloseTable(m_pHtmlLog);
			if (fp)
			{
				fclose(fp);
				HL_Printf(m_pHtmlLog, "\n");
				HL_InsertObject(m_pHtmlLog, "Backmatchinfo", p);
			}
			HL_Printf(m_pHtmlLog, "\n");
		}
		pstObj->rMatched = matched*100.0f / sum_weight;
		//if (stAlignExData.uwDebug & 1)
		//{
		//	fclose(fp);
		//}
	}

exit:
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Final Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
			pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);
		writeLog("fittingStatus: %s\n", ippGetStatusString(status));
	}
	return status;
}

IMG_INT CVisAlignSearch::iterationfit_fixanglescale(CVisAlignSearchInterData &stAlignExData)
{
	CVisMemPool pool;
	IppStatus status = ippStsNoErr;

	//init var
	IMG_INT i, j, k, m;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	IMG_INT 	num_feat = pstTable->uwNumOfSpAFeature;
	IMG_FEATUREPT *pstSpA = pstTable->pstSpA;
	BACK_MATCH_INFO &backmatch = stAlignExData.backmatch_info;
	BACK_MATCH_PAIR *backmatch_pairs = stAlignExData.backmatch_info.backmatch_pairs;
	IMG_OBJ	*pstObj = stAlignExData.pstObj;
	IMG_LREAL	*prWB = nullptr;//stAlignExData.CharBtir();
	IMG_INT 	num_matchedPoints = backmatch.matched_edge_num;//stAlignExData.Num_matchedPoints();
	IMG_INT 	num_template = stAlignExData.Num_template();
	IMG_INT		eqx, eqy;
	IMG_LREAL 	mse = 0, fitscore = 0, matched, sum_weight;
	IMG_LREAL fitting_sigma;
	IMG_LREAL edget_variance = stAlignExData.pstOption->rElasticity / pow(2, stAlignExData.current_level) + 2;
	IMG_LREAL cose, sine;
	IMG_LREAL scale = pstObj->scale;
	const IMG_UINT	NumOfUnknown = 2;
	FILE *fp = nullptr;
	HTMLLOGGING_TABLE_DATA stTable;
	IMG_CHAR pathname[FILENAME_MAX_LENGTH];


	//begin
	{
		//vars for fitting
		IMG_LREAL lastsum = 0, nowsum = 0;
		IMG_INT iter_t = 0;
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("Start Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
				pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);

			IMG_CHAR title[40];
			_snprintf(title, sizeof(title), "Fitting of Obj ID %d", pstObj->uwID);
			HL_InitTableData(&stTable);
			stTable.title = title;
			stTable.tablelinewidth = 0;
			stTable.column = 7;
			stTable.fontweight = FW_Medium;
			stTable.tablealign = TX_CENTER;
			stTable.tablewidth = 50;
			stTable.tablelinewidth = 1;
			stTable.bgColorOddLine = 0x90B0FF;
			stTable.formatstring = "%.6f";
			stTable.datatype = DT_REAL;
			stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
			stTable.heading[0] = "No.";
			stTable.heading[1] = "PosX";
			stTable.heading[2] = "PosY";
			stTable.heading[3] = "Scale";
			stTable.heading[4] = "Rotation";
			stTable.heading[5] = "Fitting Score";
			stTable.heading[6] = "MSE";
			HL_CreateTableHeader(m_pHtmlLog, &stTable);

		}

		//var to cal mse and fitScore
		/*
		vector<IMG_REAL> distanceVec;
		for (IMG_INT a = 0; a < num_matchedPoints + 1; a++)
		{
		distanceVec.push_back(pDistanceVecArray[a]);
		}
		*/

		//matrix vars
		IMG_LREAL *error_weight = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error_weight
		for (i = 0, j = 0, k = 0; i < num_feat; i++)
		{
			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			{
				error_weight[k++] = backmatch_pairs[i].origin_feature->rWeighting * (1 / sqrt(backmatch_pairs[i].matched_edge_num)*0.9 + 0.1);
			}
		}
		assert(k == backmatch.matched_edge_num);
		//for (i = 0; i < num_matchedPoints; i++)
		//{
		//	error_weight[i] = 1;
		//}


		IMG_LREAL *prB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		// Record "B" in "wAX = wB" and "AX-B"
		memset(prB, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL * Xtemp = (IMG_LREAL *)pool.Malloc(NumOfUnknown * sizeof(IMG_LREAL));		//extract 0~3 elements in prWB
		IMG_LREAL *error = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *error_iter = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));	//error = AX - B
		memset(error_iter, 0, num_matchedPoints * sizeof(IMG_LREAL));
		IMG_LREAL *prWA, *prA, *prWABack, *prwBBack;
		prWA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));		//wA
		prA = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prWABack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));	//Record "A" in "wAX = wB"
		prWB = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB
		prwBBack = (IMG_LREAL *)pool.Malloc(num_matchedPoints * sizeof(IMG_LREAL));		//wB

		if (stAlignExData.Bkmode_one2one())
		{
			fitting_sigma = ((edget_variance) / 6.0);
			if (stAlignExData.pstOption->rFittingSigma > 0) fitting_sigma = stAlignExData.pstOption->rFittingSigma;
		}
		else
		{
			fitting_sigma = ((edget_variance /*+ 2.0*/) / 3.0);
		}

																						//fitting
		do {
			pool.Push();
			lastsum = nowsum;
			nowsum = 0;
			cose = cos(pstObj->rotation*D2R);
			sine = sin(pstObj->rotation*D2R);

			memset(prWA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prA, 0, num_matchedPoints * NumOfUnknown * sizeof(IMG_LREAL));
			memset(prWB, 0, num_matchedPoints * sizeof(IMG_LREAL));

			//if (stAlignExData.Bkmode_one2one())
			//{
			//	fitting_sigma = 0.3;
			//}
			//else
			//{
			//	fitting_sigma = 1+;
			//}
			IMG_UINT feat_class;// = backmatch_pairs[i].origin_feature->ubOutMain;
								//construct "A"
			for (i = 0, k = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						//prA[k] = cose*backmatch_pairs[i].matched_edge[j].rcoPos.x + sine*backmatch_pairs[i].matched_edge[j].rcoPos.y;
						prA[k + 0] = -cose;
						prA[k + 1] = -sine;
						k = k + NumOfUnknown;
					}
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						//prA[k] = -sine*backmatch_pairs[i].matched_edge[j].rcoPos.x + cose*backmatch_pairs[i].matched_edge[j].rcoPos.y;
						prA[k + 0] = sine;
						prA[k + 1] = -cose;
						k = k + NumOfUnknown;
					}
				}
			}

			//construct "wA"
			for (i = 0, k = 0, m = 0; i < num_template; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						//prWA[k] = (cose*backmatch_pairs[i].matched_edge[j].rcoPos.x + sine*backmatch_pairs[i].matched_edge[j].rcoPos.y) *
						//	error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 0] = -cose * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 1] = -sine * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						k = k + NumOfUnknown; m++;
					}
				}
				else
				{
					for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)//times
					{
						//prWA[k] = (-sine*backmatch_pairs[i].matched_edge[j].rcoPos.x + cose*backmatch_pairs[i].matched_edge[j].rcoPos.y) *
						//	error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 0] = sine * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						prWA[k + 1] = -cose * error_weight[m] / backmatch_pairs[i].matched_edge_num;
						k = k + NumOfUnknown; m++;
					}
				}
			}
			memcpy(prWABack, prWA, k * sizeof(IMG_LREAL));

			//construct "B"
			eqx = eqy = 0;
			for (i = 0, j = 0, k = 0; i < num_feat; i++)
			{
				feat_class = backmatch_pairs[i].origin_feature->ubOutMain;
				if (feat_class % 2 == 0)
				{
					//prB[j] = matchedPointPosMat[i].x;
					for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
					{
						prB[k++] = pstSpA[i].rco.x*scale - cose*backmatch_pairs[i].matched_edge[j].rcoPos.x - sine*backmatch_pairs[i].matched_edge[j].rcoPos.y;
					}
					eqx+=backmatch_pairs[i].matched_edge_num;
				}
				else
				{
					for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
					{
						prB[k++] = pstSpA[i].rco.y*scale + sine*backmatch_pairs[i].matched_edge[j].rcoPos.x - cose*backmatch_pairs[i].matched_edge[j].rcoPos.y;
					}
					eqy+=backmatch_pairs[i].matched_edge_num;
				}
			}
			//construct "wB"
			for (i = 0, j = 0; i < num_feat; i++)
			{
				for (k = 0; k < backmatch_pairs[i].matched_edge_num; k++)
				{
					prWB[j] = prB[j] * error_weight[j] / backmatch_pairs[i].matched_edge_num;
					prwBBack[j] = prWB[j];
					j++;
				}
			}
			if (eqx == 0 || eqy == 0)
			{
				pstObj->rLikeScore = -1;
				if (stAlignExData.uwDebug & 1)
				{
					HL_CloseTable(m_pHtmlLog);
					writeLog("equation x or y lost all points");
				}
				pool.Pop();
				goto exit;
			}
			//for (i = 0; i < backmatch.matched_edge_num; i++)
			//{
			//	prWB[i] = prB[i] * error_weight[i]/ backmatch_pairs[i].matched_edge_num;
			//}

			//fitting X in "wAX = wB"
			LAPACKE_dgels(LAPACK_ROW_MAJOR, 'N', backmatch.matched_edge_num, NumOfUnknown, 1, prWA, NumOfUnknown, prWB, 1);

			Xtemp[0] = prWB[0];
			Xtemp[1] = prWB[1];

			pstObj->rco.x = prWB[0];
			pstObj->rco.y = prWB[1];

			cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, backmatch.matched_edge_num, 1, NumOfUnknown, 1, prA, NumOfUnknown, Xtemp, 1, -1, prB, 1);

			//cal error ^ 2
			for (i = 0; i < num_matchedPoints; i++)
			{
				error[i] = prB[i] * prB[i];
				nowsum = error[i] + nowsum;
			}

			//update error_weight
			for (i = 0, k = 0; i < num_feat; i++)
			{
				for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
				{
					//error_iter[k] = 0.5 / (-0.5 + exp((error[k]) / (fitting_sigma*fitting_sigma)));
					error_iter[k] = 1 / (1 - exp(-1 / (fitting_sigma*fitting_sigma)) + exp((error[k] - 1) / (fitting_sigma*fitting_sigma)));
					error_weight[k] = pstSpA[i].rWeighting * (error_iter[k] / sqrt(backmatch_pairs[i].matched_edge_num)*0.9+0.1);
					k++;
				}
			}
			//for (i = 0; i < num_matchedPoints; i++)
			//{

			//	error_weight[i] = pstSpA[i].ubWeighting * 1.0 / (1 + exp((error[i]) / (fitting_sigma*fitting_sigma)));
			//	//cout << error_weight[i] << endl;
			//}
			//cal fitting score and mse
			IMG_LREAL total_weight, origin_weight, max_weight, sum_weight, min_mse = 0, sum_mse = 0;
			total_weight = 0;
			sum_weight = 0;
			for (i = 0, j = 0, k = 0; i<num_feat; i++)
			{
				total_weight += pstSpA[i].rWeighting;
				max_weight = 0;
				min_mse = 0;
				for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
				{
					if (max_weight < error_iter[k]*pstSpA[i].rWeighting)
					{
						max_weight = error_iter[k]*pstSpA[i].rWeighting;
						min_mse = error[k];
					}
					k++;
				}
				sum_weight += max_weight;
				sum_mse += min_mse;
			}
			fitscore = sum_weight / total_weight;
			mse = sum_mse;
			pstObj->rLikeScore = fitscore;
			pstObj->rMSE = mse;

			if (stAlignExData.uwDebug & 1)
			{
				char value[7][20];
				if (iter_t % 2)		stTable.bgColorOddLine = 0xafffff;
				else			stTable.bgColorOddLine = 0xcfffff;
				_snprintf(value[0], sizeof(value[0]), "%d", iter_t);
				_snprintf(value[1], sizeof(value[1]), "%.3f", pstObj->rco.x);
				_snprintf(value[2], sizeof(value[2]), "%.3f", pstObj->rco.y);
				_snprintf(value[3], sizeof(value[3]), "%.6f", pstObj->scale);
				_snprintf(value[4], sizeof(value[4]), "%.6f", pstObj->rotation);
				_snprintf(value[5], sizeof(value[5]), "%.3f", pstObj->rLikeScore);
				_snprintf(value[6], sizeof(value[6]), "%.3f", pstObj->rMSE);
				HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
				//writeLog("x = %f, y = %f, rotation = %f, scale = %f, fitscore[%d] = %f， mse[%d] = %f\n",
				//	pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, iter_t, fitscore, iter_t, nowsum);
			}

			iter_t++;
			//cout << "迭代次数" << iter_t << endl;
			//cout << "sum:" << nowsum << "  ..." << lastsum << endl;
			pool.Pop();
		} while (abs(nowsum - lastsum) > 0.02 && iter_t <20);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			writeLog("fitting sigma = %f", fitting_sigma);
		}
		Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_pairs);
		if (stAlignExData.uwDebug & 1)
		{
			HL_CloseTable(m_pHtmlLog);
			HL_Printf(m_pHtmlLog, "\n");
			//
			//fp = fopen("backmatch.txt", "at");
			//if (fp)		fprintf(fp, "--------------Obj ID:%d----------------\n", pstObj->uwID);
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)
			//	{
			//		fprintf(fp, "A/B\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prA[k], prA[k + 1], prA[k + 2], prA[k + 3], prB[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "wA/wB\n");
			//		for (i = 0, k = 0; i < num_template; i++)
			//		{
			//			for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
			//			{
			//				fprintf(fp, "% 12.6f % 12.6f % 12.6f % 12.6f     % 12.6f\n", prWABack[k], prWABack[k + 1], prWABack[k + 2], prWABack[k + 3], prwBBack[k >> 2]);
			//				k += NumOfUnknown;
			//			}
			//		}
			//		fprintf(fp, "\nResult: \n% 12.6f % 12.6f % 12.6f % 12.6f\n", Xtemp[0], Xtemp[1], Xtemp[2], Xtemp[3]);
			//	}
			//}

		}
		//cal matching score
		matched = sum_weight = 0;
		if (stAlignExData.uwDebug & 4 /*&& fp != nullptr*/)
		{
			IMG_CHAR title[80];
			IMG_CHAR *heading[22];
			heading[0] = "FeatID";
			heading[1] = "SrcX";
			heading[2] = "SrcY";
			heading[3] = "SrcAngle";
			heading[4] = "SrcMag";
			heading[5] = "TransXBeforeFit";
			heading[6] = "TransYBeforeFit";
			heading[7] = "TransAngleBeforeFit";
			heading[8] = "TransXAfterFit";
			heading[9] = "TransYAfterFit";
			heading[10] = "TransAngleAfterFit";
			heading[11] = "ImageX";
			heading[12] = "ImageY";
			heading[13] = "ImageAngle";
			heading[14] = "ImageMag";
			heading[15] = "NormalDistBeforeFit";
			heading[16] = "NormalDistAfterFit";
			heading[17] = "Weight/NumOfPt";
			heading[18] = "Error";
			heading[19] = "WeightedError";
			heading[20] = "AXBError";
			heading[21] = "Sigma";
			if (stAlignExData.Bkmode_one2one())
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04dO.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);
			else
				_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04d.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);

			_snprintf(title, sizeof(title), "Fitting point info of Obj ID %d at level %d\n", pstObj->uwID, stAlignExData.current_level);
			fp = fopen(pathname, "at");
			if (fp)
			{
				fprintf(fp, "%s", title);
				for (i = 0; i < 22; i++)
				{
					fprintf(fp, "%s\t", heading[i]);
				}
				fprintf(fp, "\n");
			}
		}
		for (i = 0, k = 0; i<num_feat; i++)
		{
			IMG_LREAL dist = 1e10, mindist = 1e10;
			IMG_LREAL angle, anglediff;
			char value[22][20];
			for (j = 0; j<backmatch_pairs[i].matched_edge_num; j++)
			{
				//angle = atan2(backmatch_pairs[i].matched_edge[j].rcoPos.y-backmatch_pairs[i].translated_feat.y, backmatch_pairs[i].matched_edge[j].rcoPos.x-backmatch_pairs[i].translated_feat.x)/D2R;
				//anglediff = pstSpA[i].angle - angle;
				IMG_LRCOORD lrco = { backmatch_pairs[i].matched_edge[j].rcoPos.x, backmatch_pairs[i].matched_edge[j].rcoPos.y };
				dist = FeatEdgeNormalDistance(&lrco, &backmatch_pairs[i].translated_feat, backmatch_pairs[i].translated_feat_angle);
				if (mindist > dist)
					mindist = dist;
				if (stAlignExData.uwDebug & 4)
				{
					if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
					else			stTable.bgColorOddLine = 0xffffcf;
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.x);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.y);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].angle);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].gradient);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", backmatch_pairs[i].matched_normal_distance[j]);
					_snprintf(value[16], sizeof(value[11]), "%.3f", dist);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting / backmatch_pairs[i].matched_edge_num);
					_snprintf(value[18], sizeof(value[13]), "%.6f", error_iter[k]);
					_snprintf(value[19], sizeof(value[14]), "%.6f", error_weight[k]);
					_snprintf(value[20], sizeof(value[15]), "%.6f", error[k]);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}
				k++;
				if (backmatch_pairs[i].matched_edge_num == 0)
				{
					_snprintf(value[0], sizeof(value[0]), "%d", i);
					_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[i].rco.x);
					_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[i].rco.y);
					_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[i].angle);
					_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[i].uwEdgeMag);
					_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.x);
					_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_before_fitting.y);
					_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle_before_fitting);
					_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[i].translated_feat.x);
					_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat.y);
					_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[i].translated_feat_angle);
					_snprintf(value[11], sizeof(value[7]), "%9.2f", -1.0f);
					_snprintf(value[12], sizeof(value[8]), "%9.2f", -1.0f);
					_snprintf(value[13], sizeof(value[9]), "%9.2f", -1.0f);
					_snprintf(value[14], sizeof(value[9]), "%9.2f", -1.0f);
					_snprintf(value[15], sizeof(value[10]), "%9.2f", -1.0f);
					_snprintf(value[16], sizeof(value[11]), "%9.2f", -1.0f);
					_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting );
					_snprintf(value[18], sizeof(value[13]), "%.6f", -1.0f);
					_snprintf(value[19], sizeof(value[14]), "%.6f", -1.0f);
					_snprintf(value[20], sizeof(value[15]), "%.6f", -1.0f);
					_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
					if (fp)
					{
						for (int k1 = 0; k1 < 22; k1++)
						{
							fprintf(fp, "%s\t", value[k1]);
						}
						fprintf(fp, "\n");
					}
				}

			}
			//if (stAlignExData.uwDebug & 1)
			//{
			//	if (fp)fprintf(fp, "___________________________________\n");
			//}
			if (mindist < stAlignExData.pstOption->rElasticity + 1)
			{
				matched += pstSpA[i].rWeighting;
			}
			sum_weight += pstSpA[i].rWeighting;
		}
		if (stAlignExData.uwDebug & 4)
		{
			IMG_CHAR *p = strrchr(pathname, '\\')-10;
			//HL_CloseTable(m_pHtmlLog);
			if (fp)
			{
				fclose(fp);
				HL_Printf(m_pHtmlLog, "\n");
				HL_InsertObject(m_pHtmlLog, "Backmatchinfo", p);
			}
			HL_Printf(m_pHtmlLog, "\n");
		}
		pstObj->rMatched = matched*100.0f / sum_weight;
		//if (stAlignExData.uwDebug & 1)
		//{
		//	fclose(fp);
		//}
	}

exit:
	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Final Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
			pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);
		writeLog("fittingStatus: %s\n", ippGetStatusString(status));
	}
	return status;
}

IMG_INT CVisAlignSearch::iterationfit_ellipse(CVisAlignSearchInterData &stAlignExData)
{
	IMG_INT i, j, k;
	CVisMemPool pool;
	IMG_RCOORD *point;
	CVisAlignRecordTable	*pstTable = stAlignExData.pstTable;
	IMG_INT 	num_feat = pstTable->uwNumOfSpAFeature;
	IMG_FEATUREPT *pstSpA = pstTable->pstSpA;
	BACK_MATCH_INFO &backmatch = stAlignExData.backmatch_info;
	BACK_MATCH_PAIR *backmatch_pairs = stAlignExData.backmatch_info.backmatch_pairs;
	IMG_OBJ	*pstObj = stAlignExData.pstObj, initobj = *pstObj;
	IMG_ELLIPSE ellipse, init;
	FILE *fp = nullptr;
	HTMLLOGGING_TABLE_DATA stTable;
	IMG_CHAR pathname[FILENAME_MAX_LENGTH];
	IMG_LREAL 	mse = 0, fitscore = 0, matched, sum_weight;
	IMG_REAL *weight;
	IMG_LREAL *pMSE;
	MATH_FITPARA para;
	IMG_REAL original_angle = pstObj->rotation, fit_angle;
	IMG_INT angle_offset;
	IMG_REAL rMaxV = 0, rMinV = 1e9;

	if (stAlignExData.uwDebug & 1)
	{
		writeLog("Start Obj ID %d: x = %f, y = %f, rotation = %f, scale = %f, fitscore = %f\n",
			pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, fitscore);

		IMG_CHAR title[40];
		_snprintf(title, sizeof(title), "Fitting of Obj ID %d", pstObj->uwID);
		HL_InitTableData(&stTable);
		stTable.title = title;
		stTable.tablelinewidth = 0;
		stTable.column = 7;
		stTable.fontweight = FW_Medium;
		stTable.tablealign = TX_CENTER;
		stTable.tablewidth = 50;
		stTable.tablelinewidth = 1;
		stTable.bgColorOddLine = 0x90B0FF;
		stTable.formatstring = "%.6f";
		stTable.datatype = DT_REAL;
		stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
		stTable.heading[0] = "No.";
		stTable.heading[1] = "PosX";
		stTable.heading[2] = "PosY";
		stTable.heading[3] = "Scale";
		stTable.heading[4] = "Rotation";
		stTable.heading[5] = "Fitting Score";
		stTable.heading[6] = "MSE";
		HL_CreateTableHeader(m_pHtmlLog, &stTable);

	}
	if (stAlignExData.pstOption->rFittingSigma < 0)
		para.fitting_sigma = stAlignExData.pstOption->rElasticity+2;
	else
		para.fitting_sigma = stAlignExData.pstOption->rFittingSigma;
	para.iteration = 10;
	para.ransac_num = 0;
	point = (IMG_RCOORD *)pool.Malloc(backmatch.matched_edge_num*sizeof(IMG_RCOORD));
	VALIDATE_MALLOC(point);
	weight = (IMG_REAL *)pool.Malloc(backmatch.matched_edge_num * sizeof(IMG_REAL));
	VALIDATE_MALLOC(weight);
	pMSE = (IMG_LREAL *)pool.Malloc(backmatch.matched_edge_num * sizeof(IMG_LREAL));
	VALIDATE_MALLOC(pMSE);

	for (i = 0, k=0; i < backmatch.matched_pair_num; i++)
	{
		for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
		{
			point[k] = backmatch_pairs[i].matched_edge[j].rcoPos;
			weight[k] = 1.0f / backmatch_pairs[i].matched_edge_num;
			k++;
		}
	}
	for (i = 0; i < pstTable->uwNumOfSpAFeature; i++)
	{
		IMG_REAL rV = sqrt(pstTable->pstSpA[i].rco.x*pstTable->pstSpA[i].rco.x + pstTable->pstSpA[i].rco.y*pstTable->pstSpA[i].rco.y);
		if (rV < rMinV)rMinV = rV;
		if (rV > rMaxV)rMaxV = rV;
	}
	init.angle = pstObj->rotation;
	init.rco = pstObj->rco;
	init.axis_a = pstObj->rMx*pstObj->scale*rMaxV;
	init.axis_b = pstObj->rMy*pstObj->scale*rMinV;
	try 
	{
		IMG_UWORD debug = 0;
		IMG_CHAR title[80], *p;
		if (stAlignExData.uwDebug & 4)
		{
			debug = 1;
			_snprintf(title, sizeof(title), "Level %d OBJ ID %d", stAlignExData.current_level, pstObj->uwID);
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL", m_SearchOption.GetDebugPath(), g_SearchLogIndex);

		}
		VisMath::MATH_SetLogTitle(title);
		VisMath::MATH_SetDebug(debug, pathname);
		VisMath::MATH_EllipseFit(point, weight, k, &para, &init, &ellipse, pMSE);
		if (stAlignExData.uwDebug & 4)
		{
			const char *logname = VisMath::MATH_GetLogFileName();
			strncpy(title, logname, sizeof(title));
			IMG_CHAR *p = strrchr(title, '\\') - 10;
			HL_InsertObject(m_pHtmlLog, "Fitting info", p);
		}
	}
	catch (CVisException &e)
	{
		if (e.GetExceptionID() == VIS_ERR_MATH_ERR || e.GetExceptionID()==VIS_ERR_FAIL_IN_MKL)
		{
			try
			{
				VisMath::MATH_EllipseFitStr(point, k, &ellipse, pMSE);
			}
			catch (CVisException& e1)
			{
				if (e.GetExceptionID() == VIS_ERR_MATH_ERR || e.GetExceptionID() == VIS_ERR_FAIL_IN_MKL)
				{
					pstObj->rMatched = 0;
					ellipse.rco.x = ellipse.rco.y = -1e5;
					ellipse.angle = -1000;
					ellipse.axis_a = 100;
					ellipse.axis_b = 1;
				}
				else
				{
					throw e;
				}
			}
		}
		else
		{
			throw e;
		}
	}
	{
		IMG_REAL rMaxV = 0, rMinV=1e9;
		for (i = 0; i < pstTable->uwNumOfSpAFeature; i++)
		{
			IMG_REAL rV;
			rV = sqrt(pstTable->pstSpA[i].rco.x*pstTable->pstSpA[i].rco.x + pstTable->pstSpA[i].rco.y*pstTable->pstSpA[i].rco.y);
			if (rV < rMinV)rMinV = rV;
			if (rV > rMaxV)rMaxV = rV;
		}
		IMG_REAL radius = sqrt(ellipse.axis_a*ellipse.axis_b);
		IMG_REAL rMx = ellipse.axis_a / rMaxV;
		IMG_REAL rMy = ellipse.axis_b / rMinV;
		pstObj->rco = ellipse.rco;
		pstObj->rMx = rMx / sqrt(rMx*rMy);
		pstObj->rMy = rMy / sqrt(rMx*rMy);
		pstObj->rotation = ellipse.angle;
		pstObj->scale = radius / sqrt(rMaxV*rMinV);
		for (i = 0, pstObj->rLikeScore = 0; i < k; i++)
		{
			IMG_REAL w = Align_Sigmoid(pMSE[i], 0, 10);
			pstObj->rLikeScore += w*weight[i]/ backmatch.matched_pair_num;
		}
	}
	Align_Translate_Feature_table_to_backmatch(pstTable, pstObj, backmatch_pairs);
	if (stAlignExData.uwDebug & 1)
	{
		HL_CloseTable(m_pHtmlLog);
		HL_Printf(m_pHtmlLog, "\n");
		writeLog("Ellipse Info: Pos [ %.3f, %.3f ], angle %f, axis [%.3f, %.3f]\n", ellipse.rco.x, ellipse.rco.y, ellipse.angle, ellipse.axis_a, ellipse.axis_b);
		writeLog("obj pos [ % .3f, % .3f ], angle %f, scale %f, mx/my [%f, %f]\n", pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, pstObj->rMx, pstObj->rMy);

	}
	//cal matching score
	matched = sum_weight = 0;
	if (stAlignExData.uwDebug & 4 /*&& fp != nullptr*/)
	{
		IMG_CHAR title[80];
		IMG_CHAR *heading[22];
		heading[0] = "FeatID";
		heading[1] = "SrcX";
		heading[2] = "SrcY";
		heading[3] = "SrcAngle";
		heading[4] = "SrcMag";
		heading[5] = "TransXBeforeFit";
		heading[6] = "TransYBeforeFit";
		heading[7] = "TransAngleBeforeFit";
		heading[8] = "TransXAfterFit";
		heading[9] = "TransYAfterFit";
		heading[10] = "TransAngleAfterFit";
		heading[11] = "ImageX";
		heading[12] = "ImageY";
		heading[13] = "ImageAngle";
		heading[14] = "ImageMag";
		heading[15] = "NormalDistBeforeFit";
		heading[16] = "NormalDistAfterFit";
		heading[17] = "Weight/NumOfPt";
		heading[18] = "Error";
		heading[19] = "WeightedError";
		heading[20] = "AXBError";
		heading[21] = "Sigma";
		if (stAlignExData.Bkmode_one2one())
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04dO.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);
		else
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_R%02d_Backmatch_Obj%04d.txt", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, stAlignExData.current_level, pstObj->uwID);

		_snprintf(title, sizeof(title), "Fitting point info of Obj ID %d at level %d\n", pstObj->uwID, stAlignExData.current_level);
		fp = fopen(pathname, "at");
		if (fp)
		{
			fprintf(fp, "%s", title);
			for (i = 0; i < 22; i++)
			{
				fprintf(fp, "%s\t", heading[i]);
			}
			fprintf(fp, "\n");
		}
	}
	fit_angle = pstObj->rotation;
	angle_offset = (original_angle- fit_angle)*num_feat / 360;
	for (i = 0, k = 0; i < num_feat; i++)
	{
		IMG_LREAL dist = 1e10, mindist = 1e10;
		IMG_LREAL angle, anglediff;
		IMG_INT feat_index = angle_offset + i;
		if (feat_index >= num_feat)
			feat_index -= num_feat;
		if (feat_index < 0)
			feat_index += num_feat;
		char value[22][20] = { 0 };
		for (j = 0; j < backmatch_pairs[i].matched_edge_num; j++)
		{
			//angle = atan2(backmatch_pairs[i].matched_edge[j].rcoPos.y-backmatch_pairs[i].translated_feat.y, backmatch_pairs[i].matched_edge[j].rcoPos.x-backmatch_pairs[i].translated_feat.x)/D2R;
			//anglediff = pstSpA[i].angle - angle;
			IMG_LRCOORD lrco = { backmatch_pairs[i].matched_edge[j].rcoPos.x, backmatch_pairs[i].matched_edge[j].rcoPos.y };
			dist = FeatEdgeNormalDistance(&lrco, &backmatch_pairs[feat_index].translated_feat, backmatch_pairs[feat_index].translated_feat_angle);
			if (mindist > dist)
				mindist = dist;
			if (stAlignExData.uwDebug & 4)
			{
				if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
				else			stTable.bgColorOddLine = 0xffffcf;
				_snprintf(value[0], sizeof(value[0]), "%d", i);
				_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[feat_index].rco.x);
				_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[feat_index].rco.y);
				_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[feat_index].angle);
				_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[feat_index].uwEdgeMag);
				_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[feat_index].translated_feat_before_fitting.x);
				_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat_before_fitting.y);
				_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat_angle_before_fitting);
				_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[feat_index].translated_feat.x);
				_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat.y);
				_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat_angle);
				_snprintf(value[11], sizeof(value[7]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.x);
				_snprintf(value[12], sizeof(value[8]), "%9.2f", backmatch_pairs[i].matched_edge[j].rcoPos.y);
				_snprintf(value[13], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].angle);
				_snprintf(value[14], sizeof(value[9]), "%9.2f", backmatch_pairs[i].matched_edge[j].gradient);
				_snprintf(value[15], sizeof(value[10]), "%9.2f", backmatch_pairs[i].matched_normal_distance[j]);
				_snprintf(value[16], sizeof(value[11]), "%.3f", dist);
				_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting / backmatch_pairs[i].matched_edge_num);
				//_snprintf(value[18], sizeof(value[13]), "%.6f", error_iter[k]);
				//_snprintf(value[19], sizeof(value[14]), "%.6f", error_weight[k]);
				//_snprintf(value[20], sizeof(value[15]), "%.6f", error[k]);
				//_snprintf(value[21], sizeof(value[16]), "%.3f", fitting_sigma);
				if (fp)
				{
					for (int k1 = 0; k1 < 22; k1++)
					{
						fprintf(fp, "%s\t", value[k1]);
					}
					fprintf(fp, "\n");
				}
			}
			k++;
			if (backmatch_pairs[i].matched_edge_num == 0)
			{
				_snprintf(value[0], sizeof(value[0]), "%d", i);
				_snprintf(value[1], sizeof(value[1]), "%9.2f", pstSpA[feat_index].rco.x);
				_snprintf(value[2], sizeof(value[2]), "%9.2f", pstSpA[feat_index].rco.y);
				_snprintf(value[3], sizeof(value[3]), "%9.3f", pstSpA[feat_index].angle);
				_snprintf(value[4], sizeof(value[6]), "%d", pstSpA[feat_index].uwEdgeMag);
				_snprintf(value[5], sizeof(value[4]), "%9.2f", backmatch_pairs[feat_index].translated_feat_before_fitting.x);
				_snprintf(value[6], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat_before_fitting.y);
				_snprintf(value[7], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat_angle_before_fitting);
				_snprintf(value[8], sizeof(value[4]), "%9.2f", backmatch_pairs[feat_index].translated_feat.x);
				_snprintf(value[9], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat.y);
				_snprintf(value[10], sizeof(value[5]), "%9.2f", backmatch_pairs[feat_index].translated_feat_angle);
				_snprintf(value[11], sizeof(value[7]), "%9.2f", -1.0f);
				_snprintf(value[12], sizeof(value[8]), "%9.2f", -1.0f);
				_snprintf(value[13], sizeof(value[9]), "%9.2f", -1.0f);
				_snprintf(value[14], sizeof(value[9]), "%9.2f", -1.0f);
				_snprintf(value[15], sizeof(value[10]), "%9.2f", -1.0f);
				_snprintf(value[16], sizeof(value[11]), "%9.2f", -1.0f);
				_snprintf(value[17], sizeof(value[12]), "%.6f", pstSpA[i].rWeighting);
				_snprintf(value[18], sizeof(value[13]), "%.6f", -1.0f);
				_snprintf(value[19], sizeof(value[14]), "%.6f", -1.0f);
				_snprintf(value[20], sizeof(value[15]), "%.6f", -1.0f);
				_snprintf(value[21], sizeof(value[16]), "%.3f", 0/*fitting_sigma*/);
				if (fp)
				{
					for (int k1 = 0; k1 < 22; k1++)
					{
						fprintf(fp, "%s\t", value[k1]);
					}
					fprintf(fp, "\n");
				}
			}

		}
		//if (stAlignExData.uwDebug & 1)
		//{
		//	if (fp)fprintf(fp, "___________________________________\n");
		//}
		if (mindist < stAlignExData.pstOption->rElasticity + 1)
		{
			matched += pstSpA[i].rWeighting;
		}
		sum_weight += pstSpA[i].rWeighting;


	}
	if (fabs(initobj.rMx - initobj.rMy)*pstTable->rMaxSpALength < 0.1f)
	{
		for (i = 0, j = 0; i < backmatch.matched_pair_num; i++)
		{
			if (backmatch.backmatch_pairs[i].matched_edge_num > 0)j++;
		}
		pstObj->rMatched = 100.0f * j / pstTable->uwNumOfSpAFeature;
	}
	else
		pstObj->rMatched = matched*100.0f / sum_weight;

	if (stAlignExData.uwDebug & 4)
	{
		IMG_CHAR *p = strrchr(pathname, '\\') - 10;
		//HL_CloseTable(m_pHtmlLog);
		if (fp)
		{
			fclose(fp);
			HL_Printf(m_pHtmlLog, "\n");
			HL_InsertObject(m_pHtmlLog, "Backmatchinfo", p);
		}
		HL_Printf(m_pHtmlLog, "\n");
	}
	return 0;
}

/**
* @brief <B>Description:</B><br> log initialize 
*/
void CVisAlignSearch::logInit(char *filename)
{
	m_pHtmlLog = (HTMLLOGGING *)CVisMemPool::PMalloc(sizeof(HTMLLOGGING));
	VALIDATE_MALLOC(m_pHtmlLog);
	if (m_pHtmlLog == nullptr)return;
	HL_Create(filename, "Bomming Alignment Search Log", m_pHtmlLog);
	//int default_level = 4;

	//g_log.Initialize();
	//g_log.SetPath("C:\\temp\\log");
	//g_log.SetDefaultLevel(default_level);
	//g_log.SetHeadInfo(true);
	//g_log.SetMode(MODE_WRITE_WHEN_FULL); //1 MODE_LOOP_BUFFER  2 MODE_WRITE_WHEN_FULL
	//g_log.SetRelTime(50); //50 ms 
}
void CVisAlignSearch::logfinish(void)
{
	HL_Close(m_pHtmlLog);
	if (m_pHtmlLog == nullptr)return;
	CVisMemPool::PFree(m_pHtmlLog);
}

/**
* @brief <B>Description:</B><br> write log
*/


void CVisAlignSearch::writeLog(char *msg, ...)
{
	if (m_pHtmlLog == nullptr)return;

	va_list argp;
	va_start(argp, msg);
	IMG_CHAR  buf[512];
	vsprintf((char *)buf, (char *)msg, argp);
	HL_PutLine(m_pHtmlLog, buf);
	va_end(argp);
}
typedef enum 
{
	fittingErr = -5,
	backMatchErr = -4,
	edgeDetectErr = -3,
	pyramidErr = -2,
	filterErr = -1,
	searchNoErr = 0	
	
}SearchStatus;


char * getErrorMessage(int status)
{
	char *s = "searchNoErr";
	switch (status)
	{
	case fittingErr:
		s = "fittingErr";
		break;
	case backMatchErr:
		s = "backMatchErr";
		break;
	case edgeDetectErr:
		s = "edgeDetectErr";
		break;
	case pyramidErr:
		s = "pyramidErr";
		break;
	case filterErr:
		s = "filterErr";
		break;
	default:
		break;
	}
	return s;
}

/**
* @brief <B>Description:</B><br> Search main function,input image path
*/
IMG_VVOID CVisAlignSearch::search(const CVisImage& SrcImage)
{
	IMG_UBBUF ubbSrc;
	const_cast<CVisImage &>(SrcImage).GetImage(&ubbSrc);
	search(ubbSrc);
}

IMG_VVOID CVisAlignSearch::search(CVisImage& SrcImage, CVisImage *Mask)
{
	if (Mask == nullptr)
	{
		search(SrcImage);
	}
	else
	{
		IMG_UBBUF ubbSrc[4], ubbMask;
		SrcImage.GetImage(ubbSrc);
		Mask->GetImage(&ubbMask);
		search(ubbSrc[0], &ubbMask);
	}
}
IMG_VVOID CVisAlignSearch::search(CVisImage& SrcImage)
{
	IMG_UBBUF ubbSrc[4];
	SrcImage.GetImage(ubbSrc);
	search(ubbSrc[0]);
}
IMG_VVOID CVisAlignSearch::search(const IMG_UBBUF & SrcImage)
{
	search(const_cast<IMG_UBBUF &>(SrcImage));
}
IMG_VVOID CVisAlignSearch::search(IMG_UBBUF & SrcImage)
{
	return search(SrcImage, nullptr);
}
IMG_VVOID CVisAlignSearch::search(IMG_UBBUF & SrcImage, IMG_UBBUF *mask)
{
	CVisMemPool pool;
	int search_status = searchNoErr;
	ALIGN_SEARCH_OPTION *pstSrchOpt = m_SearchOption.GetSearchPara();
	VIS_ALIGN_RECORD *pstRec = m_AlignRecord->GetRecord();
	IMG_UINT ulReduction = pstSrchOpt->ubRedFactor > pstRec->ulNumOfLayer - 1 ? pstRec->ulNumOfLayer - 1 : pstSrchOpt->ubRedFactor;
	IMG_UINT ulLowestLayer = pstRec->ulHighestLayer + ulReduction;
	IMG_UINT ulHighestLayer = pstRec->ulHighestLayer;
	IMG_REAL rRejMargin[] = { 1.0, 0.85, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7 };
	IMG_UBBUF ubbSrc, ubbROI, *pubbMaskROI, ubbMaskROI;
	CVisClock clock;
	IMG_INT pcount_before, pcount_after;
	IMG_COORD coOff = { 0,0 };
	IMG_SIZE size = { 0,0};
	IMG_ULWORD ulLUTVersion = pstRec->ulLUTVersion;

	LARGE_INTEGER liTime;
	QueryPerformanceCounter(&liTime);
	m_SearchOption.GetSearchPara()->ulSrchTimestamp = liTime.LowPart;

	//loadImg
	if (mask != nullptr)
	{
		if (mask->size.width != SrcImage.size.width || mask->size.height != SrcImage.size.height)
		{
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Mask is not same size as Srcimage");
		}
	}
	if (pstSrchOpt->stSearchROI.coWindowOff.x > 0 || pstSrchOpt->stSearchROI.coWindowOff.y > 0 ||
		(pstSrchOpt->stSearchROI.szWindowSize.width>0 && pstSrchOpt->stSearchROI.szWindowSize.height > 0))
	{
		if (pstSrchOpt->stSearchROI.coWindowOff.x + pstSrchOpt->stSearchROI.szWindowSize.width < SrcImage.size.width &&
			pstSrchOpt->stSearchROI.coWindowOff.y + pstSrchOpt->stSearchROI.szWindowSize.height < SrcImage.size.height)
		{
			IMG_INT residue = 1 << ulLowestLayer;
			coOff.x = pstSrchOpt->stSearchROI.coWindowOff.x & ~(residue - 1);
			coOff.y = pstSrchOpt->stSearchROI.coWindowOff.y & ~(residue - 1);
			size.width = pstSrchOpt->stSearchROI.coWindowOff.x + pstSrchOpt->stSearchROI.szWindowSize.width - coOff.x;
			size.height = pstSrchOpt->stSearchROI.coWindowOff.y + pstSrchOpt->stSearchROI.szWindowSize.height - coOff.y;
			size.width = (size.width & ~(residue - 1)) + residue;
			size.height = (size.height & ~(residue - 1)) + residue;
			while (coOff.x + size.width >= SrcImage.size.width)size.width -= residue;
			while (coOff.y + size.height >= SrcImage.size.height)size.height -= residue;
			BUF_OFF(ubbROI.ptr, &SrcImage, &coOff);
			ubbROI.size = size;
			ubbROI.linestep = SrcImage.linestep;
			if (mask)
			{
				BUF_OFF(ubbMaskROI.ptr, mask, &coOff);
				ubbMaskROI.size = size;
				ubbMaskROI.linestep = mask->linestep;
				pubbMaskROI = &ubbMaskROI;
			}
			else
			{
				pubbMaskROI = nullptr;
			}
		}
		else
		{
			THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
		}
	}
	else
	{
		ubbROI = SrcImage;
		pubbMaskROI = mask;
	}
	CVisAlignSearchInterData stAlignExData;
	stAlignExData.PubBufSrc(&ubbROI);
	stAlignExData.pstOption = m_SearchOption.GetSearchPara();
	stAlignExData.pstClock = &clock;
	stAlignExData.uwDebug = pstSrchOpt->uwDebug;
	stAlignExData.pubMask = pubbMaskROI;

	if(!pstSrchOpt->ubFastSearch) m_AlignResult.SetResultNum(0);
	m_AlignResult.SetRecordTimeStamp(m_AlignRecord->GetTimeStamp());
	stAlignExData.highest_level = ulHighestLayer;
	stAlignExData.coarse_level = ulLowestLayer;
	stAlignExData.pstRec = pstRec;// m_AlignRecord->GetRecord();


	if (pstSrchOpt->uwDebug)
	{
		if (_access(m_SearchOption.GetDebugPath(), 06) != 0)
		{
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Cannot open debug log path");
		}

		if (g_MasterSearchLogIndex == 0)
		{
			IMG_CHAR pathname[FILENAME_MAX_LENGTH];
			WIN32_FIND_DATA data;
			int index, maxindex = 0;
			HANDLE h_next;
			BOOL nextfile = true;
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG*.*", m_SearchOption.GetDebugPath());
			h_next = FindFirstFile(pathname, &data);
			while (h_next != INVALID_HANDLE_VALUE && nextfile)
			{
				char *p = data.cFileName;
				sscanf(p, "LOG%d", &index);
				if (index > maxindex) maxindex = index;
				nextfile = FindNextFile(h_next, &data);
			}
			g_logIndexLock.try_lock_for(std::chrono::milliseconds(200));
			if (g_MasterSearchLogIndex == 0)g_MasterSearchLogIndex = maxindex + 1;
			else g_MasterSearchLogIndex++;
			if (g_MasterSearchLogIndex > 99999)g_MasterSearchLogIndex = 1;
			g_SearchLogIndex = g_MasterSearchLogIndex;
			g_logIndexLock.unlock();

		}
		else
		{
			//g_logIndexLock.try_lock_for(std::chrono::milliseconds(200));
			g_MasterSearchLogIndex++;
			if (g_MasterSearchLogIndex > 99999)g_MasterSearchLogIndex = 1;
			g_SearchLogIndex = g_MasterSearchLogIndex;
			//g_logIndexLock.unlock();

		}
		VisMath::MATH_InitLogInfo();
	}
	if (pstSrchOpt->uwDebug & 513)
	{
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL.html", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		logInit(pathname);
		writeLog("Log start\n");
#ifdef _DEBUG
		writeLog("Align Version Tag: %s, Debug\n", VisAlign::VIS_ALIGN_Version());
#else
		writeLog("Align Version Tag: %s Release\n", VisAlign::VIS_ALIGN_Version());
#endif
		writeLog("VisSystem Version Tag: %s\n", VIS_SYSTEM_DLL_Version());
		writeLog("TCL Version Tag: %s\n", TCL_DLL_Version());

#ifdef _WIN64
		writeLog("build on %s %s, x64\n", __DATE__, __TIME__);
#else
		writeLog("build on %s %s, x86\n", __DATE__, __TIME__);
#endif // _WIN64
		writeLog("Record Lib Version Tag: %s\n", m_AlignRecord->m_record->pcCommentOfRec);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		_mkdir(pathname);
		CVisImage srcImage(SrcImage);
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSI.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		srcImage.WriteImage_Syn(pathname);

		writeLog("Source Image\n");
		p = strrchr(pathname, '\\')+1;
		HL_InsertImage(m_pHtmlLog, p);
		m_SearchOption.SaveOptionToHTMLLog(m_pHtmlLog);

		if (mask)
		{
			srcImage.SetImage(*mask);
		}
		else
		{
			srcImage.Mul_C(0);
			srcImage.Add_C(1);
		}
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSMask.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		srcImage.WriteImage_Syn(pathname);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSO.opt", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		m_SearchOption.SaveToFile(pathname);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSR.rec", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		m_AlignRecord->SaveToFile(pathname);

		if (m_AlignResult.Size() && m_SearchOption.GetFastSearch())
		{
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSR.cdt", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
			m_AlignResult.SaveToFile(pathname);
		}
		_snprintf(pathname, FILENAME_MAX_LENGTH, "LUT Version: %d\n", ulLUTVersion);
		writeLog(pathname);
	}
	if (pstSrchOpt->stSearchROI.coWindowOff.x > 0 || pstSrchOpt->stSearchROI.coWindowOff.y > 0 ||
		(size_t)pstSrchOpt->stSearchROI.szWindowSize.width*pstSrchOpt->stSearchROI.szWindowSize.height > 0)
	{
		if (pstSrchOpt->stSearchROI.coWindowOff.x + pstSrchOpt->stSearchROI.szWindowSize.width < SrcImage.size.width &&
			pstSrchOpt->stSearchROI.coWindowOff.y + pstSrchOpt->stSearchROI.szWindowSize.height < SrcImage.size.height)
		{
			if (m_AlignResult.Size() > 0 && pstSrchOpt->ubFastSearch)
			{
				IMG_OBJ *pstObj = m_AlignResult.Result()->ptr;
				for (IMG_INT i = 0; i < m_AlignResult.Size(); i++)
				{
					pstObj->rco.x -= coOff.x;
					pstObj->rco.y -= coOff.y;
					pstObj->rco.x /= pow(2, ulLowestLayer);
					pstObj->rco.y /= pow(2, ulLowestLayer);
				}
			}
		}
		else
		{
			if (pstSrchOpt->uwDebug & 5)
			{
				writeLog("search ROI out of image, error");
				logfinish();
			}
			THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
		}
	}
	else
	{
		if (m_AlignResult.Size() > 0 && pstSrchOpt->ubFastSearch)
		{
			IMG_OBJ *pstObj = m_AlignResult.Result()->ptr;
			for (IMG_INT i = 0; i < m_AlignResult.Size(); i++)
			{
				pstObj->rco.x /= pow(2, ulLowestLayer);
				pstObj->rco.y /= pow(2, ulLowestLayer);
			}
		}
	}
	if (pstSrchOpt->rCoarseAcceptLevel > 1 || pstSrchOpt->rAcceptLevel > 1)
	{
		if (pstSrchOpt->uwDebug & 5)
		{
			writeLog("pstSrchOpt->rCoarseAcceptLevel > 1 or pstSrchOpt->rAcceptLevel > 1, error");
			logfinish();
		}
		THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
	}
	if (pstSrchOpt->uwDebug & 256)
	{
		g_pstClock = &clock;
		clock.Start();
		clock.Click("Start");
	}
	else
	{
		g_pstClock = nullptr;
	}	
	pcount_before = pool.GetPushPopCount();

	if (Align_VerifyBuildDate() == IMG_FALSE)
	{
		static thread_local int run_count = 0;
		run_count++;
		if (run_count > 1)
		{
			static bool sts = false;
			if (!sts)
			{
				sts = SEC_Validate();
				if (!sts)
				{
					if (pstSrchOpt->uwDebug & 513)
					{
						writeLog("SEC check fail.");
					}
					m_AlignResult.SetResultNum(0);
					goto exit;
				}
				if (run_count % 500 == 0)
				{
					sts = false;
				}
			}
		}
	}
	else
	{
		static thread_local int run_count = 0;
		run_count++;
		static bool sts = false;
		if (!sts)
		{
			sts = SEC_Validate();
		}
		if (run_count % 500 == 0)
		{
			sts = false;
		}
	}

	//gaussian
	stAlignExData.preprocessInit(pool);
	if (preprocess(stAlignExData) != 0)
	{
		search_status = filterErr;
		goto exit;
	}
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	if (pstSrchOpt->uwDebug & 1)
	{
		writeLog("reduction lowest level %d\n", stAlignExData.coarse_level);
		writeLog("reduction highest level %d\n", stAlignExData.highest_level);
		writeLog("gaussian end.");
		writeLog("pyramid begin.");
	}
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After_gaussian");
	}
	//pyramid
	stAlignExData.pyramidInit(pool);
	if (pyramid(stAlignExData) != 0)
	{
		search_status = pyramidErr;
		goto exit;
	}
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After_pyramid");
	}
	if (pstSrchOpt->uwDebug & 1)
	{
		char pyramidFile[100];
		for (int i = ulLowestLayer; i >= (int)ulHighestLayer; i--)
		{
			sprintf(pyramidFile, "subPyramid_img%u.png", i);
		}
		writeLog("pyramid end.");
	}

	//edge detect
	if (pstSrchOpt->uwDebug & 1)
	{
		writeLog("edge detect begin.");
	}
	stAlignExData.edgeDetectInit(ulLowestLayer);
	if (edgeExtract_dstRoi(stAlignExData) != 0)
	{
		search_status = edgeDetectErr;
		goto exit;
	}
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("edge_detection");
	}
	if (pstSrchOpt->uwDebug & 1)
	{
		writeLog("edge detect end.");
		//////	output bin img		///////////////////////////////////////
		//FILE *file = fopen("edgeDetect.txt", "w+");
		int flag = 1;
		//int _width = stAlignExData.PyrStruct()->pRoi[ulLowestLayer].width;
		//int _height = stAlignExData.PyrStruct()->pRoi[ulLowestLayer].height;
		int _width = stAlignExData.ubbufReduction[ulLowestLayer].size.width;
		int _height = stAlignExData.ubbufReduction[ulLowestLayer].size.height;
		unsigned char* pEdgeImg = (unsigned char*)pool.Malloc((size_t)_width * _height);
		memset(pEdgeImg, 0, (size_t)_width*_height);
		for (int k = 0; k < stAlignExData.EdgeNum(); k++)
		{
			int i, j;
			i = (stAlignExData.pEdgeArray() + k)->coPos.y;
			j = (stAlignExData.pEdgeArray() + k)->coPos.x;
			*(pEdgeImg + i * _width + j) = 255;
		}
		IMG_CHAR pathname[MAX_FILE_NAME], *p;
		if (pstSrchOpt->uwDebug & 4)
		{
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_edge_mag.tif", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
			saveImg(stAlignExData.EdDst().ptr, { _width,_height }, pathname);
			p = strrchr(pathname, '\\')-10;
			HL_InsertObject(m_pHtmlLog, "Edge mag\n", p);
			writeLog("\n");
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_edge_angle.tif", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
			saveImg(stAlignExData.EdAngle().ptr, { _width,_height }, pathname);
			p = strrchr(pathname, '\\')-10;
			HL_InsertObject(m_pHtmlLog, "Edge angle\n", p);
			writeLog("\n");
		}
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_edge.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		saveImg(pEdgeImg, { _width,_height }, pathname);
		p = strrchr(pathname, '\\')-10;
		HL_InsertImage(m_pHtmlLog, p);
		HL_PutLineBreak(m_pHtmlLog);
	}
	///////////////////////////coarse_search////////////////////////////////////////
	if (!pstSrchOpt->ubFastSearch) coarse_search(stAlignExData);
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("coarse_search");
	}
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
//	////////////////// after coarse_search  ////////////////////////////
	//IMG_INT start_level, end_level;
	IMG_INT level_i;
	//start_level = pstRec->ulNumOfLayer+pstRec->ulHighestLayer-1;
	//end_level = m_AlignRecord->GetRecord()->ulHighestLayer;
	m_AlignResult.SortByMatchScore();
	for(level_i = (IMG_INT)ulLowestLayer; level_i >= (IMG_INT)ulHighestLayer; level_i--)
	{
		stAlignExData.current_level = level_i;
		stAlignExData.pstTable = m_AlignRecord->GetRecord()->ptr+level_i-ulHighestLayer;

		if (pstSrchOpt->uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "start_fine_search_%d", level_i);
			clock.Click(msg);
		}
		//m_AlignResult.RejectByMatchScore(m_SearchOption.GetAcceptScore(), rRejMargin[level_i - ulHighestLayer]);
		pcount_before = pool.GetPushPopCount();
		if(m_AlignResult.Size()>0)
			search_level(stAlignExData, level_i-ulHighestLayer);
		m_AlignResult.SortByFittingScore();
		pcount_after = pool.GetPushPopCount();
		if (pcount_after != pcount_before)
			THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		pcount_before = pcount_after;

		scale_object_table(m_AlignResult, 2.0);
	}
	for(level_i = 0; level_i<stAlignExData.highest_level; level_i++)
		scale_object_table(m_AlignResult, 2.0);
	scale_object_table(m_AlignResult, 0.5);

	m_AlignResult.RejectByMatchScore(m_SearchOption.GetAcceptScore(), rRejMargin[0]);
	if (pstSrchOpt->uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object matching score rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Matching score");
	}
	if (!stAlignExData.pstTable->ubSpARotationIndependent)
		m_AlignResult.RejectByAngle(pstSrchOpt->rMaxAngle-pstRec->rOrientation, pstSrchOpt->rMinAngle - pstRec->rOrientation, pstSrchOpt->rRepeatingAngle, rRejMargin[0]);
	if (pstSrchOpt->uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object angle rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Angle Range");
	}
	if (!stAlignExData.pstTable->ubSpAScaleIndependent)
		m_AlignResult.RejectByScale(pstSrchOpt->rMaxScale, pstSrchOpt->rMinScale, rRejMargin[0]);
	if (pstSrchOpt->uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object scale rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Scale Range");
	}
	if (pstSrchOpt->ubOverlap)
	{
		if (stAlignExData.pstTable->ubSpARotationIndependent || pstSrchOpt->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
		{
			m_AlignResult.RejectCircleObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 0.2, stAlignExData.highest_level);
		}
		else
		{
			m_AlignResult.RejectObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 0.2, stAlignExData.highest_level);
		}
	}
	else
	{
		if (stAlignExData.pstTable->ubSpARotationIndependent || pstSrchOpt->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
		{
			m_AlignResult.RejectCircleObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 1.0, stAlignExData.highest_level);
		}
		else
		{
				m_AlignResult.RejectObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 1.0, stAlignExData.highest_level);
		}
	}
	if (pstSrchOpt->uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After final overlap rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Scale Range");
	}

	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After_reject_overlap");
	}
	for (int i = 0; i < m_AlignResult.Size(); i++)
	{
		IMG_OBJ *pstObj = m_AlignResult.GetIMG_OBJ(i);
		Align_Translate_RCOORD_By_Obj(pstRec->rcoPt, pstRec->uwNumOfObjCorner, pstObj, pstObj->arcoObjCorner);
		pstObj->uwNumOfCorner = pstRec->uwNumOfObjCorner;
		Align_Translate_RCOORD_By_Obj(pstRec->rcoROI, 4, pstObj, pstObj->arcoROICorner);
		pstObj->rotation += pstRec->rOrientation;
		if (pstObj->rotation > pstSrchOpt->rMaxAngle)pstObj->rotation -= 360;
		if (pstObj->rotation < pstSrchOpt->rMinAngle)pstObj->rotation += 360;
	}
	if (m_AlignResult.Size() == 0)
	{
		IMG_OBJ *pstObj = m_AlignResult.GetFirstIMG_OBJ();
		Align_Translate_RCOORD_By_Obj(pstRec->rcoPt, pstRec->uwNumOfObjCorner, pstObj, pstObj->arcoObjCorner);
		pstObj->uwNumOfCorner = pstRec->uwNumOfObjCorner;
		Align_Translate_RCOORD_By_Obj(pstRec->rcoROI, 4, pstObj, pstObj->arcoROICorner);
		pstObj->rotation += pstRec->rOrientation;
		if (pstObj->rotation > pstSrchOpt->rMaxAngle)pstObj->rotation -= 360;
		if (pstObj->rotation < pstSrchOpt->rMinAngle)pstObj->rotation += 360;
	}
	translate_object_table(m_AlignResult, &pstRec->rcoRefVector);
	m_AlignResult.OffsetTable({ (IMG_REAL)coOff.x, (IMG_REAL)coOff.y }, stAlignExData.highest_level);
	m_AlignResult.SortByFittingScore();
	if (m_SearchOption.GetMultiObj() == SRCH_MO_HIGHEST && m_AlignResult.Size() > 0)
	{
		m_AlignResult.SetResultNum(1);
	}
	if (stAlignExData.pstOption->uwFixedNumObj > 0 && m_AlignResult.Size() > stAlignExData.pstOption->uwFixedNumObj)
	{
		m_AlignResult.SetResultNum(stAlignExData.pstOption->uwFixedNumObj);
	}
	if (pstSrchOpt->uwDebug & 513)
	{
		// test result//////////////////////////////
		ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
		writeLog("Total Object Num %d\n", result->size);
		HTMLLOGGING_TABLE_DATA stTable;
		HL_InitTableData(&stTable);
		stTable.title = "Final Result";
		stTable.tablelinewidth = 0;
		stTable.column = 7;
		stTable.fontweight = FW_Medium;
		stTable.tablealign = TX_CENTER;
		stTable.tablewidth = 50;
		stTable.tablelinewidth = 1;
		stTable.bgColorOddLine = 0xffff7f;
		stTable.formatstring = "%.6f";
		stTable.datatype = DT_REAL;
		stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
		stTable.heading[0] = "ID";
		stTable.heading[1] = "PosX";
		stTable.heading[2] = "PosY";
		stTable.heading[3] = "Scale";
		stTable.heading[4] = "Rotation";
		stTable.heading[5] = "Fitting Score";
		stTable.heading[6] = "Matching Score";
		HL_CreateTableHeader(m_pHtmlLog, &stTable);
		for (int i = 0; i < m_AlignResult.Size(); i++)
		{
			char value[7][20];
			if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
			else			stTable.bgColorOddLine = 0xffffcf;
			_snprintf(value[0], sizeof(value[0]), "%d", result->ptr[i].uwID);
			_snprintf(value[1], sizeof(value[1]), "%.3f", result->ptr[i].rco.x);
			_snprintf(value[2], sizeof(value[2]), "%.3f", result->ptr[i].rco.y);
			_snprintf(value[3], sizeof(value[3]), "%.6f", result->ptr[i].scale);
			_snprintf(value[4], sizeof(value[4]), "%.6f", result->ptr[i].rotation);
			_snprintf(value[5], sizeof(value[5]), "%.3f", result->ptr[i].rLikeScore);
			_snprintf(value[6], sizeof(value[6]), "%.3f", result->ptr[i].rMatched);
			HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
		}
		HL_CloseTable(m_pHtmlLog);
		HL_Printf(m_pHtmlLog, "\n");
	}
	//g_log.FinalDump();
	//system("pause");

exit:
	mkl_free_buffers();
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	pcount_before = pcount_after;
	if (pstSrchOpt->uwDebug & 256)
	{
		char name[MAX_FILE_NAME];
		clock.Click("Finish_search");
		_snprintf_s(name, sizeof(name), "%s\\LOG%05uST.log", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		clock.SetPath(name);
		clock.SaveToFile();
	}
	if (pstSrchOpt->uwDebug & 513)
	{
		IMG_INT i = 0;
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
		IMG_UBBUF buf[3], bufmask;
		CVisImage immask;
		if (stAlignExData.pubMask)
		{
			bufmask = *mask;
			CVisImage mask1({ bufmask.size.width, bufmask.size.height }, 1), src;
			src.SetImage(bufmask);
			immask.SetImage(SrcImage);
			mask1.Sub(src);
			mask1.Mul_C(40);
			immask.Add(mask1);
			immask.GetImage(&bufmask);
			buf[0] = bufmask;
			buf[1] = SrcImage;
			buf[2] = SrcImage;
		}
		else
		{
			buf[0] = SrcImage;
			buf[1] = SrcImage;
			buf[2] = SrcImage;
		}
		CVisImage img(buf);
		for (i = 0; i < m_AlignResult.Size(); i++)
		{
			//Align_DrawColorfulResultInBuffer(&img, m_AlignResult.GetIMG_OBJ(i), pstRec, COLORS::Green);
			m_AlignResult.DrawObjInColorBuffer(img, m_AlignRecord, i);
			//_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult_%02d.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex,i);
			//Align_DrawResultInImage(&SrcImage, m_AlignResult.GetIMG_OBJ(i), m_AlignRecord->GetRecord(), 1, 10, pathname);
		}
		if (m_AlignResult.Size() == 0)
		{
			Align_DrawColorfulResultInBuffer(&img, m_AlignResult.GetFirstIMG_OBJ(), pstRec, COLORS::Red);
		}
		if(img.Width()*img.Height() < 2096*2096 || img.Width()>JPG_SIZE_LIMITATION|| img.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSL\\LOG%05uSResult.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSL\\LOG%05uSResult.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		//switch (g_SearchLogIndex %4)
		//{
		//case 0:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//	break;
		//case 1:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//	break;
		//case 2:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//	break;
		//case 3:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.tif", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//default:
		//	break;
		//}

		img.WriteImage(pathname);
		p = strrchr(pathname, '\\')-10;
		HL_InsertImage(m_pHtmlLog, p);
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("searchStatus: %s \n", getErrorMessage(search_status));
		logfinish();
	}
}

IMG_VVOID CVisAlignSearch::scale_object_table(CVisAlignResult &stObjtable, IMG_REAL scale_factor)
{
	int i;
	stObjtable.ScaleTable(scale_factor);
	return;
}

IMG_VVOID CVisAlignSearch::searchseg_level(CVisAlignSearchInterData &stAlignExData, IMG_INT level, ALIGN_REC_SEGMENT *segInput, IMG_INT segNums)
{
	IMG_OBJ obj;
	IMG_INT i, j, k;
	int search_status = searchNoErr;
	CVisMemPool pool;
	IMG_REAL rScoreMargin;
	ALIGN_SEARCH_OPTION *stOption = m_SearchOption.GetSearchPara();

	IMG_INT pcount_before, pcount_after;

	if (stAlignExData.uwDebug & 256)
	{
		char msg[MAX_FILE_NAME];
		_snprintf_s(msg, sizeof(msg), "Enter_level_%d", level);
		stAlignExData.pstClock->Click(msg);
	}
	if (stAlignExData.uwDebug & 4)
	{
	/*	char objfile[FILENAME_MAX_LENGTH], *p;
		IMG_UBBUF ubbSrc;

		ubbSrc.ptr = stAlignExData.pPyrImage[level];
		ubbSrc.size.width = stAlignExData.pPyrStruct->pRoi[level].width;
		ubbSrc.size.height = stAlignExData.pPyrStruct->pRoi[level].height;
		ubbSrc.linestep = ubbSrc.size.width;
		_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Level%d_ReducedSrc.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level);
		CVisImage sub_src(ubbSrc);
		sub_src.WriteImage(objfile);*/

		writeLog("Level %d", level);
		HL_PutLineBreak(m_pHtmlLog);
		/*writeLog("Level %d source image", level);
		p = strrchr(objfile, '\\') - 10;
		HL_InsertImage(m_pHtmlLog, p);*/
		writeLog("\n");
	}
	if (level == 0)
	{
		if (m_AlignResult.Size() > 0)
		{
			if (m_AlignResult.m_match)
			{
				m_AlignResult.m_match->Free();
				pool.PFree(m_AlignResult.m_match);
			}
			m_AlignResult.m_match = (CVisAlignResultPointMatch *)CVisMemPool::PMalloc(sizeof(CVisAlignResultPointMatch));
			VALIDATE_MALLOC(m_AlignResult.m_match);
			new(m_AlignResult.m_match)CVisAlignResultPointMatch();
			m_AlignResult.m_match->Allocate(m_AlignRecord->GetRecord()->ptr->uwNumOfSpAFeature, m_AlignResult.Size());
			m_AlignResult.m_match->reduction = stAlignExData.highest_level;
		}
	}
	for (i = 0; i<m_AlignResult.Size(); i++)
	{
		if (stAlignExData.uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "Obj%d_start", obj.uwID);
			stAlignExData.pstClock->Click(msg);
		}
		pool.Push();
		obj = m_AlignResult.Result()->ptr[i];
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("---------ID:%d------------\n", obj.uwID);
		}
		if (stAlignExData.uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "Start_Obj_%04d_backmatch", obj.uwID);
			stAlignExData.pstClock->Click(msg);
		}
		stAlignExData.pstObj = &obj;
		stAlignExData.Bkmode_one2one(IMG_FALSE);

		pcount_before = pool.GetPushPopCount();
		stAlignExData.backMatchInit(stAlignExData.pstTable, level, &obj, pool);
		//stAlignExData.iterInit(m_AlignRecord->GetRecord()->ptr, level, &obj);
		if (back_match_segment(stAlignExData, segInput, segNums) != 0)
		{
			search_status = backMatchErr;
			pool.Pop();
			goto exit;
		}
		pcount_after = pool.GetPushPopCount();
		if (pcount_after != pcount_before)
			THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		if (stAlignExData.uwDebug & 256)
		{
			stAlignExData.pstClock->Click("backmatch");
		}

		if (stAlignExData.backmatch_info.matched_edge_num < 5)
		{
			if (stAlignExData.uwDebug & 1)
			{
				writeLog("Matched point %d less than 5, object rejected\n", stAlignExData.backmatch_info.matched_edge_num);
			}
			m_AlignResult.Result()->ptr[i].rMatched = 0;
			search_status = backMatchErr;
			pool.Pop();
			continue;
		}
		//stAlignExData.Num_matchedPoints(num_matchedPoints);
		//fitting
		iterationfit(stAlignExData);
		if (stAlignExData.uwDebug & 256)
		{
			stAlignExData.pstClock->Click("fitting");
		}
		pcount_after = pool.GetPushPopCount();
		if (pcount_after != pcount_before)
			THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		if (ALIGN_DIST(obj.rco, m_AlignResult.Result()->ptr[i].rco) > 5 * (stOption->rElasticity + 5))
		{
			if (stAlignExData.uwDebug & 1)
			{
				writeLog("Fitting object failed, object reject\n", stAlignExData.backmatch_info.matched_edge_num);
			}
			m_AlignResult.Result()->ptr[i].rMatched = 0;
			search_status = filterErr;
			pool.Pop();
			continue;
		}
		if (level == 0)
		{
			//one to one match

			stAlignExData.Bkmode_one2one(IMG_TRUE);
			stAlignExData.backMatchInit(stAlignExData.pstTable, level, &obj, pool);
			if (back_match_segment(stAlignExData, segInput, segNums) != 0)
			{
				search_status = backMatchErr;
				pool.Pop();
				goto exit;
			}
			pcount_after = pool.GetPushPopCount();
			if (pcount_after != pcount_before)
				THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
			if (stAlignExData.uwDebug & 256)
			{
				stAlignExData.pstClock->Click("2nd_backmatch");
			}
			if (stAlignExData.backmatch_info.matched_edge_num < 5)
			{
				obj.rMatched = 0;
				m_AlignResult.Result()->ptr[i] = obj;
				search_status = backMatchErr;
				pool.Pop();
				continue;
			}
			if (stAlignExData.uwDebug & 256)
			{
				stAlignExData.pstClock->Click("Start_2nd_fitting");
			}
			iterationfit(stAlignExData);
			if (stAlignExData.uwDebug & 256)
			{
				stAlignExData.pstClock->Click("2nd_fitting");
			}
			if (stAlignExData.uwDebug & 1)
			{
				// test result//////////////////////////////
				//cout << "scale = " << obj.scale << endl;
				//cout << "rotation = " << obj.rotation << endl;
				//cout << "dstX = " << obj.rco.x << endl;
				//cout << "dstY = " << obj.rco.y << endl;
				//cout << "fitting score = " << obj.rLikeScore << endl;
				//cout << "matching score = " << obj.rMatched << endl;
				//cout << endl;
			}
			for (j = 0; j < stAlignExData.backmatch_info.matched_pair_num; j++)
			{
				EDGE_INFORMATION trans, edge = { 0 };
				trans.coPos.x = trans.rcoPos.x = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.x;
				trans.coPos.y = trans.rcoPos.y = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.y;
				trans.angle = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat_angle;
				if (stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge_num > 0)
				{
					m_AlignResult.m_match->AddPair(obj.uwID, stAlignExData.backmatch_info.backmatch_pairs[j].origin_feature, &trans, stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge);
				}
				else
				{
					m_AlignResult.m_match->AddPair(obj.uwID, stAlignExData.backmatch_info.backmatch_pairs[j].origin_feature, &trans, &edge);
				}
			}
			pcount_after = pool.GetPushPopCount();
			if (pcount_after != pcount_before)
				THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		}
		//Align_Translate_RCOORD_By_Obj(stAlignExData.pstTable->arcoObjCorner, stAlignExData.pstTable->uwNumOfObjCorner, &obj, obj.arcoObjCorner);
		//Align_Translate_RCOORD_By_Obj(stAlignExData.pstTable->arcoROICorner, 4, &obj, obj.arcoROICorner);
		m_AlignResult.Result()->ptr[i] = obj;
		if (stAlignExData.uwDebug & 4)
		{
			char objfile[FILENAME_MAX_LENGTH], *p;
			IMG_UBBUF ubbSrc, ubbC[3];

			IMG_INT cross_size = level > 2 ? 7 : 7 * (1 << (2 - level));

			ubbSrc = stAlignExData.ubbufReduction[level + stAlignExData.highest_level];
			//ubbSrc.ptr = stAlignExData.pPyrImage[level + stAlignExData.highest_level];
			//ubbSrc.size.width = stAlignExData.ubbufReduction[level + stAlignExData.highest_level].size.width;
			//ubbSrc.size.height = stAlignExData.ubbufReduction[level + stAlignExData.highest_level].size.height;
			//ubbSrc.linestep = ubbSrc.size.width;
			if(ubbSrc.size.width > JPG_SIZE_LIMITATION || ubbSrc.size.height>JPG_SIZE_LIMITATION)
				_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Search_obj_%d_%d.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level, obj.uwID);
			else
				_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Search_obj_%d_%d.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level, obj.uwID);

			//Align_DrawObjInImage(&ubbSrc, &obj, stAlignExData.pstTable, level > 2 ? 2 : 1, cross_size, objfile);
			ubbC[0] = ubbSrc;
			ubbC[1] = ubbSrc;
			ubbC[2] = ubbSrc;
			CVisImage img(ubbC);
			EDGE_INFORMATION trans;
			IMG_UINT ulMatched;
			ALIGN_REC_SEGMENT *tempSeg;
			IMG_RCOORD tempEdgePt;
			for (int m = 0; m < segNums; m++)
			{
				tempSeg = &segInput[m];
				switch (tempSeg->seg_type)
				{
				case ALIGN_REC_LINE_SEGMENT:
				{
					IMG_REAL lineLength = (IMG_INT)pow(pow(tempSeg->start.x - tempSeg->end.x, 2) + pow(tempSeg->start.y - tempSeg->end.y, 2), 0.5);
	
					for (j = 0; j < lineLength; j++)
					{
						tempEdgePt.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x) + 0.5;
						tempEdgePt.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y) + 0.5;
						img.DrawPoint(&tempEdgePt, 1, COLORS::White);
					}

				}
				break;
				case ALIGN_REC_ARC_SEGMENT:
				{
					IMG_ARCT tempArc;
					IMG_RCOORD rcoArc[3]; rcoArc[0] = tempSeg->start; rcoArc[1] = tempSeg->center[0]; rcoArc[2] = tempSeg->end;
					VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
					IMG_REAL tempAngle;
					tempAngle = tempArc.end_angle - tempArc.start_angle;
					if (tempAngle < 0)tempAngle += 360;
					IMG_INT arcLength = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
					IMG_REAL angle;
					for (j = 0; j < arcLength; j++)
					{
						angle = tempAngle*j / arcLength + tempArc.start_angle;
						if (angle < 0)angle += 360;
						if (angle > 360)angle -= 360;
						tempEdgePt.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R)) + 0.5;
						tempEdgePt.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R)) + 0.5;
						img.DrawPoint(&tempEdgePt, 1, COLORS::White);
					}
				}
				break;
				case ALIGN_REC_BSPLINE_SEGMENT:
				{
					ALIGN_SEGMENT_CURVE curve = tempSeg->curve;
					if (curve.num_points == 0 || !curve.control_points)
					{
						THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
					}
					IMG_RCOORD *coor = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*curve.num_points);
					for (int m = 0; m < curve.num_points; m++)
					{
						coor[m] = curve.control_points[m];
					}
					CVisNURBSCurve nurbsCurve(curve.isClosed);
					nurbsCurve.SetInputPara(coor, curve.num_points, curve.dims);
					vector<PARA_POINT> vecDstPoints;
					nurbsCurve.GetCurvePts(200, vecDstPoints);
					PARA_POINT tmpParaPt;
					for (j = 0; j < vecDstPoints.size(); j++)
					{
						tempEdgePt.x = (vecDstPoints[j].pt.x) + 0.5;
						tempEdgePt.y = (vecDstPoints[j].pt.y) + 0.5;
						img.DrawPoint(&tempEdgePt, 1, COLORS::White);
					}
					vecDstPoints.clear();
				}
					break;
				default:
					THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
					break;

				}
			}
			//IMG_UINT cross_size = ubbSrc.size.width / 10;
			//if (cross_size < 4)cross_size = 4;
			for (int m = 0; m < stAlignExData.Num_template(); m++) 
			{
				IMG_INT x, y;
				x = stAlignExData.backmatch_info.backmatch_pairs[m].translated_feat.x + 0.5;
				y = stAlignExData.backmatch_info.backmatch_pairs[m].translated_feat.y + 0.5;
				//Align_DrawTranslatedFeatureInImage(img, stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat, 1, COLORS::White, cross_size, 0);
				for (j = -(cross_size >> 1); j <= (cross_size >> 1); j++)
				{
					if (x - j >= 0 && x + j >= 0 && x + j < ubbSrc.size.width && x - j < ubbSrc.size.width)
					{
						if (y - 1 >= 0 && y - 1 < ubbSrc.size.height)
						{
							tempEdgePt.x = (x - j); tempEdgePt.y = (y - 1);
							img.DrawPoint(&tempEdgePt, 1, COLORS::Green);
						}
						if (y + 1 < ubbSrc.size.height && y + 1 >= 0)
						{
							tempEdgePt.x = (x - j); tempEdgePt.y = (y + 1);
							img.DrawPoint(&tempEdgePt, 1, COLORS::Green);
						}
						if (y < ubbSrc.size.height && y >= 0)
						{
							tempEdgePt.x = (x - j); tempEdgePt.y = (y + 0);
							img.DrawPoint(&tempEdgePt, 1, COLORS::Green);
						}
					}
					if (y - j >= 0 && y + j >= 0 && y + j < ubbSrc.size.height && y - j < ubbSrc.size.height)
					{
						if (x - 1 >= 0 && x - 1 < ubbSrc.size.height)
						{
							tempEdgePt.x = (x - 1); tempEdgePt.y = (y - j);
							img.DrawPoint(&tempEdgePt, 1, COLORS::Green);
						}
						if (x + 1 < ubbSrc.size.width && x + 1 >= 0)
						{
							tempEdgePt.x = (x + 1); tempEdgePt.y = (y - j);
							img.DrawPoint(&tempEdgePt, 1, COLORS::Green);
						}
						if (x < ubbSrc.size.width && x >= 0)
						{
							tempEdgePt.x = (x); tempEdgePt.y = (y - j);
							img.DrawPoint(&tempEdgePt, 1, COLORS::Green);
						}

					}
				}
			}
			//backmatch_info.backmatch_pairs[j].translated_feat
			for (j = 0; j < stAlignExData.backmatch_info.matched_pair_num; j++)
			{
				trans.rcoPos.x = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.x;
				trans.rcoPos.y = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.y;
				for (k = 0; k < stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge_num; k++)
				{
					Align_DrawTranslatedFeatureInImage(img, stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge + k, 1, COLORS::Green, cross_size, 0);
					img.DrawLine(stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge[k].rcoPos, trans.rcoPos, COLORS::Yellow);
				}
			}
			for (j = 0; j < stAlignExData.backmatch_info.matched_pair_num; j++)
			{
				trans.rcoPos.x = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.x;
				trans.rcoPos.y = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.y;
				trans.angle = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat_angle;
				if (stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge_num > 0)
					Align_DrawTranslatedFeatureInImage(img, &trans, 1, COLORS::Cyan, cross_size / 2.0f, 0);
				else
					Align_DrawTranslatedFeatureInImage(img, &trans, 1, COLORS::Red, cross_size / 2.0f, 0);
			}
			img.WriteImage(objfile);
			p = strrchr(objfile, '\\') - 10;
			HL_InsertImage(m_pHtmlLog, p);
			writeLog("\n");
		}
		pool.Pop();
		if (stAlignExData.uwDebug & 256)
		{
			stAlignExData.pstClock->Click("End_obj");
		}
	}
	pcount_before = pool.GetPushPopCount();
	if (stAlignExData.uwDebug & 1)
	{
		char str[20];
		_snprintf_s(str, sizeof(str), "Level %d", level);
		// test result//////////////////////////////
		ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
		writeLog("Total Object Num %d at Level %d\n", result->size, level);
		Align_OutputTableInHTML(m_pHtmlLog, result, str);
	}



	switch (level)
	{
	case 0:
		rScoreMargin = 0.95;
		break;
	case 1:
		rScoreMargin = 0.85;
		break;
	default:
		rScoreMargin = 0.7;
		break;
	}
	m_AlignResult.RejectByMatchScore(stOption->rAcceptLevel, rScoreMargin);
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object score rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Matching Score");
	}
	if(!stAlignExData.pstTable->ubSpARotationIndependent)
		m_AlignResult.RejectByAngle(stOption->rMaxAngle - stAlignExData.pstRec->rOrientation, stOption->rMinAngle - stAlignExData.pstRec->rOrientation, stOption->rRepeatingAngle, rScoreMargin);
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object angle rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Angle Range");
	}
	if (!stAlignExData.pstTable->ubSpAScaleIndependent)
		m_AlignResult.RejectByScale(stOption->rMaxScale, stOption->rMinScale, rScoreMargin);
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object scale rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Scale Range");
	}

	if (stAlignExData.uwDebug & 256)
	{
		stAlignExData.pstClock->Click("Score_rejection");
	}
	if (stOption->ubOverlap) rScoreMargin = 0.2;
	if (stAlignExData.pstTable->ubSpARotationIndependent || stOption->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
	{
		m_AlignResult.RejectCircleObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, stOption->rOverlapScaleMargin, rScoreMargin, level);
	}
	else
	{
		m_AlignResult.RejectObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, stOption->rOverlapScaleMargin, rScoreMargin, level);
	}
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object overlap rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Overlap");
	}
	if (stAlignExData.uwDebug & 256)
	{
		stAlignExData.pstClock->Click("Overlap_rejection");
	}
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
exit:
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "Level %d searchStatus: %s \n", level, getErrorMessage(search_status));
	}
	return;
}
IMG_VVOID CVisAlignSearch::search_level(CVisAlignSearchInterData &stAlignExData, IMG_INT level)
{
	IMG_OBJ obj;
	IMG_INT i, j, k;
	int search_status = searchNoErr;
	CVisMemPool pool;
	IMG_REAL rScoreMargin;
	ALIGN_SEARCH_OPTION *stOption = m_SearchOption.GetSearchPara();
	IMG_INT pcount_before, pcount_after;

	if (stAlignExData.uwDebug & 256)
	{
		char msg[MAX_FILE_NAME];
		_snprintf_s(msg, sizeof(msg), "Enter_level_%d", level);
		stAlignExData.pstClock->Click(msg);
	}
	if (stAlignExData.uwDebug & 4)
	{
		char objfile[FILENAME_MAX_LENGTH], *p;
		IMG_UBBUF ubbSrc;

		ubbSrc = stAlignExData.ubbufReduction[stAlignExData.current_level];
		//ubbSrc.ptr = stAlignExData.pPyrImage[stAlignExData.current_level];
		//ubbSrc.size.width = stAlignExData.ubbufReduction[stAlignExData.current_level].size.width;
		//ubbSrc.size.height = stAlignExData.ubbufReduction[stAlignExData.current_level].size.height;
		//ubbSrc.linestep = ubbSrc.size.width;
		if(ubbSrc.size.width > JPG_SIZE_LIMITATION || ubbSrc.size.height > JPG_SIZE_LIMITATION)
			_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Level%d_ReducedSrc.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level);
		else
			_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Level%d_ReducedSrc.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level);

		CVisImage sub_src(ubbSrc);
		sub_src.WriteImage(objfile);

		writeLog("Level %d", level);
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("Level %d source image", level);
		p = strrchr(objfile, '\\')-10;
		HL_InsertImage(m_pHtmlLog, p);
		writeLog("\n");
	}
	if (level == 0)
	{
		if (m_AlignResult.Size() > 0)
		{
			if (m_AlignResult.m_match)
			{
				m_AlignResult.m_match->Free();
				pool.PFree(m_AlignResult.m_match);
			}
			m_AlignResult.m_match = (CVisAlignResultPointMatch *)CVisMemPool::PMalloc(sizeof(CVisAlignResultPointMatch));
			VALIDATE_MALLOC(m_AlignResult.m_match);
			new(m_AlignResult.m_match)CVisAlignResultPointMatch();
			m_AlignResult.m_match->Allocate(m_AlignRecord->GetRecord()->ptr->uwNumOfSpAFeature, m_AlignResult.Size());
			m_AlignResult.m_match->reduction = stAlignExData.highest_level;
		}
	}
	for(i = 0; i<m_AlignResult.Size(); i++)
	{
		if (stAlignExData.uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "Obj%d_start", obj.uwID);
			stAlignExData.pstClock->Click(msg);
		}
		pool.Push();
		obj = m_AlignResult.Result()->ptr[i];
		if (stAlignExData.uwDebug & 1)
		{
			writeLog("---------ID:%d------------\n", obj.uwID);
		}
		if (stAlignExData.uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "Start_Obj_%04d_backmatch", obj.uwID);
			stAlignExData.pstClock->Click(msg);
		}
		stAlignExData.pstObj = &obj;
		stAlignExData.Bkmode_one2one(IMG_FALSE);

		pcount_before = pool.GetPushPopCount();
		stAlignExData.backMatchInit(stAlignExData.pstTable, level, &obj, pool);
		//stAlignExData.iterInit(m_AlignRecord->GetRecord()->ptr, level, &obj);
		if (back_match(stAlignExData) != 0)
		{
			search_status = backMatchErr;
			pool.Pop();
			goto exit;
		}
		pcount_after = pool.GetPushPopCount();
		if (pcount_after != pcount_before)
			THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		if (stAlignExData.uwDebug & 256)
		{
			stAlignExData.pstClock->Click("backmatch");
		}

		if (stAlignExData.backmatch_info.matched_edge_num < 5)
		{
			if (stAlignExData.uwDebug & 1)
			{
				writeLog("Matched point %d less than 5, object rejected\n", stAlignExData.backmatch_info.matched_edge_num);
			}
			m_AlignResult.Result()->ptr[i].rMatched = 0;
			search_status = backMatchErr;
			pool.Pop();
			continue;
		}
		//stAlignExData.Num_matchedPoints(num_matchedPoints);
		//fitting
		iterationfit(stAlignExData);
		if (stAlignExData.uwDebug & 256)
		{
			stAlignExData.pstClock->Click("fitting");
		}
		pcount_after = pool.GetPushPopCount();
		if (pcount_after != pcount_before)
			THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		if (ALIGN_DIST(obj.rco, m_AlignResult.Result()->ptr[i].rco) > 5 * (stOption->rElasticity + 5))
		{
			if (stAlignExData.uwDebug & 1)
			{
				writeLog("Fitting object failed, object reject\n", stAlignExData.backmatch_info.matched_edge_num);
			}
			m_AlignResult.Result()->ptr[i].rMatched = 0;
			search_status = filterErr;
			pool.Pop();
			continue;
		}
		if (level == 0)
		{
			//one to one match

			stAlignExData.Bkmode_one2one(IMG_TRUE);
			stAlignExData.backMatchInit(stAlignExData.pstTable, level, &obj, pool);
			if (back_match(stAlignExData) != 0)
			{
				search_status = backMatchErr;
				pool.Pop();
				goto exit;
			}
			pcount_after = pool.GetPushPopCount();
			if (pcount_after != pcount_before)
				THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
			if (stAlignExData.uwDebug & 256)
			{
				stAlignExData.pstClock->Click("2nd_backmatch");
			}			
			if (stAlignExData.backmatch_info.matched_edge_num < 5)
			{
				obj.rMatched = 0;
				m_AlignResult.Result()->ptr[i] = obj;
				search_status = backMatchErr;
				pool.Pop();
				continue;
			}
			if (stAlignExData.uwDebug & 256)
			{
				stAlignExData.pstClock->Click("Start_2nd_fitting");
			}
			iterationfit(stAlignExData);
			if (stAlignExData.uwDebug & 256)
			{
				stAlignExData.pstClock->Click("2nd_fitting");
			}
			if (stAlignExData.uwDebug & 1)
			{
				// test result//////////////////////////////
				//cout << "scale = " << obj.scale << endl;
				//cout << "rotation = " << obj.rotation << endl;
				//cout << "dstX = " << obj.rco.x << endl;
				//cout << "dstY = " << obj.rco.y << endl;
				//cout << "fitting score = " << obj.rLikeScore << endl;
				//cout << "matching score = " << obj.rMatched << endl;
				//cout << endl;
			}
			for (j = 0; j < stAlignExData.backmatch_info.matched_pair_num; j++)
			{
				EDGE_INFORMATION trans, edge = { 0 };
				trans.coPos.x = trans.rcoPos.x = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.x;
				trans.coPos.y = trans.rcoPos.y = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.y;
				trans.angle = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat_angle;
				if (stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge_num > 0)
				{
					m_AlignResult.m_match->AddPair(obj.uwID, stAlignExData.backmatch_info.backmatch_pairs[j].origin_feature, &trans, stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge);
				}
				else
				{
					m_AlignResult.m_match->AddPair(obj.uwID, stAlignExData.backmatch_info.backmatch_pairs[j].origin_feature, &trans, &edge);
				}
			}
			pcount_after = pool.GetPushPopCount();
			if (pcount_after != pcount_before)
				THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		}
		//Align_Translate_RCOORD_By_Obj(stAlignExData.pstTable->arcoObjCorner, stAlignExData.pstTable->uwNumOfObjCorner, &obj, obj.arcoObjCorner);
		//Align_Translate_RCOORD_By_Obj(stAlignExData.pstTable->arcoROICorner, 4, &obj, obj.arcoROICorner);
		m_AlignResult.Result()->ptr[i] = obj;
		if (stAlignExData.uwDebug & 4)
		{
			char objfile[FILENAME_MAX_LENGTH], *p;
			IMG_UBBUF ubbSrc, ubbC[3], ubbMask;

			IMG_INT cross_size = level > 2 ? 7 : 7 * (1 << (2 - level));

			ubbSrc = stAlignExData.ubbufReduction[level+stAlignExData.highest_level];
			ubbMask = stAlignExData.ubbufMaskReduction[level + stAlignExData.highest_level];
			//ubbSrc.ptr = stAlignExData.pPyrImage[level+stAlignExData.highest_level];
			//ubbSrc.size.width = stAlignExData.ubbufReduction[level + stAlignExData.highest_level].size.width;
			//ubbSrc.size.height = stAlignExData.ubbufReduction[level + stAlignExData.highest_level].size.height;
			//ubbSrc.linestep = ubbSrc.size.width;
			if(ubbSrc.size.width > JPG_SIZE_LIMITATION || ubbSrc.size.height > JPG_SIZE_LIMITATION)
				_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Search_obj_%d_%d.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level, obj.uwID);
			else
				_snprintf(objfile, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_Search_obj_%d_%d.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, level, obj.uwID);

			//Align_DrawObjInImage(&ubbSrc, &obj, stAlignExData.pstTable, level > 2 ? 2 : 1, cross_size, objfile);
			CVisImage img;
			if (stAlignExData.pubMask)
			{
				CVisImage mask(ubbMask), src(ubbSrc), mask1({ ubbMask.size.width, ubbMask.size.height }, 1);
				mask1.Sub(mask);
				mask1.Mul_C(40);
				mask1.Add(src);
				mask1.GetImage(&ubbMask);
				src.GetImage(&ubbSrc);
				ubbC[0] = ubbMask;
				ubbC[1] = ubbSrc;
				ubbC[2] = ubbSrc;
				img.SetImage(ubbC);
			}
			else
			{
				ubbC[0] = ubbSrc;
				ubbC[1] = ubbSrc;
				ubbC[2] = ubbSrc;
				img.SetImage(ubbC);
			}
			img.GetImage(ubbC);
			EDGE_INFORMATION trans;
			IMG_UINT ulMatched;
			for (j = 0; j < stAlignExData.backmatch_info.matched_pair_num; j++)
			{
				trans.rcoPos.x = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.x;
				trans.rcoPos.y = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.y;
				for (k = 0; k < stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge_num; k++)
				{
					Align_DrawTranslatedFeatureInImage(img, stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge + k, 1, COLORS::Green, cross_size, 0);
					img.DrawLine(stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge[k].rcoPos, trans.rcoPos, COLORS::Yellow);
				}
			}
			for (j = 0; j < stAlignExData.backmatch_info.matched_pair_num; j++)
			{
				trans.rcoPos.x = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.x;
				trans.rcoPos.y = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat.y;
				trans.angle = stAlignExData.backmatch_info.backmatch_pairs[j].translated_feat_angle;
				if(stAlignExData.backmatch_info.backmatch_pairs[j].matched_edge_num > 0)
					Align_DrawTranslatedFeatureInImage(img, &trans, 1, COLORS::Cyan, cross_size / 2.0f, 0);
				else
					Align_DrawTranslatedFeatureInImage(img, &trans, 1, COLORS::Red, cross_size / 2.0f, 0);
			}
			CVisImage subImg;
			IMG_COORD coUL;
			IMG_SIZE szSub;
			coUL.x = stAlignExData.pstObj->rco.x - stAlignExData.pstTable->szTemplate.width;
			coUL.y = stAlignExData.pstObj->rco.y - stAlignExData.pstTable->szTemplate.height;
			if (coUL.x < 0)coUL.x = 0;
			if (coUL.y < 0)coUL.y = 0;
			szSub.width = stAlignExData.pstTable->szTemplate.width * 2;
			if (coUL.x + szSub.width >= img.Width())szSub.width = img.Width() - coUL.x - 1;
			szSub.height = stAlignExData.pstTable->szTemplate.height * 2;
			if (coUL.y + szSub.height >= img.Height())szSub.height = img.Height() - coUL.y - 1;
			img.SubImage(coUL, szSub, subImg);
			subImg.WriteImage(objfile);
			p = strrchr(objfile, '\\')-10;
			HL_InsertImage(m_pHtmlLog, p);
			writeLog("\n");
		}
		pool.Pop();
		if (stAlignExData.uwDebug & 256)
		{
			stAlignExData.pstClock->Click("End_obj");
		}
	}
	pcount_before = pool.GetPushPopCount();
	if (stAlignExData.uwDebug & 1)
	{
		char str[20];
		_snprintf_s(str, sizeof(str), "Level %d", level);
		// test result//////////////////////////////
		ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
		writeLog("Total Object Num %d at Level %d\n", result->size, level);
		Align_OutputTableInHTML(m_pHtmlLog, result, str);
	}



	switch (level)
	{
	case 0:
		rScoreMargin = 0.95;
		break;
	case 1:
		rScoreMargin = 0.85;
		break;
	default:
		rScoreMargin = 0.7;
		break;
	}
	m_AlignResult.RejectByMatchScore(stOption->rAcceptLevel, rScoreMargin);
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object score rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Matching Score");
	}
	if(!stAlignExData.pstTable->ubSpARotationIndependent)
		m_AlignResult.RejectByAngle(stOption->rMaxAngle - stAlignExData.pstRec->rOrientation, stOption->rMinAngle - stAlignExData.pstRec->rOrientation, stOption->rRepeatingAngle, rScoreMargin);
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object angle rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Angle Range");
	}
	if (!stAlignExData.pstTable->ubSpAScaleIndependent)
		m_AlignResult.RejectByScale(stOption->rMaxScale, stOption->rMinScale, rScoreMargin);
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object scale rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Scale Range");
	}

	if (stAlignExData.uwDebug & 256)
	{
		stAlignExData.pstClock->Click("Score_rejection");
	}
	if (stOption->ubOverlap) rScoreMargin = 0.2;
	if (stAlignExData.pstTable->ubSpARotationIndependent || stOption->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
	{
		m_AlignResult.RejectCircleObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, stOption->rOverlapScaleMargin, rScoreMargin, level);
	}
	else
	{
		m_AlignResult.RejectObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, stOption->rOverlapScaleMargin, rScoreMargin, level);
	}
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "After object overlap rejection\n");
		Align_OutputTableInHTML(m_pHtmlLog, m_AlignResult.Result(), "After Reject By Overlap");
	}
	if (stAlignExData.uwDebug & 256)
	{
		stAlignExData.pstClock->Click("Overlap_rejection");
	}
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
exit:
	if (stAlignExData.uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog, "Level %d searchStatus: %s \n", level, getErrorMessage(search_status));
	}
	return;
}


CVisAlignSearchInterData::CVisAlignSearchInterData()
{
	CVisMemPool pool;
	pEdAngle = { 0 };
	pEdDstMag = { 0 };
	pedgeArray = nullptr;
	pEdDstRoiE = { 0 };
	//pPyrStruct = nullptr;
	//pPyrImage = nullptr;
	uwDebug = 0;
	memset(ubbufReduction, 0, sizeof(ubbufReduction));
	pubMask = nullptr;
}

CVisAlignSearchInterData::~CVisAlignSearchInterData()
{
	if (pEdDstMag.ptr)
	{
		CVisMemPool::PFree(pEdDstMag.ptr);
		pEdDstMag.ptr = nullptr;
	}
	if (pEdAngle.ptr)
	{
		CVisMemPool::PFree(pEdAngle.ptr);
		pEdAngle.ptr = nullptr;
	}
	if (pedgeArray)
	{
		CVisMemPool::PFree(pedgeArray);
		pedgeArray = nullptr;
	}
	if(pEdDstRoiE.ptr)
	{
		CVisMemPool::PFree(pEdDstRoiE.ptr);
		pEdDstRoiE.ptr = nullptr;
	}
	/*
	if (pPyrStruct)
	{
		for (IMG_INT i = 1; i <= pPyrStruct->level; i++)
		{
			if (pPyrImage[i])
			{
				CVisMemPool::PFree(pPyrImage[i]);
				pPyrImage[i] = nullptr;
			}
		}
		CVisMemPool::PFree(pPyrStruct);
		pPyrStruct = nullptr;
	}
	*/
}
IMG_INT saveImg(IMG_REAL *pImg, IMG_SIZE roiSize, char *fileName)
{
	//exImg = image;
	CVisImage exImg;

	VIS_IMAGE_INFO tempInfo;
	//image.GetImageInfo(tempInfo);
	tempInfo.width = roiSize.width;
	tempInfo.height = roiSize.height;
	tempInfo.byte_per_pixel = sizeof(IMG_REAL);
	tempInfo.pixel_type = VIS_IMG_REAL;
	tempInfo.page_num = 1;
	tempInfo.img_type = TIFF_TYPE;
	tempInfo.channel = VIS_IMG_GRAY;
	//tempInfo.platte_size = 0;
	tempInfo.sample_per_pixel = 1;
	tempInfo.linestep = roiSize.width* sizeof(IMG_REAL);
	exImg.SetImageInfo(tempInfo);


	void *ppImage = pImg;
	assert(ppImage != NULL);

	exImg.SetImage(&ppImage);
	exImg.WriteImage(fileName);

	return 0;
}
IMG_INT saveImg(IMG_WORD *pImg, IMG_SIZE roiSize, char *fileName)
{
	//exImg = image;
	CVisImage exImg;

	VIS_IMAGE_INFO tempInfo;
	//image.GetImageInfo(tempInfo);
	tempInfo.width = roiSize.width;
	tempInfo.height = roiSize.height;
	tempInfo.byte_per_pixel = sizeof(IMG_WORD);
	tempInfo.pixel_type = VIS_IMG_SHORT16;
	tempInfo.page_num = 1;
	tempInfo.img_type = TIFF_TYPE;
	tempInfo.channel = VIS_IMG_GRAY;
	//tempInfo.platte_size = 0;
	tempInfo.sample_per_pixel = 1;
	tempInfo.linestep = roiSize.width* sizeof(IMG_WORD);

	exImg.SetImageInfo(tempInfo);

	void *ppImage = pImg;
	assert(ppImage != NULL);

	exImg.SetImage(&ppImage);
	exImg.WriteImage(fileName);

	return 0;
}
IMG_INT saveImg(IMG_UBYTE *pImg,IMG_SIZE roiSize,char *fileName)
{
	CVisImage exImg;
	//exImg = image;
	VIS_IMAGE_INFO tempInfo;
	//image.GetImageInfo(tempInfo);
	tempInfo.width = roiSize.width;
	tempInfo.height = roiSize.height;
	tempInfo.byte_per_pixel = 1;
	tempInfo.page_num = 1;
	tempInfo.channel = VIS_IMG_GRAY;
	tempInfo.pixel_type = VIS_IMG_UINT8;
	tempInfo.img_type = BMP_TYPE;
	tempInfo.linestep = roiSize.width;

	//tempInfo.platte_size = 0;

	exImg.SetImageInfo(tempInfo);

	void *ppImage = pImg;
	assert(ppImage != NULL);

	exImg.SetImage(&ppImage);
	exImg.WriteImage(fileName);

	return 0;
}

/**
* @brief <B>Description:</B><br>This function is to init vars in gaussian filter.
*/
IMG_VVOID CVisAlignSearchInterData::preprocessInit(CVisMemPool &pool)
{
	IMG_WORD wProc = pstRec->wPreprocessType;
	//IMG_INT kernel_size = pstRec->wPreprocessKSize;// m_LearnOption.LearnInput().wPreprocKernelSize;
	//IMG_REAL sigma = pstRec->rPreprocessGaussianSigma;// m_LearnOption.LearnInput().ulPreprocParam;
	//if (kernel_size != 0 && sigma > 0)
	if(wProc != 0)
	{
		ubBufGaussian.ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE) * ubBufSrc.size.height * (size_t)ubBufSrc.size.width);
		ubBufGaussian.size = ubBufSrc.size;
		ubBufGaussian.linestep = ubBufSrc.size.width;
	}
	else
	{
		ubBufGaussian = ubBufSrc;
	}
}

/**
* @brief <B>Description:</B><br>This function is to init vars in pyramid.
*/
IMG_VVOID CVisAlignSearchInterData::pyramidInit(CVisMemPool &pool)
{
	IMG_INT level = pstRec->ulHighestLayer+pstRec->ulNumOfLayer;// m_LearnOption.LearnInput().ulReduction;//m_SearchOption.Pyramid_level();
	IMG_UBYTE ubAliasing;
	//pyramid
	ubbufReduction[0] = ubBufGaussian;
	if(pubMask)ubbufMaskReduction[0] = *pubMask;
	else memset(ubbufMaskReduction, 0, sizeof(ubbufMaskReduction));
	for(int i = 1; i<= level; i++)
	{
		if(i >= pstRec->uwAntiAliasingLevel)
			ubAliasing = IMG_TRUE;
		else
			ubAliasing = IMG_FALSE;
		ubbufReduction[i].size = { (IMG_INT)(ceil(ubbufReduction[i-1].size.width / 2.0f)), (IMG_INT)(ceil(ubbufReduction[i - 1].size.height / 2.0f))};
		ubbufReduction[i].ptr = (IMG_UBYTE *)pool.Malloc((size_t)ubbufReduction[i].size.width*ubbufReduction[i].size.height);
		VALIDATE_MALLOC(ubbufReduction[i].ptr);
		ubbufReduction[i].linestep = ubbufReduction[i].size.width;

		Align_ImageReduction3(ubbufReduction+i-1, ubbufReduction+i, ubAliasing, pool);
		if (pubMask)
		{
			ubbufMaskReduction[i].size = { (IMG_INT)(ceil(ubbufMaskReduction[i - 1].size.width / 2.0f)), (IMG_INT)(ceil(ubbufMaskReduction[i - 1].size.height / 2.0f)) };
			ubbufMaskReduction[i].ptr = (IMG_UBYTE *)pool.Malloc((size_t)ubbufMaskReduction[i].size.width*ubbufMaskReduction[i].size.height);
			VALIDATE_MALLOC(ubbufMaskReduction[i].ptr);
			ubbufMaskReduction[i].linestep = ubbufMaskReduction[i].size.width;

			Align_ImageReduction3(ubbufMaskReduction + i - 1, ubbufMaskReduction + i, IMG_FALSE, pool);
		}
	}
	//pPyrSrc = ubBufGaussian.ptr;
	//pyrRoiSize = { ubBufGaussian.size.width,ubBufGaussian.size.height };
	//pPyrStruct = NULL;
	//pPyrImage =	NULL;

}

/**
* @brief <B>Description:</B><br>This function is to init vars in edge detection.
*/
IMG_VVOID CVisAlignSearchInterData::edgeDetectInit(int _botLev)
{
	CVisMemPool pool;
	ubbufEdSrc = ubbufReduction[_botLev];
	if (pubMask)		pubbufEdMask = ubbufMaskReduction+_botLev;
	else				pubbufEdMask = nullptr;
	//ubbufEdSrc.ptr = pPyrImage[_botLev];
	//ubbufEdSrc.size = { ubbufReduction[_botLev].size.width,ubbufReduction[_botLev].size.height };
	//ubbufEdSrc.linestep = ubbufEdSrc.size.width;

	pEdDstMag.ptr = (IMG_WORD*)pool.PMalloc(sizeof(IMG_WBUF)*ubbufReduction[_botLev].size.width*(size_t)ubbufReduction[_botLev].size.height);
	VALIDATE_MALLOC(pEdDstMag.ptr);
	pEdDstMag.size = { ubbufReduction[_botLev].size.width,ubbufReduction[_botLev].size.height };
	pEdDstMag.linestep = ubbufEdSrc.size.width;

	pEdDstRoiE.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*ubbufReduction[_botLev].size.width*(size_t)ubbufReduction[_botLev].size.height);
	VALIDATE_MALLOC(pEdDstRoiE.ptr);
	pEdDstRoiE.size = { ubbufReduction[_botLev].size.width,ubbufReduction[_botLev].size.height };
	pEdDstRoiE.linestep = ubbufEdSrc.size.width;	VALIDATE_MALLOC(pEdDstRoiE.ptr);

	pEdAngle.ptr = (IMG_REAL *)pool.PMalloc(sizeof(IMG_REAL)*ubbufReduction[_botLev].size.width*(size_t)ubbufReduction[_botLev].size.height);
	VALIDATE_MALLOC(pEdDstRoiE.ptr);
	pEdAngle.size = { ubbufReduction[_botLev].size.width,ubbufReduction[_botLev].size.height };
	pEdAngle.linestep = ubbufEdSrc.size.width;
	pedgeArray = NULL;
	edgeNum = 0;
}

/**
* @brief <B>Description:</B><br>This function is to init vars in backmatch.
*/
IMG_VVOID CVisAlignSearchInterData::backMatchInit(CVisAlignRecordTable *pTable,int _level, IMG_OBJ *pstObj, CVisMemPool &pool)
{
	
	num_template = (pTable)->uwNumOfSpAFeature;//特征点数目	
	backmatch_info.backmatch_pairs = (BACK_MATCH_PAIR *)pool.Malloc(sizeof(BACK_MATCH_PAIR)*num_template);
	backmatch_info.matched_edge_num = 0;
	backmatch_info.matched_pair_num = num_template;

	//num_feat = 0;
	num_matchedPoints = 0;
														  
	offset.x = pstObj->rco.x /*- (pTable + _level)->rcoRef.x*/;
	offset.y = pstObj->rco.y /*- (pTable + _level)->rcoRef.y*/;


}

/**
* @brief <B>Description:</B><br>This function is to init vars in iteration.
*/
IMG_VVOID CVisAlignSearchInterData::iterInit(CVisAlignRecordTable *pTable, int level_i, IMG_OBJ * pstObj)
{
	CVisMemPool pool;

	offset.x = pstObj->rco.x; offset.y = pstObj->rco.y;
	offset.x *= 2; offset.y *= 2;

	//num_template = 100 - 30 * level_i;//(100) / (1 + level_i);		//???????????
	num_template = pTable->uwNumOfSpAFeature;



	IMG_LREAL scale = pstObj->scale;
}



CVisAlignResult::CVisAlignResult()
{
	m_result = (ALIGN_SRCH_RESULT *)CVisMemPool::PMalloc(sizeof(ALIGN_SRCH_RESULT));
	VALIDATE_MALLOC(m_result);
	m_result->maxsize = 4000;
	m_result->size = 0;
	m_result->mode = 0;
	m_result->ptr = (IMG_OBJ*)CVisMemPool::PMalloc(sizeof(IMG_OBJ) * m_result->maxsize);
	VALIDATE_MALLOC(m_result->ptr);
	memset(m_result->ptr, 0, sizeof(IMG_OBJ)*m_result->maxsize);
	m_match = nullptr;


}

CVisAlignResult::~CVisAlignResult()
{
	CVisMemPool::PFree(m_result->ptr);
	m_result->maxsize = 0;
	m_result->size = 0;;
	if (m_match)
	{
		m_match->Free();
		CVisMemPool::PFree(m_match);
	}
	CVisMemPool::PFree(m_result);

}
IMG_BOOL CVisAlignResult::SetMaxResultNum(IMG_UINT size)
{
	if (m_result->maxsize > size)
	{
		m_result->maxsize = size;
		if (m_result->size > size)
		{
			m_result->size = size;
		}
	}
	else if (m_result->maxsize < size)
	{
		IMG_OBJ *newptr = (IMG_OBJ *)CVisMemPool::PMalloc(sizeof(IMG_OBJ) * size);
		VALIDATE_MALLOC(newptr);
		if (newptr == nullptr)return false;
		if (m_result->size > 0)
			memcpy(newptr, m_result->ptr, sizeof(IMG_OBJ)*m_result->size);
		CVisMemPool::PFree(m_result->ptr);
		m_result->ptr = newptr;
		m_result->maxsize = size;
	}
	return true;
}
int	ALIGN_Comp_OBJ_By_Score_Fit(void const *pvPtr1, void const *pvPtr2) 
{
	IMG_REAL
		s1 = ((IMG_OBJ *)pvPtr1)->rLikeScore,
		s2 = ((IMG_OBJ *)pvPtr2)->rLikeScore;

	if (s1 > s2)
		return -1;
	if (s1 < s2)
		return 1;
	return 0;
}
void CVisAlignResult::SortByFittingScore()
{
	qsort(m_result->ptr, m_result->size, sizeof(IMG_OBJ), ALIGN_Comp_OBJ_By_Score_Fit);  //lint !e64
}
int	ALIGN_Comp_OBJ_By_Score_A(void const *pvPtr1, void const *pvPtr2);

void CVisAlignResult::SortByMatchScore()
{
	qsort(m_result->ptr, m_result->size, sizeof(IMG_OBJ), ALIGN_Comp_OBJ_By_Score_A);  //lint !e64
}
thread_local IMG_REAL x_diff = 0;
void CVisAlignResult::SortByPosition(POS_SORT_METHOD method)
{
	if (m_result->size == 0)return;
	CVisMemPool pool;
	switch (method)
	{
	case SORT_X:
		qsort(m_result->ptr, m_result->size, sizeof(IMG_OBJ), [](void const *p1, void const *p2)->int
		{
			//ascend x position
			IMG_OBJ const *obj1 = static_cast<const IMG_OBJ *>(p1), *obj2 = static_cast<IMG_OBJ const *>(p2);
			if (obj1->rco.x > obj2->rco.x)
				return 1;
			else
				return -1;
		}
		);
		break;
	case SORT_Y:
		qsort(m_result->ptr, m_result->size, sizeof(IMG_OBJ), [](void const *p1, void const *p2)->int
		{
			//ascend y position
			IMG_OBJ const *obj1 = static_cast<const IMG_OBJ *>(p1), *obj2 = static_cast<IMG_OBJ const *>(p2);
			if (obj1->rco.y > obj2->rco.y)
				return 1;
			else
				return -1;
		}
		);
		break;
	case SORT_Z:
	{
		int m = 0;
		qsort(m_result->ptr, m_result->size, sizeof(IMG_OBJ), [](void const *p1, void const *p2)->int
		{
			//ascend y position
			IMG_OBJ const *obj1 = static_cast<const IMG_OBJ *>(p1), *obj2 = static_cast<IMG_OBJ const *>(p2);
			if (obj1->rco.y > obj2->rco.y)
				return 1;
			else
				return -1;
		}
		);
		IMG_REAL *y_diff = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		IMG_REAL *y_diff2 = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		VALIDATE_MALLOC(y_diff);
		VALIDATE_MALLOC(y_diff2);
		for (size_t i = 0; i < m_result->size - 1; i++)y_diff[i] = m_result->ptr[i+1].rco.y - m_result->ptr[i].rco.y;
		memcpy(y_diff2, y_diff, sizeof(IMG_REAL)*m_result->size);
		qsort(y_diff, m_result->size - 1, sizeof(IMG_REAL), [](void const *p1, void const *p2)->int
		{
			//descend y difference
			IMG_REAL const *obj1 = static_cast<const IMG_REAL *>(p1), *obj2 = static_cast<IMG_REAL const *>(p2);
			if (*obj1 > *obj2)
				return -1;
			else
				return 1;
		});
		y_diff2[m_result->size - 1] = y_diff[0];
		IMG_REAL threshold = (y_diff[0] + y_diff[m_result->size >> 1]) / 4.0f;
		for (size_t i = 0, j = 0; i < m_result->size; i++)
		{
			if (y_diff2[i] > threshold)
			{
				qsort(m_result->ptr + j, i-j+1, sizeof(IMG_OBJ), [](void const *p1, void const *p2)->int
				{
					//descend x difference
					IMG_OBJ const *obj1 = static_cast<const IMG_OBJ *>(p1), *obj2 = static_cast<IMG_OBJ const *>(p2);
					if (obj1->rco.x > obj2->rco.x)
						return 1;
					else
						return -1;
				});
				j = i+1;
			}
		}
		break;

	}
	case SORT_N:
	{
		int m = 0;
		qsort(m_result->ptr, m_result->size, sizeof(IMG_OBJ), [](void const *p1, void const *p2)->int
		{
			//ascend x position
			IMG_OBJ const *obj1 = static_cast<const IMG_OBJ *>(p1), *obj2 = static_cast<IMG_OBJ const *>(p2);
			if (obj1->rco.x > obj2->rco.x)
				return 1;
			else
				return -1;
		}
		);
		IMG_REAL *x_diff = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		IMG_REAL *x_diff2 = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		VALIDATE_MALLOC(x_diff);
		VALIDATE_MALLOC(x_diff2);
		for (size_t i = 0; i < m_result->size - 1; i++)x_diff[i] = m_result->ptr[i + 1].rco.x - m_result->ptr[i].rco.x;
		memcpy(x_diff2, x_diff, m_result->size*sizeof(IMG_REAL));
		qsort(x_diff, m_result->size - 1, sizeof(IMG_REAL), [](void const *p1, void const *p2)->int
		{
			//descend x difference
			IMG_REAL const *obj1 = static_cast<const IMG_REAL *>(p1), *obj2 = static_cast<IMG_REAL const *>(p2);
			if (*obj1 > *obj2)
				return -1;
			else
				return 1;
		});
		x_diff2[m_result->size - 1] = x_diff[0];

		IMG_REAL threshold = (x_diff[0] + x_diff[m_result->size >> 1]) / 4.0f;
		for (size_t i = 0, j = 0; i < m_result->size; i++)
		{
			if (x_diff2[i] > threshold)
			{
				qsort(m_result->ptr + j, i - j+1, sizeof(IMG_OBJ), [](void const *p1, void const *p2)->int
				{
					//descend y difference
					IMG_OBJ const *obj1 = static_cast<const IMG_OBJ *>(p1), *obj2 = static_cast<IMG_OBJ const *>(p2);
					if (obj1->rco.y > obj2->rco.y)
						return 1;
					else
						return -1;
				});
				j = i+1;
			}
		}
		break;

	}

	case SORT_AUTO:
	{
		// mean direction
		IMG_REAL *obj_direction = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		VALIDATE_MALLOC(obj_direction);

		for (int i = 0; i < m_result->size; ++i)  obj_direction[i] = m_result->ptr[i].rotation;

		IMG_REAL dir_mean = 0, dir_stddev = 0;
		auto sts = ippsMeanStdDev_32f(obj_direction, m_result->size, &dir_mean, &dir_stddev, IppHintAlgorithm::ippAlgHintAccurate);
		if (sts != ippStsNoErr) {
			SortByPosition(SORT_Z);
			break;
		}
		IMG_REAL dir_sum = 0.0;
		IMG_INT dir_num = 0;
		for (int i = 0; i < m_result->size; ++i) {
			if (fabs(obj_direction[i] - dir_mean) > dir_stddev) continue;
			dir_sum += obj_direction[i];
			dir_num++;
		}
		
		if (dir_num > 0) dir_mean = dir_sum / dir_num;

		IMG_REAL dircos = cos(dir_mean*D2R);
		IMG_REAL dirsin = sin(dir_mean*D2R);

		auto trans_x_f = [&](const IMG_OBJ& obj) {
			return obj.rco.x*dircos + obj.rco.y*dirsin;
		};
		auto trans_y_f = [&](const IMG_OBJ& obj) {
			return -obj.rco.x*dirsin + obj.rco.y*dircos;
		};

		std::sort(m_result->ptr, m_result->ptr + m_result->size, [&](const IMG_OBJ& obj1, const IMG_OBJ& obj2) {
			return trans_y_f(obj1) < trans_y_f(obj2);
		});

		IMG_REAL *y_diff = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		IMG_REAL *y_diff2 = (IMG_REAL *)pool.Malloc(sizeof(IMG_REAL)*m_result->size);
		VALIDATE_MALLOC(y_diff);
		VALIDATE_MALLOC(y_diff2);
		for (size_t i = 0; i < m_result->size - 1; i++) {
			y_diff[i] = trans_y_f(m_result->ptr[i + 1]) - trans_y_f(m_result->ptr[i]);
		}

		memcpy(y_diff2, y_diff, sizeof(IMG_REAL)*m_result->size);
		
		qsort(y_diff, m_result->size - 1, sizeof(IMG_REAL), [](void const *p1, void const *p2)->int
		{
			//descend y difference
			IMG_REAL const *obj1 = static_cast<const IMG_REAL *>(p1), *obj2 = static_cast<IMG_REAL const *>(p2);
			if (*obj1 > *obj2)
				return -1;
			else
				return 1;
		});
		y_diff2[m_result->size - 1] = y_diff[0];
		IMG_REAL threshold = (y_diff[0] + y_diff[m_result->size >> 1]) / 4.0f;

		for (size_t i = 0, j = 0; i < m_result->size; i++)
		{
			if (y_diff2[i] > threshold)
			{
				std::sort(m_result->ptr + j, m_result->ptr + i + 1, [&](const IMG_OBJ& obj1, const IMG_OBJ& obj2) {
					return trans_x_f(obj1) < trans_x_f(obj2);
				});
				j = i + 1;
			}
		}


		//针对只有一行的工件特殊处理
		bool doXSort = true;
		IMG_REAL yDiff_mean = 0, yDiff_stddev = 0;
		sts = ippsMeanStdDev_32f(y_diff, m_result->size - 1, &yDiff_mean, &yDiff_stddev, IppHintAlgorithm::ippAlgHintAccurate);
		FILE *fp = fopen("zmzmjj.txt", "at");
		if (fp)
		{
			fprintf(fp, "%f %f", yDiff_mean,yDiff_stddev);
		}

		for (int i = 0; i < m_result->size - 1; ++i) {
			fprintf(fp, "%f", y_diff[i]);

			if (fabs(y_diff[i] - yDiff_mean) > yDiff_stddev)
			{
				doXSort = false;
				break;
			}
		}
		fclose(fp);
		if (doXSort)
		{
			SortByPosition(SORT_X);
		}

		break;
	}

	default:
		break;
	}

}

IMG_VVOID CVisAlignResult::Join(CVisAlignResult *another_table)
{
	for (IMG_INT i = 0; i < another_table->Size(); i++)
	{
		m_result->ptr[m_result->size] = another_table->m_result->ptr[i];
		m_result->size++;
		if (m_result->size == m_result->maxsize)THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	}
	if (another_table->Size()>0&&m_match != nullptr)
	{
		m_match->Join(another_table->m_match);
	}
}
void CVisAlignResult::PrintTable(FILE *fp)
{
	if (fp != nullptr)
	{
		fprintf(fp, "ID	x	y	rotation	scale	MatchScore	FitScore\n");
		for (int i = 0; i < m_result->size; i++)
		{
			IMG_OBJ *pstObj = m_result->ptr + i;
			fprintf(fp, "<%d>\t%.3f\t%.3f\t%.6f\t%.6f\t%.6f\t%.6f\n", pstObj->uwID, pstObj->rco.x, pstObj->rco.y, pstObj->rotation, pstObj->scale, pstObj->rMatched, pstObj->rLikeScore);
		}
	}
}
void CVisAlignResult::PrintTableInHTML(struct _HTMLLOGGING *pstLog, IMG_CHAR *title)
{
	Align_OutputTableInHTML(pstLog, m_result, title);
}

IMG_UINT CVisAlignResult::Size()
{
	return m_result->size;
}
void CVisAlignResult::ScaleTable(IMG_REAL scale)
{
	if (scale > 0.1 && scale < 10)
	{
		IMG_INT i;
		IMG_OBJ *pstObj;
		for (i = 0; i < m_result->size; i++)
		{
			pstObj = m_result->ptr + i;
			pstObj->rco.x *= scale;
			pstObj->rco.y *= scale;
		}
		if (m_result->size == 0)
		{
			pstObj = m_result->ptr;
			pstObj->rco.x *= scale;
			pstObj->rco.y *= scale;
		}
		return;

	}
	else
	{
		THROW_VIS_EXCEPTION(ALIGN_ERR_INVALID_ARG);
	}
}
void CVisAlignResult::OffsetTable(IMG_RCOORD rcoOffset, IMG_UINT level)
{
	IMG_INT i;
	IMG_OBJ *pstObj;
	IMG_FEATUREPT *feature;
	EDGE_INFORMATION *edge_info, *trans_feat;
	IMG_UINT matched;
	IMG_REAL scale = pow(2, level);

	for (i = 0; i < m_result->size; i++)
	{
		pstObj = m_result->ptr + i;
		pstObj->rco.x += rcoOffset.x;
		pstObj->rco.y += rcoOffset.y;
		for (int j = 0; j < pstObj->uwNumOfCorner; j++)
		{
			pstObj->arcoObjCorner[j].x += rcoOffset.x;
			pstObj->arcoObjCorner[j].y += rcoOffset.y;
		}
		for (int j = 0; j < 4; j++)
		{
			pstObj->arcoROICorner[j].x += rcoOffset.x;
			pstObj->arcoROICorner[j].y += rcoOffset.y;
		}
		m_match->GetObjMatchedPt(pstObj->uwID, feature, trans_feat, edge_info, matched);
		for (int j = 0; j < matched; j++)
		{
			trans_feat[j].coPos.x += rcoOffset.x / scale;
			trans_feat[j].coPos.y += rcoOffset.y / scale;
			trans_feat[j].rcoPos.x += rcoOffset.x / scale;
			trans_feat[j].rcoPos.y += rcoOffset.y / scale;
			edge_info[j].coPos.x += rcoOffset.x / scale;
			edge_info[j].coPos.y += rcoOffset.y / scale;
			edge_info[j].rcoPos.x += rcoOffset.x / scale;
			edge_info[j].rcoPos.y += rcoOffset.y / scale;

		}
	}
	return;
}


IMG_RCOORD CVisAlignResult::GetPosition(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rco;
	else
		return{ -1.0f,-1.0f };
}
IMG_REAL CVisAlignResult::GetRotation(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rotation;
	else
		return -1000.0f;
}
IMG_REAL CVisAlignResult::GetScale(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].scale;
	else
		return -1.0f;
}
IMG_REAL CVisAlignResult::GetMatchScore(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rMatched;
	else
		return -1.0f;
}
IMG_REAL CVisAlignResult::GetFittingScore(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rLikeScore;
	else
		return -1.0f;
}
IMG_OBJ *CVisAlignResult::GetIMG_OBJ(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr + position;
	else
		return nullptr;
}
IMG_VVOID CVisAlignResult::SetResultNum(IMG_UINT size)
{
	if (size < m_result->size)
		m_result->size = size;
}
IMG_VVOID CVisAlignResult::Reset()
{
	m_result->size = 0;
}
IMG_VVOID CVisAlignResult::TranslateObjectImage(CVisImage &src, CVisImage &dst, IMG_UINT position)
{
	IMG_RCOORD rcoPt[4], rcoTrans[4], rcoDst;
	IMG_SIZE szImage;
	IMG_OBJ *pstObj;
	IMG_INT i, j;
	pstObj = GetIMG_OBJ(position);
	if (pstObj == nullptr)
	{
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	}
	for (i = 0; i < 4; i++)
	{
		Align_Reverse_Translate_RCOORD_By_Obj(pstObj->arcoROICorner, 4, pstObj, rcoTrans);
	}
	Align_Reverse_Translate_RCOORD_By_Obj(&pstObj->rco, 1, pstObj, &rcoDst);
	szImage.width = (rcoTrans[1].x - rcoTrans[0].x + 0.1);
	szImage.height = (rcoTrans[3].y - rcoTrans[0].y + 0.1);
	rcoDst.x = rcoDst.x - rcoTrans[0].x;
	rcoDst.y = rcoDst.y - rcoTrans[0].y;
	dst.InitImage(szImage);
	dst.RTS(src, pstObj->rco, rcoDst, -pstObj->rotation, 1 / pstObj->scale);
}

IMG_VVOID CVisAlignResult::DrawObjInColorBuffer(CVisImage &img, CVisAlignRecord *pstRec, IMG_UWORD uwObjIndex)
{
	IMG_OBJ *pstObj;
	IMG_FEATUREPT *feature;
	EDGE_INFORMATION *translated, *matched;
	IMG_INT i, j;
	IMG_UINT ulNumMatched;
	IMG_REAL cose, sine;
	IMG_REAL size;
	IMG_RCOORD start, end, center;
	VIS_IMAGE_INFO info;

	size = max(pstRec->GetRecord()->stTemplate.szWindowSize.width, pstRec->GetRecord()->stTemplate.szWindowSize.height)/50;
	if (size < 3)size = 3;
	if (uwObjIndex < m_result->size)
	{
		pstObj = m_result->ptr + uwObjIndex;
	}
	else
	{
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	}
	img.GetImageInfo(info);
	if (info.channel == VIS_IMG_GRAY)
	{
		img.GrayToRGB();
	}
	img.GetImageInfo(info);
	if (info.channel != VIS_IMG_RGB)
	{
		THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Need color/gray image input");
	}
	Align_DrawColorfulResultInBuffer(&img, pstObj, pstRec->GetRecord(), COLORS::Green);
	m_match->GetObjMatchedPt(pstObj->uwID, feature, translated, matched, ulNumMatched);
	Align_DrawTranslatedFeatureInImage(img, matched, ulNumMatched, COLORS::Cyan, size, pstRec->GetRecord()->ulHighestLayer);
	Align_DrawTranslatedFeatureInImage(img, translated, ulNumMatched, COLORS::Red, size/2, pstRec->GetRecord()->ulHighestLayer);
}

IMG_VVOID CVisAlignResult::AddObject(IMG_OBJ *pstObj, IMG_UINT num)
{
	if (num + m_result->size < m_result->maxsize)
	{
		memcpy(m_result->ptr + m_result->size, pstObj, num * sizeof(IMG_OBJ));
		m_result->size += num;
	}
	else
	{
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	}
}
IMG_VVOID CVisAlignResult::Serialize(CMEMPack &mp)
{
	CMEMPackHeader pack_header(this, mp);
	IMG_PVVOID p = NULL;
	IMG_UINT u;
	mp.Proc(m_result->size);
	for (IMG_INT i = 0; i < m_result->size && i < m_result->maxsize; i++)
	{
		if (mp.IsLoading())
		{
			memset(m_result->ptr + i, 0, sizeof(IMG_OBJ));
		}
		mp.Proc(m_result->ptr[i].rco);
		mp.Proc(m_result->ptr[i].rotation);
		mp.Proc(m_result->ptr[i].scale);
		mp.Proc(m_result->ptr[i].rMx);
		mp.Proc(m_result->ptr[i].rMy);
		mp.Proc(m_result->ptr[i].uwID);
		mp.Proc(m_result->ptr[i].ulRecTimestamp);
		mp.Proc(m_result->ptr[i].rLikeScore);
		mp.Proc(m_result->ptr[i].rMatched);
		mp.Proc(m_result->ptr[i].rVoteScore);
		mp.Proc(m_result->ptr[i].rMSE);
	}
}


CVisCircleResult::CVisCircleResult()
{
	m_result = (ALIGN_CIRCLE_RESULT *)CVisMemPool::PMalloc(sizeof(ALIGN_CIRCLE_RESULT));
	VALIDATE_MALLOC(m_result);
	m_result->maxsize = 4000;
	m_result->size = 0;
	m_result->mode = 0;
	m_result->circle_type = ALIGN_CIRCLE_TYPE;
	m_result->ptr = (IMG_CIRCLE_OBJ*)CVisMemPool::PMalloc(sizeof(IMG_CIRCLE_OBJ) * m_result->maxsize);
	VALIDATE_MALLOC(m_result->ptr);
	memset(m_result->ptr, 0, sizeof(IMG_CIRCLE_OBJ)*m_result->maxsize);
	m_match = nullptr;
}

CVisCircleResult::~CVisCircleResult()
{
	CVisMemPool::PFree(m_result->ptr);
	m_result->maxsize = 0;
	m_result->size = 0;;
	CVisMemPool::PFree(m_result);
	if (m_match)
	{
		m_match->Free();
		CVisMemPool::PFree(m_match);
	}
}
IMG_RCOORD CVisCircleResult::GetPosition(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rco;
	else
		return{ -1.0f,-1.0f };
}
IMG_REAL CVisCircleResult::GetRotation(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rotation;
	else
		return -1000.0f;
}
IMG_REAL CVisCircleResult::GetRadius(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].radius;
	else
		return -1.0f;
}
IMG_REAL CVisCircleResult::GetMatchScore(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rMatched;
	else
		return -1.0f;
}
IMG_REAL CVisCircleResult::GetFittingScore(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr[position].rLikeScore;
	else
		return -1.0f;
}
IMG_CIRCLE_OBJ *CVisCircleResult::GetIMG_CIRCLE_OBJ(IMG_UINT position)
{
	if (position < m_result->size)
		return m_result->ptr + position;
	else
		return nullptr;
}
IMG_VVOID CVisCircleResult::SetResultNum(IMG_UINT size)
{
	if (size < m_result->size)
		m_result->size = size;
}
IMG_VVOID CVisCircleResult::Reset()
{
	m_result->size = 0;
}
IMG_VVOID CVisCircleResult::RadiusRejection(IMG_REAL rMinRadius, IMG_REAL rMaxRadius)
{
	for (IMG_INT i = 0; i < m_result->size; i++)
	{
		if (m_result->ptr[i].radius > rMaxRadius + 2e-3 || m_result->ptr[i].radius < rMinRadius-2e-3)
		{
			m_result->ptr[i] = m_result->ptr[m_result->size - 1];
			m_result->size--;
			i--;
		}
	}
}
IMG_VVOID CVisCircleResult::OverlapRejection(IMG_UBYTE ubOverlap, IMG_REAL rScaleMargin)
{
	IMG_INT i, j;
	IMG_REAL dist;
	IMG_CIRCLE_OBJ *pstC1, *pstC2;
	if (!ubOverlap)
	{
		for (i = 0; i < m_result->size; i++)
		{
			pstC1 = m_result->ptr + i;
			for (j = i + 1; j < m_result->size; j++)
			{
				pstC2 = m_result->ptr + j;
				dist = ALIGN_DIST(pstC1->rco, pstC2->rco);
				if (dist < (pstC1->radius + pstC2->radius)*rScaleMargin)
				{
					if (pstC1->rLikeScore > pstC2->rLikeScore)
					{
						//remove c2
						m_result->ptr[j] = m_result->ptr[m_result->size - 1];
						m_result->size--;
						j--;
						if (m_result->size > 65535) THROW_VIS_EXCEPTION(VIS_ERR_INVALID_SIZE);
						continue;
					}
					else
					{
						//remove c1
						m_result->ptr[i] = m_result->ptr[m_result->size - 1];
						m_result->size--;
						i--;
						if (m_result->size > 65535) THROW_VIS_EXCEPTION(VIS_ERR_INVALID_SIZE);
						break;
					}
				}
			}
		}
	}
	else
	{
		for (i = 0; i < m_result->size; i++)
		{
			pstC1 = m_result->ptr + i;
			for (j = i + 1; j < m_result->size; j++)
			{
				pstC2 = m_result->ptr + j;
				dist = ALIGN_DIST(pstC1->rco, pstC2->rco);
				IMG_REAL thred = sqrt(pstC2->radius*pstC1->radius) / 10;
				if (thred < 3)thred = 3;
				if (dist < thred && fabs(pstC2->radius-pstC1->radius)< dist+2)
				{
					if (pstC1->rLikeScore > pstC2->rLikeScore)
					{
						//remove c2
						m_result->ptr[j] = m_result->ptr[m_result->size - 1];
						m_result->size--;
						j--;
						if (m_result->size > 65535) THROW_VIS_EXCEPTION(VIS_ERR_INVALID_SIZE);
						continue;
					}
					else
					{
						//remove c1
						m_result->ptr[i] = m_result->ptr[m_result->size - 1];
						m_result->size--;
						i--;
						if (m_result->size > 65535) THROW_VIS_EXCEPTION(VIS_ERR_INVALID_SIZE);
						break;
					}
				}
			}
		}

	}
}
void CVisCircleResult::PrintTableInHTML(struct _HTMLLOGGING *pstLog, IMG_CHAR *title)
{
	CVisMemPool pool;
	HTMLLOGGING_TABLE_DATA stTable;
	
	HL_Printf(pstLog, "Obj Num: %d\n", m_result->size);
	HL_InitTableData(&stTable);
	stTable.title = title;
	stTable.tablelinewidth = 0;
	if (GetCircleType() == ALIGN_CIRCLE_TYPE)
		stTable.column = 6;
	else
		stTable.column = 9;
	stTable.fontweight = FW_Medium;
	stTable.tablealign = TX_CENTER;
	stTable.tablewidth = 50;
	stTable.tablelinewidth = 1;
	stTable.bgColorOddLine = 0x9fff9f;
	stTable.formatstring = "%.6f";
	stTable.datatype = DT_REAL;
	stTable.heading = (IMG_CHAR **)pool.Malloc(stTable.column * sizeof(IMG_CHAR *));
	if (GetCircleType() == ALIGN_CIRCLE_TYPE)
	{
		stTable.heading[0] = "ID";
		stTable.heading[1] = "PosX";
		stTable.heading[2] = "PosY";
		stTable.heading[3] = "Radius";
		stTable.heading[4] = "Fitting Score";
		stTable.heading[5] = "Matching Score";
	}
	else
	{
		stTable.heading[0] = "ID";
		stTable.heading[1] = "PosX";
		stTable.heading[2] = "PosY";
		stTable.heading[3] = "Rotation";
		stTable.heading[4] = "Radius";
		stTable.heading[5] = "Major";
		stTable.heading[6] = "Minor";
		stTable.heading[7] = "Fitting Score";
		stTable.heading[8] = "Matching Score";
	}
	HL_CreateTableHeader(pstLog, &stTable);
	for (int i = 0; i < m_result->size; i++)
	{
		char value[9][20];
		if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
		else		stTable.bgColorOddLine = 0xffffcf;
		if (GetCircleType() == ALIGN_CIRCLE_TYPE)
		{
			_snprintf(value[0], sizeof(value[0]), "%d", m_result->ptr[i].uwID);
			_snprintf(value[1], sizeof(value[1]), "%.3f", m_result->ptr[i].rco.x);
			_snprintf(value[2], sizeof(value[2]), "%.3f", m_result->ptr[i].rco.y);
			_snprintf(value[3], sizeof(value[3]), "%.6f", m_result->ptr[i].radius);
			_snprintf(value[4], sizeof(value[5]), "%.3f", m_result->ptr[i].rLikeScore);
			_snprintf(value[5], sizeof(value[6]), "%.3f", m_result->ptr[i].rMatched);
			HL_CreateTableRow(pstLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5]);
		}
		else
		{
			_snprintf(value[0], sizeof(value[0]), "%d", m_result->ptr[i].uwID);
			_snprintf(value[1], sizeof(value[1]), "%.3f", m_result->ptr[i].rco.x);
			_snprintf(value[2], sizeof(value[2]), "%.3f", m_result->ptr[i].rco.y);
			_snprintf(value[3], sizeof(value[3]), "%.6f", m_result->ptr[i].rotation);
			_snprintf(value[4], sizeof(value[4]), "%.3f", m_result->ptr[i].radius);
			_snprintf(value[5], sizeof(value[5]), "%.3f", m_result->ptr[i].ellipse_major);
			_snprintf(value[6], sizeof(value[6]), "%.3f", m_result->ptr[i].ellipse_minor);
			_snprintf(value[7], sizeof(value[7]), "%.3f", m_result->ptr[i].rLikeScore);
			_snprintf(value[8], sizeof(value[8]), "%.3f", m_result->ptr[i].rMatched);
			HL_CreateTableRow(pstLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8]);
		}
	}
	HL_CloseTable(pstLog);
	HL_Printf(pstLog, "\n");
}
IMG_VVOID CVisCircleResult::SetCircleType(IMG_UBYTE type)
{
	if (m_result)m_result->circle_type = type;
}
IMG_VVOID CVisCircleResult::GetCircleType(IMG_UBYTE &type)
{
	if (m_result)type = m_result->circle_type;
}

IMG_UBYTE CVisCircleResult::GetCircleType(IMG_VVOID)
{
	if (m_result)
		return m_result->circle_type;
	else 
		return 0xff;
}

void CVisAlignResult::RejectByMatchScore(IMG_REAL rAcceptance, IMG_REAL rMargin)
{
	IMG_INT i;
	for (i = 0; i<m_result->size; i++)
	{
		if (m_result->ptr[i].rMatched < rAcceptance*rMargin*100.0f || (rMargin > 0.999 && m_result->ptr[i].rLikeScore < 0))
		{
			m_result->ptr[i] = m_result->ptr[m_result->size - 1];
			m_result->size--;
			i--;
		}
	}
}
void CVisAlignResult::RejectByScale(IMG_REAL rMaxScale, IMG_REAL rMinScale, IMG_REAL rMargin)
{
	IMG_INT i;
	for (i = 0; i < m_result->size; i++)
	{
		if (m_result->ptr[i].scale < rMinScale*rMargin || m_result->ptr[i].scale > rMaxScale/rMargin)
		{
			m_result->ptr[i] = m_result->ptr[m_result->size - 1];
			m_result->size--;
			i--;
		}
	}
}
void CVisAlignResult::RejectByAngle(IMG_REAL rMaxAngle, IMG_REAL rMinAngle, IMG_REAL rRepeatAngle, IMG_REAL rMargin)
{
	IMG_INT i, flag;
	IMG_REAL angle, rotation, MaxR = rMaxAngle, MinR = rMinAngle;
	const IMG_REAL epsilon = 1e-5;
	for (i = 0; i < m_result->size; i++)
	{
		rMaxAngle = MaxR, rMinAngle = MinR;
		if (rRepeatAngle < 1e-5)
		{
			rotation = m_result->ptr[i].rotation;
			if (rMinAngle > rotation)
			{
				flag = 0;
				while (rMaxAngle > rotation)
				{
					rMinAngle -= 360, rMaxAngle -= 360;
					if (rotation > rMinAngle-epsilon && rotation < rMaxAngle+epsilon)
					{
						flag = 1;
						break;
					}
				}
			}
			else if(rMaxAngle < m_result->ptr[i].rotation)
			{
				flag = 0;
				while (rMinAngle < rotation)
				{
					rMinAngle += 360, rMaxAngle += 360;
					if (rotation > rMinAngle-epsilon && rotation < rMaxAngle+epsilon)
					{
						flag = 1;
						break;
					}
				}
			}
			else
			{
				flag = 0;
				if (rotation > rMinAngle - epsilon && rotation < rMaxAngle + epsilon)
				{
					flag = 1;
				}
			}
			//if (m_result->ptr[i].rotation > rMaxAngle-epsilon && m_result->ptr[i].rotation<rMaxAngle + 360 +epsilon && m_result->ptr[i].rotation>rMinAngle + 360-epsilon)
			//	m_result->ptr[i].rotation -= 360;
			//if (m_result->ptr[i].rotation < rMinAngle+epsilon && m_result->ptr[i].rotation > rMinAngle - 360-epsilon && m_result->ptr[i].rotation < rMaxAngle - 360+epsilon)
			//	m_result->ptr[i].rotation += 360;

			//if (m_result->ptr[i].rotation < rMinAngle - (rMaxAngle - rMinAngle)*rMargin || m_result->ptr[i].rotation > rMaxAngle + (rMaxAngle - rMinAngle)*rMargin)
			if(flag == 0)
			{
				m_result->ptr[i] = m_result->ptr[m_result->size - 1];
				m_result->size--;
				i--;
			}
		}
		else
		{
			for (angle = 0; angle < 360; angle += rRepeatAngle)
			{
				//if (m_result->ptr[i].rotation > rMaxAngle+angle-epsilon && m_result->ptr[i].rotation<rMaxAngle+angle + 360 +epsilon&& m_result->ptr[i].rotation>rMinAngle+angle + 360-epsilon)
				//	m_result->ptr[i].rotation -= 360;
				//if (m_result->ptr[i].rotation < rMinAngle+angle+epsilon && m_result->ptr[i].rotation > rMinAngle +angle- 360-epsilon && m_result->ptr[i].rotation < rMaxAngle +angle- 360+epsilon)
				//	m_result->ptr[i].rotation += 360;
				rotation = m_result->ptr[i].rotation;
				if (rMinAngle + angle > rotation)
				{
					flag = 0;
					while (rMaxAngle + angle > rotation)
					{
						rMinAngle -= 360, rMaxAngle -= 360;
						if (rotation > rMinAngle +angle - epsilon && rotation < rMaxAngle + angle + epsilon)
						{
							flag = 1;
							break;
						}
					}
				}
				else if (rMaxAngle + angle < m_result->ptr[i].rotation)
				{
					flag = 0;
					while (rMinAngle + angle < rotation)
					{
						rMinAngle += 360, rMaxAngle += 360;
						if (rotation > rMinAngle + angle - epsilon && rotation < rMaxAngle + angle + epsilon)
						{
							flag = 1;
							break;
						}
					}
				}
				else
				{
					flag = 0;
					if (rotation > rMinAngle + angle - epsilon && rotation < rMaxAngle + angle + epsilon)
					{
						flag = 1;
					}
				}
				if (flag == 1)break;
				//if (m_result->ptr[i].rotation > rMinAngle +angle - (rMaxAngle - rMinAngle)*rMargin && m_result->ptr[i].rotation < rMaxAngle +angle + (rMaxAngle - rMinAngle)*rMargin)
				//{
				//	flag=0;
				//}
			}
			if (flag == 0)
			{
				m_result->ptr[i] = m_result->ptr[m_result->size - 1];
				m_result->size--;
				i--;
			}
		}
	}
}




IMG_VVOID CVisAlignSearch::translate_object_table(CVisAlignResult & stObjTable, IMG_RCOORD * prcoOffset)
{
	IMG_INT i, j;
	ALIGN_SRCH_RESULT *result = stObjTable.Result();
	IMG_OBJ *pstObj;
	for (i = 0; i < result->size; i++)
	{
		pstObj = result->ptr + i;
		pstObj->rco.x += pstObj->scale*(prcoOffset->x*cos(result->ptr[i].rotation*D2R) - prcoOffset->y*sin(result->ptr[i].rotation*D2R));
		pstObj->rco.y += pstObj->scale*(prcoOffset->x*sin(result->ptr[i].rotation*D2R) + prcoOffset->y*cos(result->ptr[i].rotation*D2R));
	}
	//i = 0;
	//do{
	//	pstObj = result->ptr + i;
	//	pstObj->rco.x += prcoOffset->x*cos(result->ptr[i].rotation*D2R) - prcoOffset->y*sin(result->ptr[i].rotation*D2R);
	//	pstObj->rco.y += prcoOffset->x*sin(result->ptr[i].rotation*D2R) + prcoOffset->y*cos(result->ptr[i].rotation*D2R);
	//	for (j = 0; j<pstObj->uwNumOfCorner; j++)
	//	{
	//		pstObj->arcoObjCorner[j].x += prcoOffset->x*cos(result->ptr[i].rotation*D2R) - prcoOffset->y*sin(result->ptr[i].rotation*D2R);
	//		pstObj->arcoObjCorner[j].y += prcoOffset->x*sin(result->ptr[i].rotation*D2R) + prcoOffset->y*cos(result->ptr[i].rotation*D2R);
	//	}
	//	for (j = 0; j<4; j++)
	//	{
	//		pstObj->arcoROICorner[j].x += prcoOffset->x*cos(result->ptr[i].rotation*D2R) - prcoOffset->y*sin(result->ptr[i].rotation*D2R);
	//		pstObj->arcoROICorner[j].y += prcoOffset->x*sin(result->ptr[i].rotation*D2R) + prcoOffset->y*cos(result->ptr[i].rotation*D2R);
	//	}
	//	i++;
	//} while (i < result->size);
	return IMG_VVOID();
}


IMG_VVOID CVisAlignSearch::SetSearchOption(CVisAlignSearchOption *pstSrchOpt)
{
	ALIGN_SEARCH_OPTION *srchop;
	srchop = pstSrchOpt->GetSearchPara();
	m_SearchOption.SetSearchPara(*srchop);
	m_SearchOption.GetSearchPara()->rVoteRejMargin = 0;
	return IMG_VVOID();
}


void CVisAlignResult::RejectObjectByOverlap(CVisAlignRecordTable *pstTable1, CVisAlignRecordTable *pstTable2, IMG_REAL rScaleRejMargin, IMG_REAL rScoreRejMargin, IMG_ULWORD level)
{
	volatile IMG_INT i, j;
	IMG_RCOORD *prcoObj1, *prcoObj2, *prcoConvexHull1, *prcoConvexHull2;
	IMG_OBJ obj1, obj2;
	CVisMemPool pool;
	IMG_REAL dist, vec, maxvec, angle_diff, scale_diff;
	BOOL IsOverlap;
	IMG_REAL redscale = pow(2.0f, level);
	prcoObj1 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable1->uwNumOfConvexHullFeature);
	prcoObj2 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable2->uwNumOfConvexHullFeature);
	for (i = 0, maxvec = 0; i < pstTable1->uwNumOfConvexHullFeature; i++)
	{
		j = pstTable1->pulConvexHullFeatureIndex[i];
		vec = pstTable1->pstSpA[j].rco.x*pstTable1->pstSpA[j].rco.x +
			pstTable1->pstSpA[j].rco.y*pstTable1->pstSpA[j].rco.y;
		if (maxvec< vec) maxvec = vec;
	}
	for (i = 0; i < pstTable2->uwNumOfConvexHullFeature; i++)
	{
		j = pstTable2->pulConvexHullFeatureIndex[i];
		vec = pstTable2->pstSpA[j].rco.x*pstTable2->pstSpA[j].rco.x +
			pstTable2->pstSpA[j].rco.y*pstTable2->pstSpA[j].rco.y;
		if (maxvec < vec) maxvec = vec;
	}
	//maxvec = sqrt(maxvec);
	prcoConvexHull1 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable1->uwNumOfConvexHullFeature);
	prcoConvexHull2 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable2->uwNumOfConvexHullFeature);
	VALIDATE_MALLOC(prcoConvexHull1);
	VALIDATE_MALLOC(prcoConvexHull2);
	for (i = 0; i < pstTable1->uwNumOfConvexHullFeature; i++)
	{
		prcoConvexHull1[i] = pstTable1->pstSpA[pstTable1->pulConvexHullFeatureIndex[i]].rco;
	}
	for (i = 0; i < pstTable2->uwNumOfConvexHullFeature; i++)
	{
		prcoConvexHull2[i] = pstTable2->pstSpA[pstTable2->pulConvexHullFeatureIndex[i]].rco;
	}
	for (i = 0; i < m_result->size; i++)
	{
		obj1 = m_result->ptr[i];
		obj1.scale *= rScaleRejMargin;
		obj1.rMx *= rScaleRejMargin;
		obj1.rMy *= rScaleRejMargin;
		Align_Translate_RCOORD_By_Obj(prcoConvexHull1, pstTable1->uwNumOfConvexHullFeature, &obj1, prcoObj1);
		for (j = i + 1; j < m_result->size; j++)
		{
			obj2 = m_result->ptr[j];
			obj2.scale *= rScaleRejMargin;
			obj2.rMx *= rScaleRejMargin;
			obj2.rMy *= rScaleRejMargin;
			//if (obj1.uwID == 453 && obj2.uwID == 2315)
			//{
			//	printf("hi");
			//}
			//if (obj1.uwID == 2315 && obj2.uwID == 453)
			//{
			//	printf("hi");
			//}
			dist = (obj1.rco.x - obj2.rco.x)*(obj1.rco.x - obj2.rco.x) + (obj1.rco.y - obj2.rco.y)*(obj1.rco.y - obj2.rco.y);
			if (dist > maxvec * 4) continue;
			angle_diff = Angle_Difference(obj1.rotation, obj2.rotation);
			scale_diff = fabs(obj1.scale - obj2.scale);
			Align_Translate_RCOORD_By_Obj(prcoConvexHull2, pstTable2->uwNumOfConvexHullFeature, &obj2, prcoObj2);
			IsOverlap = Align_IsConvexHullOverlap(prcoObj1, pstTable1->uwNumOfConvexHullFeature, prcoObj2, pstTable2->uwNumOfConvexHullFeature);
			if (!IsOverlap) continue;

			if (obj1.rLikeScore*rScoreRejMargin > obj2.rLikeScore)
			{
				//remove obj2;
				m_result->ptr[j] = m_result->ptr[m_result->size-1];
				m_result->size--;
				j--;
			}
			else if(obj2.rLikeScore*rScoreRejMargin > obj1.rLikeScore)
			{
				//remove obj1
				m_result->ptr[i] = m_result->ptr[m_result->size - 1];
				m_result->size--;
				i--;
				break;
			}			
			else if(dist < (maxvec)*0.01 && scale_diff < 0.01 && angle_diff < 5)
			{
				if (obj1.rLikeScore > obj2.rLikeScore)
				{
					//remove obj2;
					m_result->ptr[j] = m_result->ptr[m_result->size - 1];
					m_result->size--;
					j--;
				}
				else
				{
					//remove obj1
					m_result->ptr[i] = m_result->ptr[m_result->size - 1];
					m_result->size--;
					i--;
					break;
				}
			}
		}
	}
}
void CVisAlignResult::RejectCircleObjectByOverlap(CVisAlignRecordTable *pstTable1, CVisAlignRecordTable *pstTable2, IMG_REAL rScaleRejMargin, IMG_REAL rScoreRejMargin, IMG_ULWORD level)
{
	IMG_INT i, j;
	IMG_RCOORD *prcoObj1, *prcoObj2, *prcoConvexHull1, *prcoConvexHull2;
	IMG_OBJ obj1, obj2;
	CVisMemPool pool;
	IMG_REAL dist, vec, maxvec, angle_diff, scale_diff;
	BOOL IsOverlap;
	prcoObj1 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable1->uwNumOfConvexHullFeature);
	prcoObj2 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable2->uwNumOfConvexHullFeature);
	for (i = 0, maxvec = 0; i < pstTable1->uwNumOfConvexHullFeature; i++)
	{
		j = pstTable1->pulConvexHullFeatureIndex[i];
		vec = pstTable1->pstSpA[j].rco.x*pstTable1->pstSpA[j].rco.x +
			pstTable1->pstSpA[j].rco.y*pstTable1->pstSpA[j].rco.y;
		if (maxvec < vec) maxvec = vec;
	}
	for (i = 0; i < pstTable2->uwNumOfConvexHullFeature; i++)
	{
		j = pstTable2->pulConvexHullFeatureIndex[i];
		vec = pstTable2->pstSpA[j].rco.x*pstTable2->pstSpA[j].rco.x +
			pstTable2->pstSpA[j].rco.y*pstTable2->pstSpA[j].rco.y;
		if (maxvec < vec) maxvec = vec;
	}
	//maxvec = sqrt(maxvec);
	prcoConvexHull1 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable1->uwNumOfConvexHullFeature);
	prcoConvexHull2 = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*pstTable2->uwNumOfConvexHullFeature);
	VALIDATE_MALLOC(prcoConvexHull1);
	VALIDATE_MALLOC(prcoConvexHull2);
	for (i = 0; i < pstTable1->uwNumOfConvexHullFeature; i++)
	{
		prcoConvexHull1[i] = pstTable1->pstSpA[pstTable1->pulConvexHullFeatureIndex[i]].rco;
	}
	for (i = 0; i < pstTable2->uwNumOfConvexHullFeature; i++)
	{
		prcoConvexHull2[i] = pstTable2->pstSpA[pstTable2->pulConvexHullFeatureIndex[i]].rco;
	}
	for (i = 0; i < m_result->size; i++)
	{
		obj1 = m_result->ptr[i];
		obj1.scale *= rScaleRejMargin;
		obj1.rMx *= rScaleRejMargin;
		obj1.rMy *= rScaleRejMargin;
		Align_Translate_RCOORD_By_Obj(prcoConvexHull1, pstTable1->uwNumOfConvexHullFeature, &obj1, prcoObj1);
		for (j = i + 1; j < m_result->size; j++)
		{
			obj2 = m_result->ptr[j];
			obj2.scale *= rScaleRejMargin;
			obj2.rMx *= rScaleRejMargin;
			obj2.rMy *= rScaleRejMargin;
			Align_Translate_RCOORD_By_Obj(prcoConvexHull2, pstTable2->uwNumOfConvexHullFeature, &obj2, prcoObj2);
			//if (obj1.uwID == 453 && obj2.uwID == 2315)
			//{
			//	printf("hi");
			//}
			//if (obj1.uwID == 2315 && obj2.uwID == 453)
			//{
			//	printf("hi");
			//}
			dist = (obj1.rco.x - obj2.rco.x)*(obj1.rco.x - obj2.rco.x) + (obj1.rco.y - obj2.rco.y)*(obj1.rco.y - obj2.rco.y);
			if (dist > maxvec * 4 * rScaleRejMargin*rScaleRejMargin*obj1.scale*obj2.scale) continue;
			angle_diff = Angle_Difference(obj1.rotation, obj2.rotation);
			scale_diff = fabs(obj1.scale - obj2.scale);
			IsOverlap = Align_IsConvexHullOverlap(prcoObj1, pstTable1->uwNumOfConvexHullFeature, prcoObj2, pstTable2->uwNumOfConvexHullFeature);
			if (!IsOverlap) continue;

			if (obj1.rLikeScore*rScoreRejMargin > obj2.rLikeScore)
			{
				//remove obj2;
				m_result->ptr[j] = m_result->ptr[m_result->size - 1];
				m_result->size--;
				j--;
			}
			else if (obj2.rLikeScore*rScoreRejMargin > obj1.rLikeScore)
			{
				//remove obj1
				m_result->ptr[i] = m_result->ptr[m_result->size - 1];
				m_result->size--;
				i--;
				break;
			}
			else if (dist < (maxvec)*0.01 && (scale_diff < 0.02 && scale_diff*scale_diff*maxvec < 25*pow(4.0, level)) && (angle_diff < 5 || (obj1.rMx/obj1.rMy < 1.05 && obj2.rMx / obj2.rMy < 1.05)))
			{
				if (obj1.rLikeScore > obj2.rLikeScore)
				{
					//remove obj2;
					m_result->ptr[j] = m_result->ptr[m_result->size - 1];
					m_result->size--;
					j--;
				}
				else
				{
					//remove obj1
					m_result->ptr[i] = m_result->ptr[m_result->size - 1];
					m_result->size--;
					i--;
					break;
				}
			}
		}
	}
}

IMG_VVOID CVisAlignSearch::SaveResultImage(CVisImage &Src, const IMG_CHAR *pathname)
{
	CVisImage img;
	VIS_IMAGE_INFO info;
	img.CopyFrom(Src);
	img.GetImageInfo(info);
	if (info.channel < 3)img.GrayToRGB();
	for (int i = 0; i < m_AlignResult.Size(); i++)
	{
		Align_DrawColorfulResultInBuffer(&img, m_AlignResult.GetIMG_OBJ(i), m_AlignRecord->GetRecord(), COLORS::Green);
	}
	if (m_AlignResult.Size() == 0)
	{
		Align_DrawColorfulResultInBuffer(&img, m_AlignResult.GetFirstIMG_OBJ(), m_AlignRecord->GetRecord(), COLORS::Red);
	}
	img.WriteImage(pathname);
}

IMG_VVOID CVisAlignSearch::SaveResultImage(IMG_UBBUF &Src, const IMG_CHAR *pathname)
{
	Align_DrawResultInImage(&Src, m_AlignResult.Result()->ptr, m_AlignRecord->GetRecord(), 1, 10, pathname);
}
IMG_VVOID CVisAlignSearchOption::Serialize(CMEMPack &mp)
{
	CMEMPackHeader pack_header(this, mp);
	IMG_PVVOID p = NULL;
	IMG_UINT u;
	if (mp.IsLoading())m_searchPara->init();
	mp.Proc(m_searchPara->uwDebug);
	
	mp.Proc(m_searchPara->ubNumChannel);
	mp.Proc(m_searchPara->ubRedFactor);
	mp.Proc(m_searchPara->uwEdgeThd);
	mp.Proc(m_searchPara->ubOverlap);	//0 for no overlap, 1 for overlap
	mp.Proc(m_searchPara->rOverlapScaleMargin);
	mp.Proc(m_searchPara->uwPhaseInv);
	mp.Proc(m_searchPara->ulSrchTimestamp);
	mp.Proc(m_searchPara->ubAngleMatchTolerance);
	mp.Proc(m_searchPara->rRepeatingAngle);
	mp.Proc(m_searchPara->rMinAngle);
	mp.Proc(m_searchPara->rMaxAngle);
	mp.Proc(m_searchPara->rMinScale);
	mp.Proc(m_searchPara->rMaxScale);
	mp.Proc(m_searchPara->ubColorMatchOpt);
	if (mp.IsLoading())
	{
		mp.Proc(u);
		m_searchPara->MultiObj = (ALIGN_SRCH_MULTIOBJ)u;
	}
	else
	{
		u = m_searchPara->MultiObj;
		mp.Proc(u);
	}
	mp.Proc(m_searchPara->uwCompleteObj);		//0 for incomplete object, 1 for complete object
	mp.Proc(m_searchPara->uwFixedNumObj);
	mp.Proc(m_searchPara->rElasticity);
	mp.Proc(m_searchPara->rcoMagFactor.x);
	mp.Proc(m_searchPara->rcoMagFactor.y);
	mp.Proc(m_searchPara->rCoarseAcceptLevel);
	mp.Proc(m_searchPara->rAcceptLevel);
	mp.Proc(m_searchPara->rVoteRejMargin);
	mp.Proc(m_searchPara->ubExactMatch);
	u = sizeof(m_searchPara->strLogPath);
	mp.Proc(m_searchPara->strLogPath, u);
	mp.Proc(m_searchPara->ubExactMatch);
	mp.Proc(m_searchPara->rcoRefPt.x);
	mp.Proc(m_searchPara->rcoRefPt.y);
	mp.Proc(m_searchPara->uwIDStart);
	mp.Proc(m_searchPara->ubFittingOption);
	mp.Proc(m_searchPara->rFittingSigma);
	mp.Proc(m_searchPara->stSearchROI);
	mp.Proc(m_searchPara->ubFastSearch);

}
void CVisAlignSearchOption::SaveOptionToHTMLLog(struct _HTMLLOGGING *pstLog)
{
	if (pstLog == nullptr)return;
	IMG_CHAR value[1000];
	IMG_CHAR *heading[2] = { "Key", "Value" };
	HTMLLOGGING_TABLE_DATA stTable;
	HL_InitTableData(&stTable);
	stTable.title = "Search Input option";
	stTable.tablelinewidth = 0;
	stTable.column = 2;
	stTable.fontweight = FW_Medium;
	stTable.tablealign = TX_CENTER;
	stTable.tablewidth = 50;
	stTable.tablelinewidth = 1;
	stTable.bgColorOddLine = 0xbfffbf;
	stTable.formatstring = "%.6f";
	stTable.datatype = DT_REAL;
	stTable.heading = heading;

	HL_CreateTableHeader(pstLog, &stTable);

	IMG_UWORD	uwDebug;
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwDebug);
	HL_CreateTableRow(pstLog, &stTable, "uwDebug(0/1/5/512)", value);
	_snprintf(value, sizeof(value), "[%d %d]/[%d %d]", m_searchPara->stSearchROI.coWindowOff.x, m_searchPara->stSearchROI.coWindowOff.y, 
		m_searchPara->stSearchROI.szWindowSize.width, m_searchPara->stSearchROI.szWindowSize.height);
	HL_CreateTableRow(pstLog, &stTable, "SearchROI Offset/Size", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubNumChannel);
	HL_CreateTableRow(pstLog, &stTable, "ubNumChannel(not used)", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubRedFactor);
	HL_CreateTableRow(pstLog, &stTable, "ubRedFactor", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwEdgeThd);
	HL_CreateTableRow(pstLog, &stTable, "uwEdgeThd", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubOverlap);
	HL_CreateTableRow(pstLog, &stTable, "ubOverlap", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rOverlapScaleMargin);
	HL_CreateTableRow(pstLog, &stTable, "rOverlapScaleMargin", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwPhaseInv);
	HL_CreateTableRow(pstLog, &stTable, "uwPhaseInv", value);
	_snprintf(value, sizeof(value), "%u", m_searchPara->ulSrchTimestamp);
	HL_CreateTableRow(pstLog, &stTable, "ulSrchTimestamp(output)", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubAngleMatchTolerance);
	HL_CreateTableRow(pstLog, &stTable, "ubAngleMatchTolerance", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rRepeatingAngle);
	HL_CreateTableRow(pstLog, &stTable, "rRepeatingAngle", value);
	_snprintf(value, sizeof(value), "%.3f %.3f", m_searchPara->rMinAngle, m_searchPara->rMaxAngle);
	HL_CreateTableRow(pstLog, &stTable, "rMinAngle/rMaxAngle", value);
	_snprintf(value, sizeof(value), "%.3f %.3f", m_searchPara->rMinScale, m_searchPara->rMaxScale);
	HL_CreateTableRow(pstLog, &stTable, "rMinScale/rMaxScale", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubColorMatchOpt);
	HL_CreateTableRow(pstLog, &stTable, "ubColorMatchOpt(not used)", value);
	switch (m_searchPara->MultiObj)
	{
	case SRCH_MO_NEAREST:
		_snprintf(value, sizeof(value), "SRCH_MO_NEAREST");
		break;
	case SRCH_MO_MULTIPLE:
		_snprintf(value, sizeof(value), "SRCH_MO_MULTIPLE");
		break;
	case SRCH_MO_HIGHEST:
		_snprintf(value, sizeof(value), "SRCH_MO_HIGHEST");
		break;
	case SRCH_MO_NEAREST_OVERLAPREJ:
		_snprintf(value, sizeof(value), "SRCH_MO_NEAREST_OVERLAPREJ");
		break;
	default:
		_snprintf(value, sizeof(value), "%d", m_searchPara->MultiObj);
		break;
	}
	HL_CreateTableRow(pstLog, &stTable, "MultiObj", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwCompleteObj);
	HL_CreateTableRow(pstLog, &stTable, "uwCompleteObj", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwFixedNumObj);
	HL_CreateTableRow(pstLog, &stTable, "uwFixedNumObj", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rElasticity);
	HL_CreateTableRow(pstLog, &stTable, "rElasticity", value);
	_snprintf(value, sizeof(value), "%.3f %.3f", m_searchPara->rcoMagFactor.x, m_searchPara->rcoMagFactor.y);
	HL_CreateTableRow(pstLog, &stTable, "rcoMagFactor", value);
	_snprintf(value, sizeof(value), "%.3f %.3f", m_searchPara->rcoRefPt.x, m_searchPara->rcoRefPt.y);
	HL_CreateTableRow(pstLog, &stTable, "rcoRefPt", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rAcceptLevel);
	HL_CreateTableRow(pstLog, &stTable, "rAcceptLevel", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rCoarseAcceptLevel);
	HL_CreateTableRow(pstLog, &stTable, "rCoarseAcceptLevel", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rVoteRejMargin);
	HL_CreateTableRow(pstLog, &stTable, "rVoteRejMargin", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubExactMatch);
	HL_CreateTableRow(pstLog, &stTable, "ubExactMatch", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubFittingOption);
	HL_CreateTableRow(pstLog, &stTable, "ubFittingOption", value);
	_snprintf(value, sizeof(value), "%f", m_searchPara->rFittingSigma);
	HL_CreateTableRow(pstLog, &stTable, "rFittingSigma", value);
	_snprintf(value, sizeof(value), "%u", m_searchPara->ubFastSearch);
	HL_CreateTableRow(pstLog, &stTable, "ubFastSearch", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwIDStart);
	HL_CreateTableRow(pstLog, &stTable, "uwIDStart", value);
	_snprintf(value, sizeof(value), "%s", m_searchPara->strLogPath);
	HL_CreateTableRow(pstLog, &stTable, "strLogPath", value);
	HL_CloseTable(pstLog);

}
void CVisCircleSearchOption::SaveOptionToHTMLLog(struct _HTMLLOGGING *pstLog)
{
	if (pstLog == nullptr)return;
	IMG_CHAR value[1000];
	IMG_CHAR *heading[2] = { "Key", "Value" };
	HTMLLOGGING_TABLE_DATA stTable;
	HL_InitTableData(&stTable);
	stTable.title = "Search Input option";
	stTable.tablelinewidth = 0;
	stTable.column = 2;
	stTable.fontweight = FW_Medium;
	stTable.tablealign = TX_CENTER;
	stTable.tablewidth = 50;
	stTable.tablelinewidth = 1;
	stTable.bgColorOddLine = 0xbfffbf;
	stTable.formatstring = "%.6f";
	stTable.datatype = DT_REAL;
	stTable.heading = heading;

	HL_CreateTableHeader(pstLog, &stTable);

	IMG_UWORD	uwDebug;
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwDebug);
	HL_CreateTableRow(pstLog, &stTable, "uwDebug(0/1/5/512)", value);
	_snprintf(value, sizeof(value), "[%d %d]/[%d %d]", m_searchPara->stSearchROI.coWindowOff.x, m_searchPara->stSearchROI.coWindowOff.y,
		m_searchPara->stSearchROI.szWindowSize.width, m_searchPara->stSearchROI.szWindowSize.height);
	HL_CreateTableRow(pstLog, &stTable, "SearchROI Offset/Size", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubNumChannel);
	HL_CreateTableRow(pstLog, &stTable, "ubNumChannel(not used)", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubRedFactor);
	HL_CreateTableRow(pstLog, &stTable, "ubRedFactor", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubHighestLevel);
	HL_CreateTableRow(pstLog, &stTable, "ubHighestLevel", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwFeatureNum);
	HL_CreateTableRow(pstLog, &stTable, "uwFeatureNum", value);
	switch (m_searchPara->edgeType)
	{
	case EDGETYPE::ANY:
		_snprintf(value, sizeof(value), "ANY");
		break;
	case EDGETYPE::LIGHT2DARK:
		_snprintf(value, sizeof(value), "LIGHT2DARK");
		break;
	case EDGETYPE::DARK2LIGHT:
		_snprintf(value, sizeof(value), "DARK2LIGHT");
		break;
	case EDGETYPE::WHITECENTER:
		_snprintf(value, sizeof(value), "WHITECENTER");
		break;
	case EDGETYPE::BLACKCENTER:
		_snprintf(value, sizeof(value), "BLACKCENTER");
		break;
	case EDGETYPE::BOTH:
		_snprintf(value, sizeof(value), "BOTH");
		break;
	default:
		_snprintf(value, sizeof(value), "%d", m_searchPara->edgeType);
		break;
	}
	HL_CreateTableRow(pstLog, &stTable, "edgeType", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwEdgeThd);
	HL_CreateTableRow(pstLog, &stTable, "uwEdgeThd", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwEdgeKernel);
	HL_CreateTableRow(pstLog, &stTable, "uwEdgeKernel", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubOverlap);
	HL_CreateTableRow(pstLog, &stTable, "ubOverlap", value);
	switch (m_searchPara->ubCirType)
	{
	case 0:
		_snprintf(value, sizeof(value), "CIRCLE");
		break;
	case 1:
		_snprintf(value, sizeof(value), "ELLIPSE");
		break;
	default:
		_snprintf(value, sizeof(value), "%d", m_searchPara->ubCirType);
		break;
	}
	HL_CreateTableRow(pstLog, &stTable, "ubCirType", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rOverlapScaleMargin);
	HL_CreateTableRow(pstLog, &stTable, "rOverlapScaleMargin", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwPhaseInv);
	HL_CreateTableRow(pstLog, &stTable, "uwPhaseInv", value);
	_snprintf(value, sizeof(value), "%u", m_searchPara->ulSrchTimestamp);
	HL_CreateTableRow(pstLog, &stTable, "ulSrchTimestamp(output)", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubAngleMatchTolerance);
	HL_CreateTableRow(pstLog, &stTable, "ubAngleMatchTolerance", value);
	_snprintf(value, sizeof(value), "%.3f/%.3f/%.6f ", m_searchPara->rMinRadius, m_searchPara->rMaxRadius, m_searchPara->rInitEllipseRatio);
	HL_CreateTableRow(pstLog, &stTable, "rMinRadius/rMaxRadius/rInitEllipseRatio", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubColorMatchOpt);
	HL_CreateTableRow(pstLog, &stTable, "ubColorMatchOpt(not used)", value);
	switch (m_searchPara->MultiObj)
	{
	case SRCH_MO_NEAREST:
		_snprintf(value, sizeof(value), "SRCH_MO_NEAREST");
		break;
	case SRCH_MO_MULTIPLE:
		_snprintf(value, sizeof(value), "SRCH_MO_MULTIPLE");
		break;
	case SRCH_MO_HIGHEST:
		_snprintf(value, sizeof(value), "SRCH_MO_HIGHEST");
		break;
	case SRCH_MO_NEAREST_OVERLAPREJ:
		_snprintf(value, sizeof(value), "SRCH_MO_NEAREST_OVERLAPREJ");
		break;
	default:
		_snprintf(value, sizeof(value), "%d", m_searchPara->MultiObj);
		break;
	}
	HL_CreateTableRow(pstLog, &stTable, "MultiObj", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwCompleteObj);
	HL_CreateTableRow(pstLog, &stTable, "uwCompleteObj", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->uwFixedNumObj);
	HL_CreateTableRow(pstLog, &stTable, "uwFixedNumObj", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rElasticity);
	HL_CreateTableRow(pstLog, &stTable, "rElasticity", value);
	_snprintf(value, sizeof(value), "%.3f %.3f", m_searchPara->rcoMagFactor.x, m_searchPara->rcoMagFactor.y);
	HL_CreateTableRow(pstLog, &stTable, "rcoMagFactor", value);
	_snprintf(value, sizeof(value), "%.3f %.3f", m_searchPara->rcoRefPt.x, m_searchPara->rcoRefPt.y);
	HL_CreateTableRow(pstLog, &stTable, "rcoRefPt", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rAcceptLevel);
	HL_CreateTableRow(pstLog, &stTable, "rAcceptLevel", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rCoarseAcceptLevel);
	HL_CreateTableRow(pstLog, &stTable, "rCoarseAcceptLevel", value);
	_snprintf(value, sizeof(value), "%.3f", m_searchPara->rVoteRejMargin);
	HL_CreateTableRow(pstLog, &stTable, "rVoteRejMargin", value);
	_snprintf(value, sizeof(value), "%d", m_searchPara->ubExactMatch);
	HL_CreateTableRow(pstLog, &stTable, "ubExactMatch", value);
	_snprintf(value, sizeof(value), "%f", m_searchPara->rFittingSigma);
	HL_CreateTableRow(pstLog, &stTable, "rFittingSigma", value);
	_snprintf(value, sizeof(value), "%s", m_searchPara->strLogPath);
	HL_CreateTableRow(pstLog, &stTable, "strLogPath", value);
	HL_CloseTable(pstLog);

}
IMG_VVOID CVisCircleSearchOption::Serialize(CMEMPack &mp)
{
	CMEMPackHeader pack_header(this, mp);
	IMG_PVVOID p = NULL;
	IMG_UINT u;
	mp.Proc(m_searchPara->uwDebug);

	mp.Proc(m_searchPara->ubNumChannel);
	mp.Proc(m_searchPara->ubRedFactor);
	mp.Proc(m_searchPara->ubHighestLevel);
	mp.Proc(m_searchPara->uwFeatureNum);
	mp.Proc(m_searchPara->uwEdgeThd);
	mp.Proc(m_searchPara->uwEdgeKernel);
	if (mp.IsLoading())
	{
		mp.Proc(u);
		m_searchPara->edgeType = (EDGETYPE)u;
	}
	else
	{
		u = (IMG_UINT)m_searchPara->edgeType;
		mp.Proc(u);
	}
	mp.Proc(m_searchPara->ubOverlap);	//0 for no overlap, 1 for overlap
	mp.Proc(m_searchPara->rOverlapScaleMargin);
	mp.Proc(m_searchPara->uwPhaseInv);
	mp.Proc(m_searchPara->ulSrchTimestamp);
	mp.Proc(m_searchPara->ubAngleMatchTolerance);
	mp.Proc(m_searchPara->rMinRadius);
	mp.Proc(m_searchPara->rMaxRadius);
	mp.Proc(m_searchPara->ubColorMatchOpt);
	if (mp.IsLoading())
	{
		mp.Proc(u);
		m_searchPara->MultiObj = (ALIGN_SRCH_MULTIOBJ)u;
	}
	else
	{
		u = m_searchPara->MultiObj;
		mp.Proc(u);
	}
	mp.Proc(m_searchPara->uwCompleteObj);		//0 for incomplete object, 1 for complete object
	mp.Proc(m_searchPara->uwFixedNumObj);
	mp.Proc(m_searchPara->rElasticity);
	mp.Proc(m_searchPara->rcoMagFactor.x);
	mp.Proc(m_searchPara->rcoMagFactor.y);
	mp.Proc(m_searchPara->rCoarseAcceptLevel);
	mp.Proc(m_searchPara->rAcceptLevel);
	mp.Proc(m_searchPara->rVoteRejMargin);
	mp.Proc(m_searchPara->ubExactMatch);
	u = sizeof(m_searchPara->strLogPath);
	mp.Proc(m_searchPara->strLogPath, u);
	mp.Proc(m_searchPara->ubExactMatch);
	mp.Proc(m_searchPara->rcoRefPt.x);
	mp.Proc(m_searchPara->rcoRefPt.y);
	mp.Proc(m_searchPara->ubCirType);
	mp.Proc(m_searchPara->rFittingSigma);
	mp.Proc(m_searchPara->stSearchROI);
	mp.Proc(m_searchPara->rInitEllipseRatio);
}

IMG_VVOID CVisAlignSearch::search_circle(const CVisImage &Src, CVisCircleSearchOption &Option, CVisCircleResult &Result)
{
	search_circle(const_cast<CVisImage &>(Src), Option, Result);
}
IMG_VVOID CVisAlignSearch::search_circle(CVisImage &Src, CVisCircleSearchOption &Option, CVisCircleResult &Result)
{
	search_circle(Src, nullptr, Option, Result);
}

IMG_VVOID CVisAlignSearch::search_circle(CVisImage &Src, CVisImage *Mask, CVisCircleSearchOption &Option, CVisCircleResult &Result)
{
	IMG_INT i, j, k;
	IMG_LREAL a, b, c, d;
	CVisMemPool				pool;
	CVisAlignSearchOption	srchopt;
	CIRCLE_RECORD_INPUT		stRecInput;
	CVisAlignSearch			srch;
	CVisAlignResult			*p_result, all;
	CVisAlignRecord			*pRec;

	IMG_UBBUF				result_buf[3];
	IMG_REAL				red_scale = pow(0.5, Option.GetHighestLayer());
	IMG_UINT				rec_num, ulSearchLogIndex, *pSearchObjID;
	IMG_REAL				scale_range, rMinRadius, rMaxRadius, rInitEllipseRatio;
	HTMLLOGGING				logbackup;
	IMG_CHAR				pathname[FILENAME_MAX_LENGTH], *p;
	CVisClock				clock;
	IMG_UWORD				uwIDStart = 0;
	IMG_COORD				coUL;
	IMG_SIZE				szR;

	CVisImage result_img;


	if (Option.GetDebug() & 513)
	{
		CVisImage immask;
		immask.CopyFrom(Src);
		if (Mask)
		{
			CVisImage mask1, src;
			mask1.CopyFrom(*Mask);
			mask1.Mul_C(0);
			mask1.Add_C(1);
			src.CopyFrom(*Mask);
			mask1.Sub(src);
			mask1.Mul_C(40);
			immask.Add(mask1);
			immask.GetImage(result_buf + 0);

			Src.GetImage(result_buf + 1);
			Src.GetImage(result_buf + 2);
		}
		else
		{
			Src.GetImage(result_buf + 0);
			Src.GetImage(result_buf + 1);
			Src.GetImage(result_buf + 2);
		}

		result_img.SetImage(result_buf);
	}

	if (Option.GetDebug())
	{
		if (_access(Option.GetDebugPath(), 06) != 0)
		{
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Cannot open debug log path");
		}

		if (g_MasterSearchLogIndex == 0)
		{
			WIN32_FIND_DATA data;
			int index, maxindex = 0;
			HANDLE h_next;
			BOOL nextfile = true;
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG*.*", Option.GetDebugPath());
			h_next = FindFirstFile(pathname, &data);
			while (h_next != INVALID_HANDLE_VALUE && nextfile)
			{
				char *p = data.cFileName;
				sscanf(p, "LOG%d", &index);
				if (index > maxindex) maxindex = index;
				nextfile = FindNextFile(h_next, &data);
			}
			g_logIndexLock.try_lock_for(std::chrono::milliseconds(200));
			if(g_MasterSearchLogIndex==0)g_MasterSearchLogIndex = maxindex + 1;
			else g_MasterSearchLogIndex++;
			if (g_MasterSearchLogIndex > 99999)g_MasterSearchLogIndex = 1;
			g_SearchLogIndex = g_MasterSearchLogIndex;
			g_logIndexLock.unlock();

		}
		else
		{
			//g_logIndexLock.try_lock_for(std::chrono::milliseconds(200));
			g_MasterSearchLogIndex++;
			if (g_MasterSearchLogIndex > 99999)g_MasterSearchLogIndex = 1;
			g_SearchLogIndex = g_MasterSearchLogIndex;
			//g_logIndexLock.unlock();

		}
	}
	ulSearchLogIndex = g_SearchLogIndex;
	if (Option.GetDebug() & 513)
	{

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uCL.html", Option.GetDebugPath(), ulSearchLogIndex);
		logInit(pathname);
		writeLog("Log start");
#ifdef _DEBUG
		writeLog("Align Version Tag: %s, Debug\n", VisAlign::VIS_ALIGN_Version());
#else
		writeLog("Align Version Tag: %s Release\n", VisAlign::VIS_ALIGN_Version());
#endif
		writeLog("VisSystem Version Tag: %s\n", VIS_SYSTEM_DLL_Version());
		writeLog("TCL Version Tag: %s\n", TCL_DLL_Version());

#ifdef _WIN64
		writeLog("build on %s %s, x64\n", __DATE__, __TIME__);
#else
		writeLog("build on %s %s, x86\n", __DATE__, __TIME__);
#endif // _WIN64

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uCL", Option.GetDebugPath(), ulSearchLogIndex);
		_mkdir(pathname);

		if (Mask)
		{
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uCM.png", Option.GetDebugPath(), ulSearchLogIndex);
			Mask->WriteImage(pathname);
		}

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uCI.bmp", Option.GetDebugPath(), ulSearchLogIndex);
		Src.WriteImage(pathname);


		writeLog("Source Image\n");
		p = strrchr(pathname, '\\')+1;
		HL_InsertImage(m_pHtmlLog, p);
		Option.SaveOptionToHTMLLog(m_pHtmlLog);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uCO.opt", Option.GetDebugPath(), ulSearchLogIndex);
		Option.SaveToFile(pathname);
	}
	if (Option.GetDebug() & 256)
	{
		g_pstClock = &clock;
		clock.Start();
		clock.Click("Start");
	}
	else
	{
		g_pstClock = nullptr;
	}
	if (Option.GetHighestLayer() > Option.GetReduction())THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
	Result.SetResultNum(0);
	Result.SetCircleType(Option.GetCirType());
	Option.GetRadius(rMinRadius, rMaxRadius, rInitEllipseRatio);
	if (rInitEllipseRatio < 1)rInitEllipseRatio = 1 / rInitEllipseRatio;
	a = (log(rMaxRadius) - log(rMinRadius)) / log(4);
	rec_num = (IMG_UINT)(ceil(a));
	if (rec_num == 0)rec_num = 1;
	pRec = (CVisAlignRecord *)pool.Malloc(sizeof(CVisAlignRecord)*rec_num);
	pSearchObjID = (IMG_UINT *)pool.Malloc(sizeof(IMG_UINT)*rec_num);
	for (i = 0; i < rec_num; i++)new(pRec+i)CVisAlignRecord();

	stRecInput.edge_kernel = Option.GetEdgeKernel();
	stRecInput.edgetype = Option.GetEdgeType();
	stRecInput.ellipse_angle = 0;
	stRecInput.ellipse_ratio = rInitEllipseRatio;
	stRecInput.num_of_feature = Option.GetFeatureNum();

	srchopt.SetAcceptScore(Option.GetAcceptScore());
	srchopt.SetCoarseAcceptScore(Option.GetCoarseAcceptScore());
	srchopt.SetReduction(Option.GetReduction());
	srchopt.SetElasiticity(Option.GetElasiticity());
	srchopt.SetCompleteObj(Option.GetCompleteObj());
	if (Option.GetDebug() & 4)
		srchopt.SetDebug(ALIGN_DEBUG_DETAIL);
	else
		srchopt.SetDebug(0);

	_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uCL", Option.GetDebugPath(), ulSearchLogIndex);
	srchopt.SetDebugPath(pathname);
	srchopt.SetMultiObj(Option.GetMultiObj());
	srchopt.SetOverlap(Option.GetOverlap());
	srchopt.SetOverlapScaleMargin(Option.GetOverlapScaleMargin());
	srchopt.SetPhaseInv(Option.GetPhaseInv());
	srchopt.SetFitOption(Option.GetCirType());
	srchopt.SetEdgeThreshold(Option.GetEdgeThreshold());
	srchopt.SetPtAngleTolerance(Option.GetPtAngleTolerance());
	srchopt.SetFittingSigma(Option.GetFittingSigma());
	if (rInitEllipseRatio > 1 / 0.8 )
	{
		srchopt.SetAngle(-90, 90);
	}
	else
	{
		srchopt.SetAngle(0, 0);
	}

	Option.GetSearchROI(coUL, szR);
	srchopt.SetSearchROI(coUL, szR);
	if (Option.GetDebug() & 513)logbackup = *m_pHtmlLog;
	if (Option.GetDebug() & 256)
	{
		clock.Click("finish_prepare");
	}
	for (i = 0; i < rec_num; i++)
	{
		IMG_INT min_reduction;
		a = exp(i*log(rMaxRadius / rMinRadius) / rec_num);
		b = exp(log(rMaxRadius / rMinRadius) / rec_num);
		c = rMinRadius*a;
		d = rMinRadius*a*b;


		stRecInput.radius = (c+d)/2;
		if (stRecInput.num_of_feature == 0)
		{
			if (stRecInput.radius * 2 * PI*red_scale > 100) stRecInput.num_of_feature = 100;
			else stRecInput.num_of_feature = (IMG_UINT)ceil(stRecInput.radius * 2 * PI*red_scale);
		}
		min_reduction = (IMG_INT)floor(log(c / 4.0) / log(2));
		if (min_reduction < 0)min_reduction = 0;

		stRecInput.highest_layer = Option.GetHighestLayer();
		if (stRecInput.highest_layer <= min_reduction)
		{
			if (min_reduction > Option.GetReduction())
				stRecInput.num_of_layer = Option.GetReduction() + 1 - Option.GetHighestLayer();
			else
				stRecInput.num_of_layer = min_reduction + 1 - Option.GetHighestLayer();
			if (stRecInput.num_of_layer + Option.GetHighestLayer() >= ALIGN_MAX_LEARN_REDUCTION)
				stRecInput.num_of_layer = ALIGN_MAX_LEARN_REDUCTION - Option.GetHighestLayer();
		}
		else
		{
			stRecInput.highest_layer = min_reduction;
			stRecInput.num_of_layer = 1;
		}

		pRec[i].CreateCircularRec(&stRecInput);
		if (Option.GetDebug() & 256)
		{
			clock.Click("Create_record");
		}
		srchopt.SetIDStart(uwIDStart);
		srch.SetRecord(pRec+i);
		srchopt.SetScale(c / stRecInput.radius*.9, d / stRecInput.radius*1.1);
		if (Option.GetDebug() & 1)
		{
			writeLog("Search %d of %d\n", i, rec_num);
			writeLog("Search Radius %f\n", stRecInput.radius);
			writeLog("Search radius limit [%.3f %.3f]\n", c, d);
		}
		srch.SetSearchOption(&srchopt);
		try
		{
			srch.search(Src, Mask);
			if (Option.GetDebug() & 4)
			{
				char *p, alignsearch[FILENAME_MAX_LENGTH];
				_snprintf(alignsearch, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL.html", pathname, g_SearchLogIndex);
				p = strrchr(alignsearch, '\\')-1;
				while (p > alignsearch && *p != '\\')p--;
				p++;
				*m_pHtmlLog = logbackup;
				HL_InsertObject(m_pHtmlLog, "search log", p);
				writeLog("\n");
			}
		}
		catch (CVisException &e)
		{
			if (Option.GetDebug() & 1)writeLog("Exception at %s,line %d, code %d(%s) message: %s\n ", e.GetExceptionFile(), e.GetExceptionLine(), e.GetExceptionID(), e.GetExceptionIDInfo(), e.GetExceptionMessage());
			throw e;
		}
		if (Option.GetDebug() & 256)
		{
			clock.Click("search");
		}
		if (Option.GetDebug() & 513)*m_pHtmlLog = logbackup;
		p_result = srch.GetSearchResult();
		if (Option.GetDebug() & 1)
		{
			p_result->PrintTableInHTML(m_pHtmlLog, "Align Search Result");
		}
		if (Option.GetMultiObj() == SRCH_MO_MULTIPLE)
		{
			Result.Result()->size += p_result->Size();
			for (j = 0; j < p_result->Size(); j++)
			{
				IMG_OBJ *pstObj = p_result->GetIMG_OBJ(j);
				IMG_CIRCLE_OBJ *pstCircle = Result.GetIMG_CIRCLE_OBJ(Result.Size() - p_result->Size() + j);
				pstCircle->radius = stRecInput.radius*pstObj->scale;
				if (Option.GetCirType() == 0)
				{
					pstCircle->ellipse_major = pstCircle->ellipse_minor = stRecInput.radius*pstObj->scale;
					pstCircle->rotation = 0;
					pstCircle->rotation = pstObj->rotation;
				}
				else
				{
					pstCircle->ellipse_major = stRecInput.radius*pstObj->rMx*pstObj->scale*sqrt(rInitEllipseRatio);
					pstCircle->ellipse_minor = stRecInput.radius*pstObj->rMy*pstObj->scale/sqrt(rInitEllipseRatio);
					if (pstCircle->ellipse_major - pstCircle->ellipse_minor < 0.1)
						pstCircle->rotation = 0, pstObj->rotation = 0;
					else
						pstCircle->rotation = pstObj->rotation;
				}
				pstCircle->rco = pstObj->rco;
				pstCircle->rLikeScore = pstObj->rLikeScore;
				pstCircle->rMatched = pstObj->rMatched;
				pstCircle->rMSE = pstObj->rMSE;
				pstCircle->rVoteScore = pstObj->rVoteScore;
				pstCircle->uwID = pstObj->uwID;
				if (uwIDStart <= pstObj->uwID)uwIDStart = pstObj->uwID + 1;
			}
		}
		else if(Option.GetMultiObj()==SRCH_MO_HIGHEST)
		{
			if (Result.Size() == 0 && p_result->Size() > 0)
			{
				Result.Result()->size = p_result->Size();
				IMG_OBJ *pstObj = p_result->GetIMG_OBJ(0);
				IMG_CIRCLE_OBJ *pstCircle = Result.GetIMG_CIRCLE_OBJ(0);
				pstCircle->radius = stRecInput.radius*pstObj->scale;
				if (Option.GetCirType() == 0)
				{
					pstCircle->ellipse_major = pstCircle->ellipse_minor = stRecInput.radius*pstObj->scale;
					pstCircle->rotation = 0;
					pstCircle->rotation = pstObj->rotation;
				}
				else
				{
					pstCircle->ellipse_major = stRecInput.radius*pstObj->rMx*pstObj->scale*sqrt(rInitEllipseRatio);
					pstCircle->ellipse_minor = stRecInput.radius*pstObj->rMy*pstObj->scale / sqrt(rInitEllipseRatio);
					if (pstCircle->ellipse_major - pstCircle->ellipse_minor < 0.1)
						pstCircle->rotation = 0, pstObj->rotation = 0;
					else
						pstCircle->rotation = pstObj->rotation;
				}
				pstCircle->rco = pstObj->rco;
				pstCircle->rLikeScore = pstObj->rLikeScore;
				pstCircle->rMatched = pstObj->rMatched;
				pstCircle->rMSE = pstObj->rMSE;
				pstCircle->rVoteScore = pstObj->rVoteScore;
				pstCircle->uwID = pstObj->uwID;
				if (uwIDStart <= pstObj->uwID)uwIDStart = pstObj->uwID + 1;
			}
			else if(p_result->Size()>0)
			{
				IMG_OBJ *pstObj = p_result->GetIMG_OBJ(0);
				IMG_CIRCLE_OBJ *pstCircle = Result.GetIMG_CIRCLE_OBJ(0);
				if (pstObj->rLikeScore > pstCircle->rLikeScore)
				{
					pstCircle->radius = stRecInput.radius*pstObj->scale;
					if (Option.GetCirType() == 0)
					{
						pstCircle->ellipse_major = pstCircle->ellipse_minor = stRecInput.radius*pstObj->scale;
						pstCircle->rotation = 0;
						pstCircle->rotation = pstObj->rotation;
					}
					else
					{
						pstCircle->ellipse_major = stRecInput.radius*pstObj->rMx*pstObj->scale*sqrt(rInitEllipseRatio);
						pstCircle->ellipse_minor = stRecInput.radius*pstObj->rMy*pstObj->scale/ sqrt(rInitEllipseRatio);
						if (pstCircle->ellipse_major - pstCircle->ellipse_minor < 0.1)
							pstCircle->rotation = 0, pstObj->rotation = 0;
						else
							pstCircle->rotation = pstObj->rotation;
					}
					pstCircle->rco = pstObj->rco;
					pstCircle->rLikeScore = pstObj->rLikeScore;
					pstCircle->rMatched = pstObj->rMatched;
					pstCircle->rMSE = pstObj->rMSE;
					pstCircle->rVoteScore = pstObj->rVoteScore;
					pstCircle->uwID = pstObj->uwID;
					if (uwIDStart <= pstObj->uwID)uwIDStart = pstObj->uwID + 1;
				}
			}

		}

		all.Join(p_result);
		if (Result.m_match == nullptr)
		{
			Result.m_match = (CVisAlignResultPointMatch *)pool.PMalloc(sizeof(CVisAlignResultPointMatch));
			VALIDATE_MALLOC(Result.m_match);
			new(Result.m_match)CVisAlignResultPointMatch();
		}
		Result.m_match->Join(p_result->m_match);

		pSearchObjID[i] = uwIDStart;
		if (Option.GetDebug() & 256)
		{
			clock.Click("fill_result");
		}
		if (p_result->Size() == 0 && Result.Size()==0)
		{
			IMG_OBJ *pstObj = p_result->GetFirstIMG_OBJ();
			IMG_CIRCLE_OBJ *pstCircle = Result.GetFirstIMG_CIRCLE_OBJ();
			pstCircle->radius = stRecInput.radius*pstObj->scale;
			if (Option.GetCirType() == 0)
			{
				pstCircle->ellipse_major = pstCircle->ellipse_minor = stRecInput.radius*pstObj->scale;
				pstCircle->rotation = 0;
			}
			else
			{
				pstCircle->ellipse_major = stRecInput.radius*pstObj->rMx*sqrt(rInitEllipseRatio);
				pstCircle->ellipse_minor = stRecInput.radius*pstObj->rMy/ sqrt(rInitEllipseRatio);
			}
			pstCircle->rco = pstObj->rco;
			pstCircle->rLikeScore = pstObj->rLikeScore;
			pstCircle->rMatched = pstObj->rMatched;
			pstCircle->rMSE = pstObj->rMSE;
			pstCircle->rVoteScore = pstObj->rVoteScore;
			pstCircle->uwID = pstObj->uwID;
			pstCircle->rotation = pstObj->rotation;
		}
	}
	if (Option.GetDebug() & 256)
	{
		clock.Click("finish_search");
	}
	if (Option.GetDebug() & 513)
	{
		Result.PrintTableInHTML(m_pHtmlLog, "After Search Circle");
	}
	Result.RadiusRejection(rMinRadius, rMaxRadius);
	if (Option.GetDebug() & 513)
	{
		Result.PrintTableInHTML(m_pHtmlLog, "After Radius Rejection");
	}
	if (Option.GetDebug() & 256)
	{
		clock.Click("radius_rej");
	}
	Result.OverlapRejection(Option.GetOverlap(), Option.GetOverlapScaleMargin());
	if (Option.GetDebug() & 513)
	{
		Result.PrintTableInHTML(m_pHtmlLog, "After Overlap Rejection");
	}
	if (Option.GetDebug() & 256)
	{
		clock.Click("Overlap_rej");
	}
	if (Result.Size() > 0 && (Option.GetDebug() & 513))
	{
		for (j = 0; j < Result.Size(); j++)
		{
			IMG_CIRCLE_OBJ *pstCircle = Result.GetIMG_CIRCLE_OBJ(j);
			IMG_ULWORD timestamp = 0;
			IMG_OBJ *pstObj = nullptr;
			for (k = 0; k < all.Size(); k++)
			{
				pstObj = all.GetIMG_OBJ(k);
				if (pstCircle->uwID == pstObj->uwID)
				{
					timestamp = pstObj->ulRecTimestamp;
					break;
				}
			}
			for (k = 0; k < rec_num; k++)
			{
				if (timestamp == pRec[k].GetTimeStamp())
				{
					Align_DrawColorfulResultInBuffer(&result_img, pstObj, pRec[k].GetRecord(), COLORS::Green);
				}
			}
		}
	}
	if (Option.GetDebug() & 513)
	{
		if (result_img.Width()*result_img.Height() < 2096 * 2096 || result_img.Width()>JPG_SIZE_LIMITATION|| result_img.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uCL\\LOG%05uCResult.bmp", Option.GetDebugPath(), ulSearchLogIndex, ulSearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uCL\\LOG%05uCResult.jpg", Option.GetDebugPath(), ulSearchLogIndex, ulSearchLogIndex);
		p = strrchr(pathname, '\\')-10;
		result_img.WriteImage(pathname);
		writeLog("Result\n");
		HL_InsertImage(m_pHtmlLog, p);
		logfinish();
	}
	if (Option.GetDebug() & 256)
	{
		char name[MAX_FILE_NAME];
		clock.Click("Finish_all");
		_snprintf_s(name, sizeof(name), "%s\\LOG%05uCT.log", Option.GetDebugPath(), ulSearchLogIndex);
		clock.SetPath(name);
		clock.SaveToFile();
	}
	for (i = 0; i < rec_num; i++)
	{
		pRec[i].~CVisAlignRecord();
	}

}


IMG_VVOID CVisAlignSearch::search_segment(SEARCH_SEGMENT_INPUT &Stinput)
{
	CVisMemPool pool;
	int search_status = searchNoErr;
	ALIGN_SEARCH_OPTION *pstSrchOpt = m_SearchOption.GetSearchPara();
	VIS_ALIGN_RECORD *pstRec = m_AlignRecord->GetRecord();
	IMG_UINT ulReduction = pstSrchOpt->ubRedFactor > pstRec->ulNumOfLayer - 1 ? pstRec->ulNumOfLayer - 1 : pstSrchOpt->ubRedFactor;
	IMG_UINT ulLowestLayer = pstRec->ulHighestLayer + ulReduction;
	IMG_UINT ulHighestLayer = pstRec->ulHighestLayer;
	IMG_REAL rRejMargin[] = { 1.0, 0.85, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7 };
	IMG_UBBUF ubbSrc;
	CVisClock clock;
	IMG_INT pcount_before, pcount_after;

	LARGE_INTEGER liTime;
	QueryPerformanceCounter(&liTime);
	m_SearchOption.GetSearchPara()->ulSrchTimestamp = liTime.LowPart;

	// create mag pic
	CVisAlignSearchInterData stAlignExData;
	vector<EDGE_INFORMATION> edgePts;
	EDGE_INFORMATION tempEdgePt;
	IMG_REAL reduction = pow(0.5, ulLowestLayer), angle;
	ALIGN_REC_SEGMENT *tempSeg;

	//loadPara
	stAlignExData.pstOption = m_SearchOption.GetSearchPara();
	stAlignExData.pstClock = &clock;
	stAlignExData.uwDebug = pstSrchOpt->uwDebug;

	m_AlignResult.SetResultNum(0);
	m_AlignResult.SetRecordTimeStamp(m_AlignRecord->GetTimeStamp());
	stAlignExData.highest_level = ulHighestLayer;
	stAlignExData.coarse_level = ulLowestLayer;
	stAlignExData.pstRec = pstRec;// m_AlignRecord->GetRecord();
	stAlignExData.pubMask = nullptr;

	if (pstSrchOpt->uwDebug & 256)
	{
		g_pstClock = &clock;
		clock.Start();
		clock.Click("Start");
	}
	else
	{
		g_pstClock = nullptr;
	}
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("Before Load CAD Para");
	}

	int j;
	IMG_REAL xMin = FLT_MAX, yMin = FLT_MAX;
	IMG_REAL xMax = -FLT_MAX, yMax = -FLT_MAX;
	for (int i = 0; i < Stinput.num_of_segment; i++)
	{
		tempSeg = Stinput.segment + i;
		switch (tempSeg->seg_type)
		{
		case ALIGN_REC_LINE_SEGMENT:
			{
				IMG_REAL lineLength = (IMG_INT)pow(pow(tempSeg->start.x - tempSeg->end.x, 2) + pow(tempSeg->start.y - tempSeg->end.y, 2), 0.5);
				lineLength *= reduction/Stinput.pixel2mm;
				angle = atan2(tempSeg->end.y - tempSeg->start.y, tempSeg->end.x - tempSeg->start.x) / D2R - 90;
				if (angle < 0)angle += 360;
				for (j = 0; j < lineLength; j++)
				{
					tempEdgePt.coPos.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x)*reduction / Stinput.pixel2mm + 0.5;
					tempEdgePt.coPos.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y)*reduction / Stinput.pixel2mm + 0.5;
					tempEdgePt.rcoPos.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x)*reduction / Stinput.pixel2mm;
					tempEdgePt.rcoPos.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y)*reduction / Stinput.pixel2mm;
					tempEdgePt.gradient = 50;
					tempEdgePt.angle = angle;
					if (tempEdgePt.rcoPos.x < xMin)
					{
						xMin = tempEdgePt.rcoPos.x;
					}
					if (tempEdgePt.rcoPos.x > xMax)
					{
						xMax = tempEdgePt.rcoPos.x;
					}
					if (tempEdgePt.rcoPos.y < yMin)
					{
						yMin = tempEdgePt.rcoPos.y;
					}
					if (tempEdgePt.rcoPos.y > yMax)
					{
						yMax = tempEdgePt.rcoPos.y;
					}
					edgePts.push_back(tempEdgePt);
				}

			}
			break;
		case ALIGN_REC_ARC_SEGMENT:
			{
				IMG_ARCT tempArc;
				IMG_RCOORD rcoArc[3]; rcoArc[0] = tempSeg->start; rcoArc[1] = tempSeg->center[0]; rcoArc[2] = tempSeg->end;
				VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
				IMG_REAL tempAngle;
				tempAngle = tempArc.end_angle - tempArc.start_angle;
				if (tempAngle < 0)tempAngle += 360;
				IMG_INT arcLength = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
				arcLength *= reduction / Stinput.pixel2mm;

				for (j = 0; j < arcLength; j++)
				{
					angle = tempAngle*j / arcLength + tempArc.start_angle;
					if (angle < 0)angle += 360;
					if (angle > 360)angle -= 360;
					tempEdgePt.angle = angle;
					tempEdgePt.coPos.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R))*reduction / Stinput.pixel2mm + 0.5;
					tempEdgePt.coPos.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R))*reduction / Stinput.pixel2mm + 0.5;
					tempEdgePt.rcoPos.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R))*reduction / Stinput.pixel2mm;
					tempEdgePt.rcoPos.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R))*reduction / Stinput.pixel2mm;
					tempEdgePt.gradient = 50;
					if (tempEdgePt.rcoPos.x < xMin)
					{
						xMin = tempEdgePt.rcoPos.x;
					}
					if (tempEdgePt.rcoPos.x > xMax)
					{
						xMax = tempEdgePt.rcoPos.x;
					}
					if (tempEdgePt.rcoPos.y < yMin)
					{
						yMin = tempEdgePt.rcoPos.y;
					}
					if (tempEdgePt.rcoPos.y > yMax)
					{
						yMax = tempEdgePt.rcoPos.y;
					}
					edgePts.push_back(tempEdgePt);
				}
			}
			break;
		case ALIGN_REC_BSPLINE_SEGMENT:
			{
				ALIGN_SEGMENT_CURVE curve = tempSeg->curve;
				if (curve.num_points == 0 || !curve.control_points)
				{
					THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
				}
				IMG_RCOORD *coor = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*curve.num_points);
				for (int m = 0; m < curve.num_points; m++)
				{
					coor[m] = curve.control_points[m];
				}
				CVisNURBSCurve nurbsCurve(curve.isClosed);
				nurbsCurve.SetInputPara(coor, curve.num_points, curve.dims);
				vector<PARA_POINT> vecDstPoints;
				nurbsCurve.GetCurvePts(200, vecDstPoints);
				PARA_POINT tmpParaPt;
				for (j = 0; j < vecDstPoints.size(); j++)
				{
					tmpParaPt = vecDstPoints[j];
					tempEdgePt.angle = tmpParaPt.angle;
					tempEdgePt.coPos.x = tmpParaPt.pt.x * reduction / Stinput.pixel2mm + 0.5;
					tempEdgePt.coPos.y = tmpParaPt.pt.y * reduction / Stinput.pixel2mm + 0.5;
					tempEdgePt.rcoPos.x = tmpParaPt.pt.x * reduction / Stinput.pixel2mm;
					tempEdgePt.rcoPos.y = tmpParaPt.pt.y * reduction / Stinput.pixel2mm;
					tempEdgePt.gradient = 50;
					if (tempEdgePt.rcoPos.x < xMin)
					{
						xMin = tempEdgePt.rcoPos.x;
					}
					if (tempEdgePt.rcoPos.x > xMax)
					{
						xMax = tempEdgePt.rcoPos.x;
					}
					if (tempEdgePt.rcoPos.y < yMin)
					{
						yMin = tempEdgePt.rcoPos.y;
					}
					if (tempEdgePt.rcoPos.y > yMax)
					{
						yMax = tempEdgePt.rcoPos.y;
					}
					edgePts.push_back(tempEdgePt);
				}
				vecDstPoints.clear();
			}

			break;
		default:
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
			break;

		}
	}
	if (!pool.check_memory())SYS_Assert(0);
	IMG_UINT sizex = xMax-xMin, sizey = yMax-yMin;
	//xMin -= sizex>>1; yMin -= sizex >> 1; xMax += sizey >> 1; yMax += sizey >> 1;
	//sizex = xMax - xMin, sizey = yMax - yMin;
	xMin -= 10; yMin -= 10; xMax += 10; yMax += 10;
	//if (xMin<-1e5 || yMin<-1e5 || xMax>1e5 || yMax>1e5 || sizex > 32767 || sizey > 32767)
	//{
	//	THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment input error");
	//}
	//if (xMax - xMin> 65535 * reduction || yMax - yMin> 65535 * reduction)
	//{
	//	THROW_VIS_EXCEPTION(VIS_ERR_INVALID_SIZE);
	//}
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After Load CAD Para");
	}

	if (pstSrchOpt->uwDebug)
	{
		if (_access(m_SearchOption.GetDebugPath(), 06) != 0)
		{
			//THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "Cannot open debug log path");
			_mkdir(m_SearchOption.GetDebugPath());
		}
		if (g_MasterSearchLogIndex == 0)
		{
			IMG_CHAR pathname[FILENAME_MAX_LENGTH];
			WIN32_FIND_DATA data;
			int index, maxindex = 0;
			HANDLE h_next;
			BOOL nextfile = true;
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG*.*", m_SearchOption.GetDebugPath());
			h_next = FindFirstFile(pathname, &data);
			while (h_next != INVALID_HANDLE_VALUE && nextfile)
			{
				char *p = data.cFileName;
				sscanf(p, "LOG%d", &index);
				if (index > maxindex) maxindex = index;
				nextfile = FindNextFile(h_next, &data);
			}
			g_logIndexLock.try_lock_for(std::chrono::milliseconds(200));
			if (g_MasterSearchLogIndex == 0)g_MasterSearchLogIndex = maxindex + 1;
			else g_MasterSearchLogIndex++;
			if (g_MasterSearchLogIndex > 99999)g_MasterSearchLogIndex = 1;
			g_SearchLogIndex = g_MasterSearchLogIndex;
			g_logIndexLock.unlock();

		}
		else
		{
			//g_logIndexLock.try_lock_for(std::chrono::milliseconds(200));
			g_MasterSearchLogIndex++;
			if (g_MasterSearchLogIndex > 99999)g_MasterSearchLogIndex = 1;
			g_SearchLogIndex = g_MasterSearchLogIndex;
			//g_logIndexLock.unlock();

		}
		VisMath::MATH_InitLogInfo();
	}
	if (pstSrchOpt->uwDebug & 513)
	{
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL_search.html", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		logInit(pathname);
		writeLog("Log start\n");
		writeLog("Version Tag: %s\n", VisAlign::VIS_ALIGN_Version());
		writeLog("VisSystem Version Tag: %s\n", VIS_SYSTEM_DLL_Version());
		writeLog("TCL Version Tag: %s\n", TCL_DLL_Version());

#ifdef _WIN64
		writeLog("build on %s %s, x64\n", __DATE__, __TIME__);
#else
		writeLog("build on %s %s, x86\n", __DATE__, __TIME__);
#endif // _WIN64

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		_mkdir(pathname);
		IMG_UBBUF SrcImage;
		IMG_SIZE imgSize;
		imgSize.width = (IMG_UINT)((xMax - xMin) / reduction);
		imgSize.height = (IMG_UINT)((yMax - yMin) / reduction);
		SrcImage.size = imgSize;
		SrcImage.linestep = imgSize.width;
		SrcImage.ptr = (unsigned char*)pool.Malloc((size_t)imgSize.width *imgSize.height);
		memset(SrcImage.ptr, 0, (size_t)imgSize.width *imgSize.height);
		for (int i = 0; i < Stinput.num_of_segment; i++)
		{
			tempSeg = Stinput.segment + i;
			switch (tempSeg->seg_type)
			{
			case ALIGN_REC_LINE_SEGMENT:
			{
				IMG_REAL lineLength = (IMG_INT)pow(pow(tempSeg->start.x - tempSeg->end.x, 2) + pow(tempSeg->start.y - tempSeg->end.y, 2), 0.5);
				lineLength /= Stinput.pixel2mm;
				angle = atan2(tempSeg->end.y - tempSeg->start.y, tempSeg->end.x - tempSeg->start.x) / D2R - 90;
				if (angle < 0)angle += 360;
				for (j = 0; j < lineLength; j++)
				{
					tempEdgePt.coPos.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x) / Stinput.pixel2mm + 0.5 - xMin / reduction;
					tempEdgePt.coPos.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y) / Stinput.pixel2mm + 0.5 - yMin / reduction;
					tempEdgePt.rcoPos.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x) / Stinput.pixel2mm - xMin / reduction;;
					tempEdgePt.rcoPos.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y) / Stinput.pixel2mm - yMin / reduction;;
					tempEdgePt.gradient = 50;
					tempEdgePt.angle = angle;
					SrcImage.ptr[tempEdgePt.coPos.y*SrcImage.linestep + tempEdgePt.coPos.x] = 255;
				}

			}
			break;
			case ALIGN_REC_ARC_SEGMENT:
			{
				IMG_ARCT tempArc;
				IMG_RCOORD rcoArc[3]; rcoArc[0] = tempSeg->start; rcoArc[1] = tempSeg->center[0]; rcoArc[2] = tempSeg->end;
				VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
				IMG_REAL tempAngle;
				tempAngle = tempArc.end_angle - tempArc.start_angle;
				if (tempAngle < 0)tempAngle += 360;
				IMG_INT arcLength = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
				arcLength /= Stinput.pixel2mm;

				for (j = 0; j < arcLength; j++)
				{
					angle = tempAngle*j / arcLength + tempArc.start_angle;
					if (angle < 0)angle += 360;
					if (angle > 360)angle -= 360;
					tempEdgePt.angle = angle;
					tempEdgePt.coPos.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R)) / Stinput.pixel2mm + 0.5 - xMin / reduction;
					tempEdgePt.coPos.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R)) / Stinput.pixel2mm + 0.5 - yMin / reduction;
					tempEdgePt.rcoPos.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R)) / Stinput.pixel2mm - xMin / reduction;
					tempEdgePt.rcoPos.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R)) / Stinput.pixel2mm - yMin / reduction;
					tempEdgePt.gradient = 50;
					SrcImage.ptr[tempEdgePt.coPos.y*SrcImage.linestep + tempEdgePt.coPos.x] = 255;
				}
			}
			break;
			case ALIGN_REC_BSPLINE_SEGMENT:
			{
				ALIGN_SEGMENT_CURVE curve = tempSeg->curve;
				if (curve.num_points == 0 || !curve.control_points)
				{
					THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
				}
				IMG_RCOORD *coor = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*curve.num_points);
				for (int m = 0; m < curve.num_points; m++)
				{
					coor[m] = curve.control_points[m];
				}
				CVisNURBSCurve nurbsCurve(curve.isClosed);
				nurbsCurve.SetInputPara(coor, curve.num_points, curve.dims);
				vector<PARA_POINT> vecDstPoints;
				nurbsCurve.GetCurvePts(200, vecDstPoints);
				PARA_POINT tmpParaPt;
				for (j = 0; j < vecDstPoints.size(); j++)
				{
					tempEdgePt.coPos.x = (vecDstPoints[j].pt.x) / Stinput.pixel2mm + 0.5 - xMin / reduction;
					tempEdgePt.coPos.y = (vecDstPoints[j].pt.y) / Stinput.pixel2mm + 0.5 - yMin / reduction;
					SrcImage.ptr[tempEdgePt.coPos.y*SrcImage.linestep + tempEdgePt.coPos.x] = 255;
				}
				vecDstPoints.clear();
			}
			break;
			default:
				THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
				break;

			}
		}
		//for (j = 0; j < edgePts.size(); j++)
		//{
		//	int xTemp = (int)((edgePts[j].rcoPos.x + 0.5) - xMin) / reduction;
		//	int yTemp = (int)((edgePts[j].rcoPos.y + 0.5) - yMin) / reduction;
		//	SrcImage.ptr[yTemp*SrcImage.linestep + xTemp] = 255;
		//}
		CVisImage srcImage(SrcImage);
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSI.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		srcImage.WriteImage(pathname);
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSI.bmp", Stinput.strLogPath, g_SearchLogIndex);
		srcImage.WriteImage(pathname);

		writeLog("Source CAD Image\n");
		p = strrchr(pathname, '\\') + 1;
		HL_InsertImage(m_pHtmlLog, p);
		m_SearchOption.SaveOptionToHTMLLog(m_pHtmlLog);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSO.opt", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		m_SearchOption.SaveToFile(pathname);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSR.rec", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		m_AlignRecord->SaveToFile(pathname);

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSE.opt", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		Stinput.SaveToFile(pathname);

		writeLog("Segment srcData:\n");
		writeLog("num of segment : %d:\n", Stinput.num_of_segment);
		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			switch (Stinput.segment[j].seg_type)
			{
			case ALIGN_REC_LINE_SEGMENT:
				writeLog("LineSeg (%f,%f) (%f,%f) %d\n", Stinput.segment[j].start.x, Stinput.segment[j].start.y,
					Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				break;
			case ALIGN_REC_ARC_SEGMENT:
				writeLog("ArcSeg (%f,%f) (%f,%f) (%f,%f) %d\n", Stinput.segment[j].center[0].x, Stinput.segment[j].center[0].y,
					Stinput.segment[j].start.x, Stinput.segment[j].start.y, Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				break;
			case ALIGN_REC_BSPLINE_SEGMENT:
			{

				ALIGN_SEGMENT_CURVE curve = Stinput.segment[j].curve;
				writeLog("CurveSeg: dims valid %d  %d\n", curve.dims, Stinput.segment[j].valid);
				for (int mm = 0; mm < curve.num_points; mm++)
				{
					writeLog("CurveSeg (%f,%f)\n", curve.control_points[mm].x, curve.control_points[mm].y);
				}
			}
				break;
			default:
				break;
			}
		}
	}

	pcount_before = pool.GetPushPopCount();

	/*if (Align_VerifyBuildDate() == IMG_FALSE)
	{
		static thread_local int run_count = 0;
		run_count++;
		if (run_count > 50)
		{
			static bool sts = false;
			if (!sts)
			{
				sts = SEC_Validate();
				if (!sts)
				{
					if (pstSrchOpt->uwDebug & 513)
					{
						writeLog("SEC check fail.");
					}
					m_AlignResult.SetResultNum(0);
					goto exit;
				}
				if (run_count % 500 == 0)
				{
					sts = false;
				}
			}
		}
	}*/

	////gaussian
	//stAlignExData.gaussianInit(pool);
	//if (preprocess(stAlignExData) != 0)
	//{
	//	search_status = filterErr;
	//	goto exit;
	//}
	//pcount_after = pool.GetPushPopCount();
	//if (pcount_after != pcount_before)
	//	THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	//if (pstSrchOpt->uwDebug & 1)
	//{
	//	writeLog("reduction lowest level %d\n", stAlignExData.coarse_level);
	//	writeLog("reduction highest level %d\n", stAlignExData.highest_level);
	//	writeLog("gaussian end.");
	//	writeLog("pyramid begin.");
	//}
	//if (pstSrchOpt->uwDebug & 256)
	//{
	//	clock.Click("After_gaussian");
	//}
	IMG_INT width, height;
	width = xMax - xMin;
	height = yMax - yMin;
	//if (xMax - xMin> 0x7fffff* reduction || yMax - yMin> 0x7fffff* reduction)
	//{
	//	THROW_VIS_EXCEPTION(VIS_ERR_INVALID_SIZE);
	//}
	//if(width/reduction > 32767 || height/reduction > 32767)
	//{
	//	THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
	//	search_status = backMatchErr;
	//	goto exit;
	//}

	//pyramid
	stAlignExData.ubBufSrc.size = { (IMG_INT)(width / reduction),(IMG_INT)(height / reduction) };
	stAlignExData.ubBufSrc.linestep = stAlignExData.ubBufSrc.size.width;
	stAlignExData.ubBufSrc.ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*((size_t)stAlignExData.ubBufSrc.size.height*stAlignExData.ubBufSrc.size.width));
	VALIDATE_MALLOC(stAlignExData.ubBufSrc.ptr);
	memset(stAlignExData.ubBufSrc.ptr, 0, sizeof(IMG_UBYTE)*(stAlignExData.ubBufSrc.size.width*(size_t)stAlignExData.ubBufSrc.size.height));

	stAlignExData.ubBufGaussian.size = stAlignExData.ubBufSrc.size;
	stAlignExData.ubBufGaussian.linestep = stAlignExData.ubBufGaussian.size.width;
	stAlignExData.ubBufGaussian.ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*stAlignExData.ubBufSrc.size.width*(size_t)stAlignExData.ubBufSrc.size.height);
	VALIDATE_MALLOC(stAlignExData.ubBufGaussian.ptr);
	memset(stAlignExData.ubBufGaussian.ptr, 0, sizeof(IMG_UBYTE)*(stAlignExData.ubBufGaussian.size.width*(size_t)stAlignExData.ubBufGaussian.size.height));

	Stinput.width = stAlignExData.ubBufSrc.size.width; Stinput.height = stAlignExData.ubBufSrc.size.height;
	Stinput.xOffset = (IMG_INT)(xMin / reduction); Stinput.yOffset = (IMG_INT)(yMin / reduction);

	if (!pool.check_memory())SYS_Assert(0);
	stAlignExData.pyramidInit(pool);
	if (pyramid(stAlignExData) != 0)
	{
		search_status = pyramidErr;
		goto exit;
	}
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After_pyramid");
	}
	if (pstSrchOpt->uwDebug & 1)
	{
		char pyramidFile[100];
		for (int i = ulLowestLayer; i >= (int)ulHighestLayer; i--)
		{
			sprintf(pyramidFile, "subPyramid_img%u.bmp", i);
		}
		writeLog("pyramid end.");
	}

	//edge detect
	if (pstSrchOpt->uwDebug & 1)
	{
		writeLog("edge detect begin.");
	}
	if (!pool.check_memory())SYS_Assert(0);
	stAlignExData.ubbufEdSrc.ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*(size_t)width*height);
	VALIDATE_MALLOC(stAlignExData.ubbufEdSrc.ptr);
	stAlignExData.ubbufEdSrc.size = { width,height };
	stAlignExData.ubbufEdSrc.linestep = width;
	memset(stAlignExData.ubbufEdSrc.ptr, 0, sizeof(IMG_UBYTE)*(size_t)width*height);

	stAlignExData.pEdDstMag.ptr = (IMG_WORD*)pool.PMalloc(sizeof(IMG_WORD)*(size_t)width*height);
	VALIDATE_MALLOC(stAlignExData.pEdDstMag.ptr);
	stAlignExData.pEdDstMag.size = { width,height };
	stAlignExData.pEdDstMag.linestep = width;
	memset(stAlignExData.pEdDstMag.ptr, 0, sizeof(IMG_WORD)*(size_t)width*height);

	stAlignExData.pEdDstRoiE.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*(size_t)width*height);
	VALIDATE_MALLOC(stAlignExData.pEdDstRoiE.ptr);
	stAlignExData.pEdDstRoiE.size = { width,height };
	stAlignExData.pEdDstRoiE.linestep = width;
	memset(stAlignExData.pEdDstRoiE.ptr, 0, sizeof(IMG_UBYTE)*(size_t)width*height);

	stAlignExData.pEdAngle.ptr = (IMG_REAL *)pool.PMalloc(sizeof(IMG_REAL)*(size_t)width*height);
	VALIDATE_MALLOC(stAlignExData.pEdAngle.ptr);
	stAlignExData.pEdAngle.size = { width,height };
	stAlignExData.pEdAngle.linestep = width;
	memset(stAlignExData.pEdAngle.ptr, 0, sizeof(IMG_REAL)*(size_t)width*height);

	stAlignExData.edgeNum = edgePts.size();
	stAlignExData.pedgeArray = (EDGE_INFORMATION*)pool.PMalloc(stAlignExData.edgeNum * sizeof(EDGE_INFORMATION));

	for (j = 0; j < stAlignExData.edgeNum; j++)
	{
		stAlignExData.pedgeArray[j].coPos.x = (edgePts[j].rcoPos.x + 0.5 - xMin);
		stAlignExData.pedgeArray[j].coPos.y = (edgePts[j].rcoPos.y + 0.5 - yMin);
		stAlignExData.pedgeArray[j].rcoPos.x = edgePts[j].rcoPos.x - xMin;
		stAlignExData.pedgeArray[j].rcoPos.y = edgePts[j].rcoPos.y - yMin;
		stAlignExData.pedgeArray[j].gradient = edgePts[j].gradient;
		stAlignExData.pedgeArray[j].angle = edgePts[j].angle;
		stAlignExData.pEdDstMag.ptr[stAlignExData.pedgeArray[j].coPos.y*width + stAlignExData.pedgeArray[j].coPos.x] = 50;
		stAlignExData.pEdDstRoiE.ptr[stAlignExData.pedgeArray[j].coPos.y*width + stAlignExData.pedgeArray[j].coPos.x] = 255;
		stAlignExData.pEdAngle.ptr[stAlignExData.pedgeArray[j].coPos.y*width + stAlignExData.pedgeArray[j].coPos.x] = edgePts[j].angle;

		stAlignExData.ubBufSrc.ptr[(IMG_INT)(stAlignExData.pedgeArray[j].coPos.y /reduction)*(size_t)stAlignExData.ubBufSrc.linestep + (IMG_INT)(stAlignExData.pedgeArray[j].coPos.x / reduction)] =
			stAlignExData.ubBufGaussian.ptr[(IMG_INT)(stAlignExData.pedgeArray[j].coPos.y / reduction)*(size_t)stAlignExData.ubBufSrc.linestep + (IMG_INT)(stAlignExData.pedgeArray[j].coPos.x / reduction)] = 255;
	}
	if (!pool.check_memory())SYS_Assert(0);
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After_Buildedge");
	}

	if (pstSrchOpt->uwDebug & 1)
	{
		writeLog("edge detect end.");
		//////	output bin img		///////////////////////////////////////
		//FILE *file = fopen("edgeDetect.txt", "w+");
		int flag = 1;
		int _width = width; int _height = height;
		/*int _width = stAlignExData.PyrStruct()->pRoi[ulLowestLayer].width;
		int _height = stAlignExData.PyrStruct()->pRoi[ulLowestLayer].height;
		unsigned char* pEdgeImg = (unsigned char*)pool.Malloc(_width * _height);
		memset(pEdgeImg, 0, _width*_height);
		for (int k = 0; k < stAlignExData.EdgeNum(); k++)
		{
			int i, j;
			i = (stAlignExData.pEdgeArray() + k)->coPos.y;
			j = (stAlignExData.pEdgeArray() + k)->coPos.x;
			*(pEdgeImg + i * _width + j) = 255;
		}*/
		IMG_CHAR pathname[MAX_FILE_NAME], *p;
		if (pstSrchOpt->uwDebug & 4)
		{
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_edge_mag.tif", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
			saveImg(stAlignExData.EdDst().ptr, { _width,_height }, pathname);
			p = strrchr(pathname, '\\') - 10;
			HL_InsertObject(m_pHtmlLog, "Edge mag\n", p);
			writeLog("\n");
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_edge_angle.tif", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
			saveImg(stAlignExData.EdAngle().ptr, { _width,_height }, pathname);
			p = strrchr(pathname, '\\') - 10;
			HL_InsertObject(m_pHtmlLog, "Edge angle\n", p);
			writeLog("\n");
		}
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uS_edge.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		saveImg(stAlignExData.EdDstRoiE().ptr, { _width,_height }, pathname);
		p = strrchr(pathname, '\\') - 10;
		HL_InsertImage(m_pHtmlLog, p);
		HL_PutLineBreak(m_pHtmlLog);
	}
	///////////////////////////coarse_search////////////////////////////////////////
	if (!pool.check_memory())SYS_Assert(0);
	coarse_search(stAlignExData);
	if (!pool.check_memory())SYS_Assert(0);
	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("coarse_search");
	}
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	//	////////////////// after coarse_search  ////////////////////////////
	//IMG_INT start_level, end_level;
	IMG_INT level_i;
	//start_level = pstRec->ulNumOfLayer+pstRec->ulHighestLayer-1;
	//end_level = m_AlignRecord->GetRecord()->ulHighestLayer;
	/*for (j = 0; j < m_AlignResult.Size(); j++)
	{
		(m_AlignResult.GetFirstIMG_OBJ()+j)->rco.x += xMin;
		(m_AlignResult.GetFirstIMG_OBJ()+j)->rco.y += yMin;
	}*/
	/*for (j = 0; j < stAlignExData.edgeNum; j++)
	{
		stAlignExData.pedgeArray[j].coPos.x = edgePts[j].coPos.x + xMin;
		stAlignExData.pedgeArray[j].coPos.y = edgePts[j].coPos.y + yMin;
		stAlignExData.pedgeArray[j].rcoPos.x = edgePts[j].rcoPos.x + xMin;
		stAlignExData.pedgeArray[j].rcoPos.y = edgePts[j].rcoPos.y + yMin;
		stAlignExData.pedgeArray[j].gradient = edgePts[j].gradient;
		stAlignExData.pedgeArray[j].angle = edgePts[j].angle;
		stAlignExData.pEdDstMag.ptr[stAlignExData.pedgeArray[j].coPos.y*width + stAlignExData.pedgeArray[j].coPos.x] = 50;
		stAlignExData.pEdDstRoiE.ptr[stAlignExData.pedgeArray[j].coPos.y*width + stAlignExData.pedgeArray[j].coPos.x] = 255;
		stAlignExData.pEdAngle.ptr[stAlignExData.pedgeArray[j].coPos.y*width + stAlignExData.pedgeArray[j].coPos.x] = edgePts[j].angle;
	}*/
	m_AlignResult.SortByMatchScore();
	ALIGN_REC_SEGMENT *segInput = (ALIGN_REC_SEGMENT*)pool.Malloc(sizeof(ALIGN_REC_SEGMENT)*Stinput.num_of_segment);
	for (level_i = (IMG_INT)ulLowestLayer; level_i >= (IMG_INT)ulHighestLayer; level_i--)
	{
		reduction = pow(0.5, level_i);
		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			segInput[j].seg_type = Stinput.segment[j].seg_type;
			segInput[j].edgedir = Stinput.segment[j].edgedir;
			segInput[j].contour_id = Stinput.segment[j].contour_id;
			segInput[j].center[0].x = (Stinput.segment[j].center[0].x / Stinput.pixel2mm - Stinput.xOffset) * reduction;
			segInput[j].center[0].y = (Stinput.segment[j].center[0].y / Stinput.pixel2mm - Stinput.yOffset) * reduction;
			segInput[j].center[1].x = (Stinput.segment[j].center[1].x / Stinput.pixel2mm - Stinput.xOffset) * reduction;
			segInput[j].center[1].y = (Stinput.segment[j].center[1].y / Stinput.pixel2mm - Stinput.yOffset) * reduction;
			segInput[j].start.x = (Stinput.segment[j].start.x / Stinput.pixel2mm - Stinput.xOffset) * reduction;
			segInput[j].start.y = (Stinput.segment[j].start.y / Stinput.pixel2mm - Stinput.yOffset) * reduction;
			segInput[j].end.x = (Stinput.segment[j].end.x / Stinput.pixel2mm - Stinput.xOffset) * reduction;
			segInput[j].end.y = (Stinput.segment[j].end.y / Stinput.pixel2mm - Stinput.yOffset) * reduction;
			segInput[j].valid = Stinput.segment[j].valid;
			if (Stinput.segment[j].curve.num_points > 0)
			{
				segInput[j].curve.dims = Stinput.segment[j].curve.dims;
				segInput[j].curve.isClosed = Stinput.segment[j].curve.isClosed;
				segInput[j].curve.num_points = Stinput.segment[j].curve.num_points;
				segInput[j].curve.control_points = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*segInput[j].curve.num_points);
				for (int mm = 0; mm < Stinput.segment[j].curve.num_points; mm++)
				{
					segInput[j].curve.control_points[mm].x = (Stinput.segment[j].curve.control_points[mm].x / Stinput.pixel2mm - Stinput.xOffset) * reduction;
					segInput[j].curve.control_points[mm].y = (Stinput.segment[j].curve.control_points[mm].y / Stinput.pixel2mm - Stinput.yOffset) * reduction;
				}
			}
		}
		stAlignExData.current_level = level_i;
		stAlignExData.pstTable = m_AlignRecord->GetRecord()->ptr + level_i - ulHighestLayer;

		if (pstSrchOpt->uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "start_fine_search_%d", level_i);
			clock.Click(msg);
		}
		//m_AlignResult.RejectByMatchScore(m_SearchOption.GetAcceptScore(), rRejMargin[level_i - ulHighestLayer]);
		pcount_before = pool.GetPushPopCount();
		if (m_AlignResult.Size()>0)
			searchseg_level(stAlignExData, level_i - ulHighestLayer, segInput, Stinput.num_of_segment);
		m_AlignResult.SortByFittingScore();
		pcount_after = pool.GetPushPopCount();
		if (pcount_after != pcount_before)
			THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
		pcount_before = pcount_after;

		scale_object_table(m_AlignResult, 2.0);
	}
	for (level_i = 0; level_i<stAlignExData.highest_level; level_i++)
		scale_object_table(m_AlignResult, 2.0);
	scale_object_table(m_AlignResult, 0.5);
	if (!pool.check_memory())SYS_Assert(0);
	m_AlignResult.RejectByMatchScore(m_SearchOption.GetAcceptScore(), rRejMargin[0]);
	if (pstSrchOpt->ubOverlap)
	{
		if (stAlignExData.pstTable->ubSpARotationIndependent || pstSrchOpt->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
		{
			m_AlignResult.RejectCircleObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 0.2, 0);
		}
		else
		{
			m_AlignResult.RejectObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 0.2, 0);
		}
	}
	else
	{
		if (stAlignExData.pstTable->ubSpARotationIndependent || pstSrchOpt->ubFittingOption & ALIGN_SRCH_FITTING_ELLIPSE)
		{
			m_AlignResult.RejectCircleObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 1.0, 0);
		}
		else
		{
			m_AlignResult.RejectObjectByOverlap(stAlignExData.pstTable, stAlignExData.pstTable, pstSrchOpt->rOverlapScaleMargin, 1.0, 0);
		}
	}

	if (pstSrchOpt->uwDebug & 256)
	{
		clock.Click("After_reject_overlap");
	}
	for (int i = 0; i < m_AlignResult.Size(); i++)
	{
		IMG_OBJ *pstObj = m_AlignResult.GetIMG_OBJ(i);
		Align_Translate_RCOORD_By_Obj(pstRec->rcoPt, pstRec->uwNumOfObjCorner, pstObj, pstObj->arcoObjCorner);
		pstObj->uwNumOfCorner = pstRec->uwNumOfObjCorner;
		Align_Translate_RCOORD_By_Obj(pstRec->rcoROI, 4, pstObj, pstObj->arcoROICorner);
		pstObj->rotation += pstRec->rOrientation;
	}
	if (m_AlignResult.Size() == 0)
	{
		IMG_OBJ *pstObj = m_AlignResult.GetFirstIMG_OBJ();
		Align_Translate_RCOORD_By_Obj(pstRec->rcoPt, pstRec->uwNumOfObjCorner, pstObj, pstObj->arcoObjCorner);
		pstObj->uwNumOfCorner = pstRec->uwNumOfObjCorner;
		Align_Translate_RCOORD_By_Obj(pstRec->rcoROI, 4, pstObj, pstObj->arcoROICorner);
		pstObj->rotation += pstRec->rOrientation;
	}
	translate_object_table(m_AlignResult, &pstRec->rcoRefVector);
	m_AlignResult.SortByFittingScore();
	if (m_SearchOption.GetMultiObj() == SRCH_MO_HIGHEST && m_AlignResult.Size() > 0)
	{
		m_AlignResult.SetResultNum(1);
	}
	if (stAlignExData.pstOption->uwFixedNumObj > 0 && m_AlignResult.Size() > stAlignExData.pstOption->uwFixedNumObj)
	{
		m_AlignResult.SetResultNum(stAlignExData.pstOption->uwFixedNumObj);
	}
	if (!pool.check_memory())SYS_Assert(0);
	if (pstSrchOpt->uwDebug & 513)
	{
		// test result//////////////////////////////
		ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
		writeLog("Total Object Num %d\n", result->size);
		HTMLLOGGING_TABLE_DATA stTable;
		HL_InitTableData(&stTable);
		stTable.title = "Final Result";
		stTable.tablelinewidth = 0;
		stTable.column = 7;
		stTable.fontweight = FW_Medium;
		stTable.tablealign = TX_CENTER;
		stTable.tablewidth = 50;
		stTable.tablelinewidth = 1;
		stTable.bgColorOddLine = 0xffff7f;
		stTable.formatstring = "%.6f";
		stTable.datatype = DT_REAL;
		stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
		stTable.heading[0] = "ID";
		stTable.heading[1] = "PosX";
		stTable.heading[2] = "PosY";
		stTable.heading[3] = "Scale";
		stTable.heading[4] = "Rotation";
		stTable.heading[5] = "Fitting Score";
		stTable.heading[6] = "Matching Score";
		HL_CreateTableHeader(m_pHtmlLog, &stTable);
		for (int i = 0; i < m_AlignResult.Size(); i++)
		{
			char value[7][20];
			if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
			else			stTable.bgColorOddLine = 0xffffcf;
			_snprintf(value[0], sizeof(value[0]), "%d", result->ptr[i].uwID);
			_snprintf(value[1], sizeof(value[1]), "%.3f", result->ptr[i].rco.x);
			_snprintf(value[2], sizeof(value[2]), "%.3f", result->ptr[i].rco.y);
			_snprintf(value[3], sizeof(value[3]), "%.6f", result->ptr[i].scale);
			_snprintf(value[4], sizeof(value[4]), "%.6f", result->ptr[i].rotation);
			_snprintf(value[5], sizeof(value[5]), "%.3f", result->ptr[i].rLikeScore);
			_snprintf(value[6], sizeof(value[6]), "%.3f", result->ptr[i].rMatched);
			HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
		}
		HL_CloseTable(m_pHtmlLog);
		HL_Printf(m_pHtmlLog, "\n");
	}
	//g_log.FinalDump();
	//system("pause");

exit:
	mkl_free_buffers();
	pcount_after = pool.GetPushPopCount();
	if (pcount_after != pcount_before)
		THROW_VIS_EXCEPTION(VIS_ERR_OVERFLOW);
	pcount_before = pcount_after;
	if (pstSrchOpt->uwDebug & 256)
	{
		char name[MAX_FILE_NAME];
		clock.Click("Finish_search");
		_snprintf_s(name, sizeof(name), "%s\\LOG%05uST.log", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		clock.SetPath(name);
		clock.SaveToFile();
	}
	if (pstSrchOpt->uwDebug & 513)
	{
		IMG_INT i = 0;
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
		IMG_UBBUF SrcImage;
		SrcImage.size.width = Stinput.width; SrcImage.size.height = Stinput.height;
		SrcImage.linestep = SrcImage.size.width;
		SrcImage.ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*SrcImage.size.width*(size_t)SrcImage.size.height);
		memset(SrcImage.ptr, 0, SrcImage.size.width*(size_t)SrcImage.size.height);
		reduction = pow(0.5, ulLowestLayer);
		for (int i = 0; i < Stinput.num_of_segment; i++)
		{
			tempSeg = Stinput.segment + i;
			switch (tempSeg->seg_type)
			{
			case ALIGN_REC_LINE_SEGMENT:
			{
				IMG_REAL lineLength = (IMG_INT)pow(pow(tempSeg->start.x - tempSeg->end.x, 2) + pow(tempSeg->start.y - tempSeg->end.y, 2), 0.5);
				lineLength /= Stinput.pixel2mm;
				angle = atan2(tempSeg->end.y - tempSeg->start.y, tempSeg->end.x - tempSeg->start.x) / D2R - 90;
				if (angle < 0)angle += 360;
				for (j = 0; j < lineLength; j++)
				{
					tempEdgePt.coPos.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x) / Stinput.pixel2mm + 0.5 - xMin / reduction;
					tempEdgePt.coPos.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y) / Stinput.pixel2mm + 0.5 - yMin / reduction;
					tempEdgePt.rcoPos.x = ((tempSeg->end.x - tempSeg->start.x)*j / lineLength + tempSeg->start.x) / Stinput.pixel2mm - xMin / reduction;;
					tempEdgePt.rcoPos.y = ((tempSeg->end.y - tempSeg->start.y)*j / lineLength + tempSeg->start.y) / Stinput.pixel2mm - yMin / reduction;;
					tempEdgePt.gradient = 50;
					tempEdgePt.angle = angle;
					SrcImage.ptr[tempEdgePt.coPos.y*SrcImage.linestep + tempEdgePt.coPos.x] = 255;
				}

			}
			break;
			case ALIGN_REC_ARC_SEGMENT:
			{
				IMG_ARCT tempArc;
				IMG_RCOORD rcoArc[3]; rcoArc[0] = tempSeg->start; rcoArc[1] = tempSeg->center[0]; rcoArc[2] = tempSeg->end;
				VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
				IMG_REAL tempAngle;
				tempAngle = tempArc.end_angle - tempArc.start_angle;
				if (tempAngle < 0)tempAngle += 360;
				IMG_INT arcLength = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
				arcLength /= Stinput.pixel2mm;

				for (j = 0; j < arcLength; j++)
				{
					angle = tempAngle*j / arcLength + tempArc.start_angle;
					if (angle < 0)angle += 360;
					if (angle > 360)angle -= 360;
					tempEdgePt.angle = angle;
					tempEdgePt.coPos.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R)) / Stinput.pixel2mm + 0.5 - xMin / reduction;
					tempEdgePt.coPos.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R)) / Stinput.pixel2mm + 0.5 - yMin / reduction;
					tempEdgePt.rcoPos.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R)) / Stinput.pixel2mm - xMin / reduction;
					tempEdgePt.rcoPos.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R)) / Stinput.pixel2mm - yMin / reduction;
					tempEdgePt.gradient = 50;
					SrcImage.ptr[tempEdgePt.coPos.y*SrcImage.linestep + tempEdgePt.coPos.x] = 255;
				}
			}
			break;
			case ALIGN_REC_BSPLINE_SEGMENT:
			{
				ALIGN_SEGMENT_CURVE curve = tempSeg->curve;
				if (curve.num_points == 0 || !curve.control_points)
				{
					THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
				}
				IMG_RCOORD *coor = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*curve.num_points);
				for (int m = 0; m < curve.num_points; m++)
				{
					coor[m] = curve.control_points[m];
				}
				CVisNURBSCurve nurbsCurve(curve.isClosed);
				nurbsCurve.SetInputPara(coor, curve.num_points, curve.dims);
				vector<PARA_POINT> vecDstPoints;
				nurbsCurve.GetCurvePts(200, vecDstPoints);
				PARA_POINT tmpParaPt;
				for (j = 0; j < vecDstPoints.size(); j++)
				{
					tempEdgePt.coPos.x = (vecDstPoints[j].pt.x) / Stinput.pixel2mm + 0.5 - xMin / reduction;
					tempEdgePt.coPos.y = (vecDstPoints[j].pt.y) / Stinput.pixel2mm + 0.5 - yMin / reduction;
					SrcImage.ptr[tempEdgePt.coPos.y*SrcImage.linestep + tempEdgePt.coPos.x] = 255;
				}
				vecDstPoints.clear();
			}
			break;
			default:
				THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
				break;

			}
		}
		//for (j = 0; j < edgePts.size(); j++)
		//{
		//	int xTemp = (int)((edgePts[j].rcoPos.x + 0.5 - xMin) / pow(0.5, ulLowestLayer));
		//	int yTemp = (int)((edgePts[j].rcoPos.y + 0.5 - yMin) / pow(0.5, ulLowestLayer));
		//	SrcImage.ptr[yTemp*SrcImage.linestep + xTemp] = 255;
		//}
		IMG_UBBUF buf[3];
		buf[0] = SrcImage;
		buf[1] = SrcImage;
		buf[2] = SrcImage;
		CVisImage img(buf);
		for (i = 0; i < m_AlignResult.Size(); i++)
		{
			//Align_DrawColorfulResultInBuffer(&img, m_AlignResult.GetIMG_OBJ(i), pstRec, COLORS::Green);
			m_AlignResult.DrawObjInColorBuffer(img, m_AlignRecord, i);
			//_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult_%02d.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex,i);
			//Align_DrawResultInImage(&SrcImage, m_AlignResult.GetIMG_OBJ(i), m_AlignRecord->GetRecord(), 1, 10, pathname);
		}
		if (m_AlignResult.Size() == 0)
		{
			Align_DrawColorfulResultInBuffer(&img, m_AlignResult.GetFirstIMG_OBJ(), pstRec, COLORS::Red);
		}
		if (img.Width()*img.Height() < 2096 * 2096 || img.Width()>JPG_SIZE_LIMITATION|| img.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSL\\LOG%05uSResult.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSL\\LOG%05uSResult.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		//switch (g_SearchLogIndex %4)
		//{
		//case 0:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//	break;
		//case 1:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//	break;
		//case 2:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.bmp", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//	break;
		//case 3:
		//	_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSResult.tif", m_SearchOption.GetDebugPath(), g_SearchLogIndex);
		//default:
		//	break;
		//}

		img.WriteImage(pathname);
		p = strrchr(pathname, '\\') - 10;
		HL_InsertImage(m_pHtmlLog, p);
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("searchStatus: %s \n", getErrorMessage(search_status));
		logfinish();
	}


}

IMG_VVOID CVisAlignSearch::match_segment(SEARCH_SEGMENT_INPUT &Stinput)
{
	CVisMemPool pool;
	ALIGN_SEARCH_OPTION *pstSrchOpt = m_SearchOption.GetSearchPara();
	VIS_ALIGN_RECORD *pstRec = m_AlignRecord->GetRecord();
	ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
	IMG_UINT ulReduction = pstSrchOpt->ubRedFactor > pstRec->ulNumOfLayer - 1 ? pstRec->ulNumOfLayer - 1 : pstSrchOpt->ubRedFactor;
	IMG_UINT ulLowestLayer = pstRec->ulHighestLayer + ulReduction;
	IMG_UINT ulHighestLayer = pstRec->ulHighestLayer;
	int i, j, k, m;
	IMG_OBJ *pstObj;
	IMG_INT width = Stinput.width;
	IMG_INT height = Stinput.height;
	IMG_INT iElasticity = Stinput.iElasticity;
	IMG_REAL reduction = pow(0.5, ulHighestLayer), angle;

	IMG_INT fea_point_num = pstRec->ptr->ulNumOfContourPts;
	IMG_RCOORD *dstCoor = (IMG_RCOORD*)pool.PMalloc(sizeof(IMG_RCOORD)*fea_point_num);
	IMG_RCOORD tempCoor, elaCoor;;
	IMG_UBBUF ubbufEdge;
	ALIGN_REC_SEGMENT *tempSeg;
	IMG_INT	 interval = 3, totalPt = 0, length;
	for (i = 0; i < result->size; i++)
	{
		pstObj = result->ptr + i;
		IMG_REAL scale = pow(2.0, ulHighestLayer);
		pstObj->rco.x -= pstRec->rcoRefVector.x*cos(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMx - pstRec->rcoRefVector.y*sin(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMy;
		pstObj->rco.y -= pstRec->rcoRefVector.x*sin(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMx + pstRec->rcoRefVector.y*cos(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMy;
		pstObj->rotation -= pstRec->rOrientation;

	}

	for (i = 0; i < ulHighestLayer; i++)
	{
		scale_object_table(m_AlignResult, 0.5);
		width /= 2;
		height /= 2;
	}
	ubbufEdge.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*(size_t)width*height);
	ubbufEdge.size = { width,height };
	ubbufEdge.linestep = width;
	memset(ubbufEdge.ptr, 0, sizeof(IMG_UBYTE)*(size_t)width*height);

	for (i = 0; i < result->size; i++)
	{
		pstObj = result->ptr + i;
		for (j = 0; j < fea_point_num; j++)
		{
			tempCoor = pstRec->ptr->pstContourPts[j].fpoint;
			Align_Translate_RCOORD_By_Obj(&tempCoor, 1, pstObj, &dstCoor[j]);
			ubbufEdge.ptr[(int)(dstCoor[j].y + 0.5)*(size_t)ubbufEdge.linestep + (int)(dstCoor[j].x + 0.5)] = 255;
		}

		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			totalPt = 0;
			tempSeg = Stinput.segment + j;
			switch (tempSeg->seg_type)
			{
			case ALIGN_REC_LINE_SEGMENT:
				length = (IMG_INT)pow(pow(tempSeg->start.x - tempSeg->end.x, 2) + pow(tempSeg->start.y - tempSeg->end.y, 2), 0.5);
				length *= reduction;
				angle = atan2(tempSeg->end.y - tempSeg->start.y, tempSeg->end.x - tempSeg->start.x) / D2R - 90;
				if (angle < 0)angle += 360;
				for (k = 0; k < length; k++)
				{
					tempCoor.x = ((tempSeg->end.x - tempSeg->start.x)*k / length + tempSeg->start.x)*reduction;
					tempCoor.y = ((tempSeg->end.y - tempSeg->start.y)*k / length + tempSeg->start.y)*reduction;
					for (m = -iElasticity; m <= iElasticity; m++)
					{
						elaCoor.x = tempCoor.x + m*cos(angle*D2R);
						elaCoor.y = tempCoor.y + m*sin(angle*D2R);
						if (ubbufEdge.ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge.linestep + (int)(elaCoor.x + 0.5)] == 255)
						{
							totalPt += 1;
							break;
						}
					}

				}
				break;
			case ALIGN_REC_ARC_SEGMENT:
				IMG_ARCT tempArc;
				IMG_RCOORD rcoArc[3]; rcoArc[0] = tempSeg->start; rcoArc[1] = tempSeg->center[0]; rcoArc[2] = tempSeg->end;
				VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
				IMG_REAL tempAngle;
				tempAngle = tempArc.end_angle - tempArc.start_angle;
				if (tempAngle < 0)tempAngle += 360;
				length = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
				length *= reduction;

				for (k = 0; k < length; k++)
				{
					angle = tempAngle*k / length + tempArc.start_angle;
					//if (angle < 0)angle += 360;
					tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R))*reduction;
					tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R))*reduction;
			
					for (m = -iElasticity; m <= iElasticity; m++)
					{
						elaCoor.x = tempCoor.x + m*cos(angle*D2R);
						elaCoor.y = tempCoor.y + m*sin(angle*D2R);
						if (ubbufEdge.ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge.linestep + (int)(elaCoor.x + 0.5)] == 255)
						{
							totalPt += 1;
							break;
						}
					}
				}
				break;
			case ALIGN_REC_BSPLINE_SEGMENT:

				//break;
			default:
				THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
				break;
			}

			if (totalPt < length / interval*Stinput.rAcceptScore)
			{
				tempSeg->valid = 0;
			}
		}

		memset(ubbufEdge.ptr, 0, sizeof(IMG_UBYTE)*(size_t)width*height);
	}
	IMG_RCOORD rco_Arc[3], coor;
	IMG_ARCT temp_Arc;
	IMG_REAL temp_Angle, angle1, angle2;
	IMG_CIRCLE temp_circle;
	if (m_SearchOption.GetDebug() & 513)
	{
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("\n");
		writeLog("Search segment result:\n");
		writeLog("num of segment : %d:\n", Stinput.num_of_segment);

		IMG_UBBUF SrcImage;
		SrcImage.size.width = Stinput.width; SrcImage.size.height = Stinput.height;
		SrcImage.linestep = SrcImage.size.width;
		SrcImage.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*SrcImage.size.width*(size_t)SrcImage.size.height);
		memset(SrcImage.ptr, 0, SrcImage.size.width*(size_t)SrcImage.size.height);

		IMG_UBBUF buf[3];
		buf[0] = SrcImage;
		buf[1] = SrcImage;
		buf[2] = SrcImage;
		CVisImage img(buf);
		
		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			switch (Stinput.segment[j].seg_type)
			{
				
			case ALIGN_REC_LINE_SEGMENT:
				writeLog("LineSeg (%f,%f) (%f,%f) %d\n", Stinput.segment[j].start.x, Stinput.segment[j].start.y,
					Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				if (Stinput.segment[j].valid == 1)
				{
					img.DrawLine(Stinput.segment[j].start, Stinput.segment[j].end, COLORS::Red);
				}
				else
				{
					img.DrawLine(Stinput.segment[j].start, Stinput.segment[j].end, COLORS::Yellow);
				}
				break;
			case ALIGN_REC_ARC_SEGMENT:
				writeLog("ArcSeg (%f,%f) (%f,%f) (%f,%f) %d\n", Stinput.segment[j].center[0].x, Stinput.segment[j].center[0].y,
					Stinput.segment[j].start.x, Stinput.segment[j].start.y, Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				if (Stinput.segment[j].valid == 1)
				{
					
					rco_Arc[0] = Stinput.segment[j].start; rco_Arc[1] = Stinput.segment[j].center[0]; rco_Arc[2] = Stinput.segment[j].end;
					VisMath::MATH_CreateArcBySCEPts(rco_Arc, &temp_Arc);
					temp_Angle = temp_Arc.end_angle - temp_Arc.start_angle;
					if (temp_Angle < 0)temp_Angle += 360;
					length = (IMG_INT)(temp_Arc.radius*fabs(temp_Angle)*D2R);

					for (k = 0; k < length-1; k++)
					{
						angle1 = temp_Angle*k / length + temp_Arc.start_angle;
						tempCoor.x = (temp_Arc.center.x + temp_Arc.radius*cos(angle1*D2R));
						tempCoor.y = (temp_Arc.center.y + temp_Arc.radius*sin(angle1*D2R));
						angle2 = temp_Angle*(k+1) / length + temp_Arc.start_angle;
						coor.x = (temp_Arc.center.x + temp_Arc.radius*cos(angle2*D2R));
						coor.y = (temp_Arc.center.y + temp_Arc.radius*sin(angle2*D2R));
						img.DrawLine(tempCoor, coor, COLORS::Red);
					}
				}
				else
				{
					IMG_RCOORD rco_Arc[3] = { 0 };
					rco_Arc[0] = Stinput.segment[j].start; rco_Arc[1] = Stinput.segment[j].center[0]; rco_Arc[2] = Stinput.segment[j].end;
					VisMath::MATH_CreateArcBySCEPts(rco_Arc, &temp_Arc);
					temp_Angle = temp_Arc.end_angle - temp_Arc.start_angle;
					if (temp_Angle < 0)temp_Angle += 360;
					length = (IMG_INT)(temp_Arc.radius*fabs(temp_Angle)*D2R);

					for (k = 0; k < length-1; k++)
					{
						angle1 = temp_Angle*k / length + temp_Arc.start_angle;
						tempCoor.x = (temp_Arc.center.x + temp_Arc.radius*cos(angle1*D2R));
						tempCoor.y = (temp_Arc.center.y + temp_Arc.radius*sin(angle1*D2R));
						angle2 = temp_Angle*(k + 1) / length + temp_Arc.start_angle;
						coor.x = (temp_Arc.center.x + temp_Arc.radius*cos(angle2*D2R));
						coor.y = (temp_Arc.center.y + temp_Arc.radius*sin(angle2*D2R));
						img.DrawLine(tempCoor, coor, COLORS::Yellow);
						
					}
				}
				break;
			case ALIGN_REC_BSPLINE_SEGMENT:

				//break;
			default:
				THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
				break;
			}

		}
		writeLog("\n");
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("red is valid :\n");

		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
		if (img.Width()*img.Height() < 2096 * 2096 || img.Width()>JPG_SIZE_LIMITATION|| img.Height()>JPG_SIZE_LIMITATION)
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSL\\LOG%05uS_SegmentResult.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		else
			_snprintf(pathname, MAX_FILE_NAME, "%s\\LOG%05uSL\\LOG%05uS_SegmentResult.jpg", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		img.WriteImage(pathname);
		p = strrchr(pathname, '\\') - 10;
		HL_InsertImage(m_pHtmlLog, p);
		HL_PutLineBreak(m_pHtmlLog);

		logfinish();
	}

}

IMG_VVOID CVisAlignSearch::match_segment(CVisImage *srcImg, IMG_INT imgNums, SEARCH_SEGMENT_INPUT &Stinput)
{
	CVisMemPool pool;
	CVisClock clock;
	CVisImage imgEdge;
	int search_status = searchNoErr;
	ALIGN_SEARCH_OPTION *pstSrchOpt = m_SearchOption.GetSearchPara();
	VIS_ALIGN_RECORD *pstRec = m_AlignRecord->GetRecord();
	ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
	if (result->size == 0)
	{
		return;
	}
	IMG_UINT ulReduction = pstSrchOpt->ubRedFactor > pstRec->ulNumOfLayer - 1 ? pstRec->ulNumOfLayer - 1 : pstSrchOpt->ubRedFactor;
	IMG_UINT ulLowestLayer = pstRec->ulHighestLayer + ulReduction;
	IMG_UINT ulHighestLayer = pstRec->ulHighestLayer;
	int i, j, k, m, n;
	IMG_OBJ *pstObj;
	IMG_INT width = Stinput.width;
	IMG_INT height = Stinput.height;
	IMG_INT xOffset = Stinput.xOffset;
	IMG_INT yOffset = Stinput.yOffset;
	//int xMin = 1e6, yMin = 1e6;
	//int xMax = -1e6, yMax = -1e6;
	
	IMG_REAL reduction = pow(0.5, ulHighestLayer), angle;
	IMG_INT iElasticity = Stinput.iElasticity * reduction < 3 ? 3 : Stinput.iElasticity * reduction;

	//IMG_INT fea_point_num = pstRec->ptr->ulNumOfContourPts;
	//IMG_RCOORD *dstCoor = (IMG_RCOORD*)pool.PMalloc(sizeof(IMG_RCOORD)*fea_point_num);
	IMG_COORD coWindowOff = pstRec->stTemplate.coWindowOff;
	IMG_SIZE szWindowSize = pstRec->stTemplate.szWindowSize;
	IMG_RCOORD tempCoor, elaCoor, dstCoor;
	IMG_UBBUF *ubbufEdge = (IMG_UBBUF*)pool.Malloc(sizeof(IMG_UBBUF)*imgNums);;
	ALIGN_REC_SEGMENT tempSeg;
	IMG_INT	 interval = 3, totalPt = 0, length;
	IMG_UWORD uwDebug = Stinput.uwDebug;

	vector<vector<PARA_POINT>>vec_vecParaPts;
	vector<PARA_POINT>vec_tmpParaPts;
	if (Stinput.uwDebug & ALIGN_DEBUG_TIME)
	{
		g_pstClock = &clock;
		clock.Start();
		clock.Click("Match Start");
	}
	else
	{
		g_pstClock = nullptr;
	}
	if (Stinput.uwDebug)
	{
		if (_access(Stinput.strLogPath, 06) != 0)
		{
			_mkdir(Stinput.strLogPath);
		}
	}
	if (Stinput.uwDebug & 513)
	{
		IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL_match.html", Stinput.strLogPath, g_SearchLogIndex);
		logInit(pathname);
		writeLog("Log start\n");
		writeLog("Version Tag: %s\n", VisAlign::VIS_ALIGN_Version());
		writeLog("VisSystem Version Tag: %s\n", VIS_SYSTEM_DLL_Version());
		writeLog("TCL Version Tag: %s\n", TCL_DLL_Version());

#ifdef _WIN64
		writeLog("build on %s %s, x64\n", __DATE__, __TIME__);
#else
		writeLog("build on %s %s, x86\n", __DATE__, __TIME__);
#endif // _WIN64

		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uML", Stinput.strLogPath, g_SearchLogIndex);
		_mkdir(pathname);
		
		//CVisImage srcImage(SrcImage);
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSI.bmp", Stinput.strLogPath, g_SearchLogIndex);
		//srcImage.WriteImage(pathname);

		writeLog("\n");
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("Source CAD Image\n");
		p = strrchr(pathname, '\\') + 1;
		HL_InsertImage(m_pHtmlLog, p);
		//m_SearchOption.SaveOptionToHTMLLog(m_pHtmlLog);

		//_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSO.opt", Stinput.strLogPath, g_SearchLogIndex);
		//m_SearchOption.SaveToFile(pathname);

		//_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSR.rec", Stinput.strLogPath, g_SearchLogIndex);
		//m_AlignRecord->SaveToFile(pathname);

		//_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSE.opt", Stinput.strLogPath, g_SearchLogIndex);
		//Stinput.SaveToFile(pathname);
		writeLog("\n");
		HL_PutLineBreak(m_pHtmlLog);
		writeLog("Segment srcData:\n");
		writeLog("num of segment : %d:\n", Stinput.num_of_segment);
		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			switch (Stinput.segment[j].seg_type)
			{
			case ALIGN_REC_LINE_SEGMENT:
				writeLog("LineSeg (%f,%f) (%f,%f) %d\n", Stinput.segment[j].start.x, Stinput.segment[j].start.y,
					Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				break;
			case ALIGN_REC_ARC_SEGMENT:
				writeLog("ArcSeg (%f,%f) (%f,%f) (%f,%f) %d\n", Stinput.segment[j].center[0].x, Stinput.segment[j].center[0].y,
					Stinput.segment[j].start.x, Stinput.segment[j].start.y, Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				break;
			case ALIGN_REC_BSPLINE_SEGMENT:
			{

				ALIGN_SEGMENT_CURVE curve = Stinput.segment[j].curve;
				writeLog("CurveSeg:num_points dims valid isClosed%d  %d\n", curve.num_points, curve.dims, Stinput.segment[j].valid, curve.isClosed);
				for (int mm = 0; mm < curve.num_points; mm++)
				{
					writeLog("CurveSeg (%f,%f)\n", curve.control_points[mm].x, curve.control_points[mm].y);
				}
			}
			break;
			default:
				break;
			}
		}
	}


	for (i = 0; i < result->size; i++)
	{
		pstObj = result->ptr + i;
		IMG_REAL scale = pow(2.0, ulHighestLayer);
		pstObj->rco.x -= pstRec->rcoRefVector.x*cos(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMx - pstRec->rcoRefVector.y*sin(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMy;
		pstObj->rco.y -= pstRec->rcoRefVector.x*sin(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMx + pstRec->rcoRefVector.y*cos(pstObj->rotation*PI / 180)*pstObj->scale*pstObj->rMy;
		pstObj->rotation -= pstRec->rOrientation;

	}
	if (result->size == 0)
	{
		goto exit;
	}
	for (i = 0; i < ulHighestLayer; i++)
	{
		scale_object_table(m_AlignResult, 0.5);
		width /= 2;
		height /= 2;
		//xOffset /= 2;
		//yOffset /= 2;
		//coWindowOff.x /= 2; coWindowOff.y /= 2;
		//szWindowSize.height /= 2; szWindowSize.width /= 2;
	}

	if (Stinput.uwDebug & 513)
	{
		ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
		writeLog("Final Object:\n");
		HL_PutLineBreak(m_pHtmlLog);
		HTMLLOGGING_TABLE_DATA stTable;
		HL_InitTableData(&stTable);
		stTable.title = "Search Result";
		stTable.tablelinewidth = 0;
		stTable.column = 7;
		stTable.fontweight = FW_Medium;
		stTable.tablealign = TX_CENTER;
		stTable.tablewidth = 50;
		stTable.tablelinewidth = 1;
		stTable.bgColorOddLine = 0xffff7f;
		stTable.formatstring = "%.6f";
		stTable.datatype = DT_REAL;
		stTable.heading = (IMG_CHAR **)pool.Malloc(7 * sizeof(IMG_CHAR *));
		stTable.heading[0] = "ID";
		stTable.heading[1] = "PosX";
		stTable.heading[2] = "PosY";
		stTable.heading[3] = "Scale";
		stTable.heading[4] = "Rotation";
		stTable.heading[5] = "Fitting Score";
		stTable.heading[6] = "Matching Score";
		HL_CreateTableHeader(m_pHtmlLog, &stTable);
		for (int i = 0; i < m_AlignResult.Size(); i++)
		{
			char value[7][20];
			if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
			else			stTable.bgColorOddLine = 0xffffcf;
			_snprintf(value[0], sizeof(value[0]), "%d", result->ptr[i].uwID);
			_snprintf(value[1], sizeof(value[1]), "%.3f", result->ptr[i].rco.x);
			_snprintf(value[2], sizeof(value[2]), "%.3f", result->ptr[i].rco.y);
			_snprintf(value[3], sizeof(value[3]), "%.6f", result->ptr[i].scale);
			_snprintf(value[4], sizeof(value[4]), "%.6f", result->ptr[i].rotation);
			_snprintf(value[5], sizeof(value[5]), "%.3f", result->ptr[i].rLikeScore);
			_snprintf(value[6], sizeof(value[6]), "%.3f", result->ptr[i].rMatched);
			HL_CreateTableRow(m_pHtmlLog, &stTable, value[0], value[1], value[2], value[3], value[4], value[5], value[6]);
		}
		HL_CloseTable(m_pHtmlLog);
		HL_Printf(m_pHtmlLog, "\n");

		writeLog("\n");
		//writeLog("batch matching start:");
		HL_PutLineBreak(m_pHtmlLog);
	}

	IMG_UBBUF ubbSrc;
	ubbSrc.size = szWindowSize;
	ubbSrc.linestep = szWindowSize.width;
	ubbSrc.ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*(size_t)ubbSrc.size.width*ubbSrc.size.height);
	//ubbufEdge.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*width*height);
	//ubbufEdge.size = { width,height };
	//ubbufEdge.linestep = width;
	//memset(ubbufEdge.ptr, 0, sizeof(IMG_UBYTE)*width*height);

	EDGE_INFORMATION *edgePts = (EDGE_INFORMATION*)pool.Malloc(sizeof(EDGE_INFORMATION)*(size_t)width*height);
	memset(edgePts, 0, sizeof(EDGE_INFORMATION)*(size_t)width*height);
	IMG_REAL *segScore = (IMG_REAL*)pool.Malloc(sizeof(IMG_REAL)*imgNums*Stinput.num_of_segment);
	IMG_REAL rDisMatch, rMagMatch;
	IMG_RCOORD *pointsInCAD = nullptr;
	IMG_INT segPointNums = 0;
	IMG_INT searCount = 2;
	IMG_RCOORD circleCenter;
	IMG_ULWORD circleType;
	IMG_ARCT tempArc;
	IMG_REAL tempAngle, angle1, angle2;
	IMG_RCOORD rcoArc[3], coor;
	IMG_CHAR pathname1[FILENAME_MAX_LENGTH], *p1;

	
	for (i = 0; i < Stinput.num_of_segment; i++)
	{
		tempSeg = *(Stinput.segment + i);

		if (tempSeg.seg_type == ALIGN_REC_BSPLINE_SEGMENT)
		{
			
			if (tempSeg.curve.num_points == 0)
			{
				vec_tmpParaPts.clear();
				continue;
			}
			IMG_RCOORD *tmpCoor = new IMG_RCOORD[tempSeg.curve.num_points];
			for (j = 0; j < tempSeg.curve.num_points; j++)
			{
				tmpCoor[j].x = (tempSeg.curve.control_points[j].x - Stinput.xOffset) * reduction;
				tmpCoor[j].y = (tempSeg.curve.control_points[j].y - Stinput.yOffset) * reduction;
			}
			CVisNURBSCurve nurbsCurve(tempSeg.curve.isClosed);
			nurbsCurve.SetInputPara(tmpCoor, tempSeg.curve.num_points, tempSeg.curve.dims);
			nurbsCurve.GetCurvePts(200, vec_tmpParaPts);

			if (vec_tmpParaPts.size() > 0)
			{
				vec_vecParaPts.push_back(vec_tmpParaPts);
			}
			vec_tmpParaPts.clear();
			if (tmpCoor)
			{
				delete[]tmpCoor;
				tmpCoor = nullptr;
			}
		}
	}
	int curveIndex = 0;
	for (i = 0; i < imgNums; i++)
	{
		ubbufEdge[i].ptr = (IMG_UBYTE*)pool.Malloc(sizeof(IMG_UBYTE)*(size_t)width*height);
		ubbufEdge[i].size = { width,height };
		ubbufEdge[i].linestep = width;
		memset(ubbufEdge[i].ptr, 0, sizeof(IMG_UBYTE)*(size_t)width*height);
		memset(edgePts, 0, sizeof(EDGE_INFORMATION)*(size_t)width*height);

		if (Stinput.uwDebug & 256)
		{
			char msg[MAX_FILE_NAME];
			_snprintf_s(msg, sizeof(msg), "match_img%d-------", i + 1);
			clock.Click(msg);
		}
		CVisAlignSearchInterData stAlignExData;
		stAlignExData.pstOption = m_SearchOption.GetSearchPara();
		stAlignExData.uwDebug = 0;
		//m_AlignResult.SetResultNum(0);
		//m_AlignResult.SetRecordTimeStamp(m_AlignRecord->GetTimeStamp());
		stAlignExData.highest_level = ulHighestLayer;
		stAlignExData.pstRec = pstRec;
		IMG_UBBUF ubbTemp;
		srcImg[i].GetImage(&ubbTemp);
		ippiCopy_8u_C1R(ubbTemp.ptr + coWindowOff.y*(size_t)ubbTemp.linestep + coWindowOff.x, ubbTemp.linestep, ubbSrc.ptr, ubbSrc.linestep, IppiSize{ ubbSrc.size.width,ubbSrc.size.height });
		
		if (Stinput.uwDebug & ALIGN_DEBUG_TIME)
		{
			clock.Click("Build Roi img");
		}
		if (Stinput.uwDebug & 513)
		{
			IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
			CVisImage srcImage(ubbSrc);
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uS_SearchImg%d.bmp", Stinput.strLogPath, g_SearchLogIndex, i+1);
			srcImage.WriteImage(pathname);
			/*writeLog("------------SearchImg%d------------", i+1);
			p = strrchr(pathname, '\\') + 1;
			HL_InsertImage(m_pHtmlLog, p);*/
		}
		stAlignExData.PubBufSrc(&ubbSrc);
		stAlignExData.PubBufGaussian(&ubbSrc);
		//pyramid
		stAlignExData.pyramidInit(pool);
		if (pyramid(stAlignExData) != 0)
		{
			search_status = pyramidErr;
			goto exit;
		}
		stAlignExData.edgeDetectInit(ulHighestLayer);
		if (edgeExtract_dstRoi(stAlignExData) != 0)
		{
			search_status = edgeDetectErr;
			goto exit;
		}
		if (Stinput.uwDebug & ALIGN_DEBUG_TIME)
		{
			clock.Click("after_edgedetection");
		}

		for (j = 0; j < result->size; j++)
		{
			curveIndex = 0;
			pstObj = result->ptr + j;
			for (k = 0; k < stAlignExData.edgeNum; k++)
			{
				tempCoor.x = stAlignExData.pedgeArray[k].rcoPos.x - pstRec->ptr->rcoRef.x;
				tempCoor.y = stAlignExData.pedgeArray[k].rcoPos.y - pstRec->ptr->rcoRef.y;
				Align_Translate_RCOORD_By_Obj(&tempCoor, 1, pstObj, &dstCoor);
				if ((int)(dstCoor.x + 0.5)<0 || (int)(dstCoor.x + 0.5)>ubbufEdge[i].size.width-1 || (int)(dstCoor.y + 0.5)<0 || (int)(dstCoor.y + 0.5)>ubbufEdge[i].size.height-1)
				{
					continue;
				}
				ubbufEdge[i].ptr[(int)(dstCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(dstCoor.x + 0.5)] = 255;
				edgePts[(int)(dstCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(dstCoor.x + 0.5)] = stAlignExData.pedgeArray[k];
			}
			for (m = 0; m < Stinput.num_of_segment; m++)
			{
				totalPt = 0;
				rDisMatch = 0.f;
				rMagMatch = 0.f;
				tempSeg = *(Stinput.segment + m);
				tempSeg.start.x -= Stinput.xOffset; tempSeg.start.y -= Stinput.yOffset;
				tempSeg.end.x -= Stinput.xOffset; tempSeg.end.y -= Stinput.yOffset;
				tempSeg.center[0].x -= Stinput.xOffset; tempSeg.center[0].y -= Stinput.yOffset;
				tempSeg.center[1].x -= Stinput.xOffset; tempSeg.center[1].y -= Stinput.yOffset;

				vector<IMG_RCOORD>vecCoor;
				switch (tempSeg.seg_type)
				{
				case ALIGN_REC_LINE_SEGMENT:
					length = (IMG_INT)pow(pow(tempSeg.start.x - tempSeg.end.x, 2) + pow(tempSeg.start.y - tempSeg.end.y, 2), 0.5);
					length *= reduction;
					angle = atan2(tempSeg.end.y - tempSeg.start.y, tempSeg.end.x - tempSeg.start.x) / D2R - 90;
					if (angle < 0)angle += 360;
					for (k = 0; k < length; k++)
					{
						tempCoor.x = ((tempSeg.end.x - tempSeg.start.x)*k / length + tempSeg.start.x)*reduction;
						tempCoor.y = ((tempSeg.end.y - tempSeg.start.y)*k / length + tempSeg.start.y)*reduction;
						for (n = 0; n <= iElasticity; n++)
						{
							elaCoor.x = tempCoor.x + n*cos(angle*D2R);
							elaCoor.y = tempCoor.y + n*sin(angle*D2R);
							if (ubbufEdge[i].ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)] == 255)
							{
								totalPt += 1;
								rDisMatch += n;
								rMagMatch += edgePts[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)].gradient;
								break;
							}
							elaCoor.x = tempCoor.x - n*cos(angle*D2R);
							elaCoor.y = tempCoor.y - n*sin(angle*D2R);
							if (ubbufEdge[i].ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)] == 255)
							{
								totalPt += 1;
								rDisMatch += n;
								rMagMatch += edgePts[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)].gradient;
								break;
							}
						}
					}
					break;
				case ALIGN_REC_ARC_SEGMENT:
					rcoArc[0] = tempSeg.start; rcoArc[1] = tempSeg.center[0]; rcoArc[2] = tempSeg.end;
					VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
				
					tempAngle = tempArc.end_angle - tempArc.start_angle;
					if (tempAngle < 0)tempAngle += 360;
					length = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
					length *= reduction;
					circleCenter = tempSeg.center[0];
					circleCenter.x *= reduction;
					circleCenter.y *= reduction;
					for (k = 0; k < length; k++)
					{
						angle = tempAngle*k / length + tempArc.start_angle;
						tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R))*reduction;
						tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R))*reduction;

						for (n = 0; n <= iElasticity; n++)
						{
							elaCoor.x = tempCoor.x + n*cos(angle*D2R);
							elaCoor.y = tempCoor.y + n*sin(angle*D2R);
							if (ubbufEdge[i].ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)] == 255)
							{
								totalPt += 1;
								rDisMatch += n;
								rMagMatch += edgePts[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)].gradient;
								vecCoor.push_back({ round(elaCoor.x),  round(elaCoor.y) });
								break;
							}
							elaCoor.x = tempCoor.x - n*cos(angle*D2R);
							elaCoor.y = tempCoor.y - n*sin(angle*D2R);
							if (ubbufEdge[i].ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)] == 255)
							{
								totalPt += 1;
								rDisMatch += n;
								rMagMatch += edgePts[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)].gradient;
								vecCoor.push_back({ round(elaCoor.x),  round(elaCoor.y) });
								break;
							}
						}
					}
					break;
				case ALIGN_REC_BSPLINE_SEGMENT:
				{
					vec_tmpParaPts = vec_vecParaPts[curveIndex];
					
					for (k = 0; k < length; k++)
					{
						angle = vec_tmpParaPts[k].angle;
						for (n = 0; n <= iElasticity; n++)
						{
							elaCoor.x = vec_tmpParaPts[k].pt.x + n*cos(angle*D2R);
							elaCoor.y = vec_tmpParaPts[k].pt.y + n*sin(angle*D2R);
							if (ubbufEdge[i].ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)] == 255)
							{
								totalPt += 1;
								rDisMatch += n;
								rMagMatch += edgePts[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)].gradient;
								vecCoor.push_back({ round(elaCoor.x),  round(elaCoor.y) });
								break;
							}
							elaCoor.x = tempCoor.x - n*cos(angle*D2R);
							elaCoor.y = tempCoor.y - n*sin(angle*D2R);
							if (ubbufEdge[i].ptr[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)] == 255)
							{
								totalPt += 1;
								rDisMatch += n;
								rMagMatch += edgePts[(int)(elaCoor.y + 0.5)*(size_t)ubbufEdge[i].linestep + (int)(elaCoor.x + 0.5)].gradient;
								vecCoor.push_back({ round(elaCoor.x),  round(elaCoor.y) });
								break;
							}
						}
					}

					vec_tmpParaPts.clear();
					curveIndex++;
				}

				break;
				default:
					THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
					break;
				}


				if (totalPt < length/* / interval*/*Stinput.rAcceptScore / pstObj->scale)
				{
					segScore[m*imgNums + i] = -1.f;
				}
				else
				{
					rDisMatch /= totalPt;
					rMagMatch /= totalPt;
					segScore[m*imgNums + i] = log(1 + Align_Sigmoid(rMagMatch, 200, 10)) +
						2 * log(1 + Align_Sigmoid(rDisMatch, 0, iElasticity));

					if (tempSeg.seg_type == ALIGN_REC_ARC_SEGMENT&&tempSeg.usePara != 0)
					{
						segPointNums = vecCoor.size();
						pointsInCAD = (IMG_RCOORD*)pool.Malloc(sizeof(IMG_RCOORD)*(size_t)segPointNums);

						for (k = 0; k < segPointNums; k++)
						{
							Align_Reverse_Translate_RCOORD_By_Obj(&vecCoor[k], 1, pstObj, &vecCoor[k]);
							vecCoor[k].x += pstRec->ptr->rcoRef.x; vecCoor[k].y += pstRec->ptr->rcoRef.y;
							pointsInCAD[k].x = vecCoor[k].x / reduction;
							pointsInCAD[k].y = vecCoor[k].y / reduction;
						}
						Align_Reverse_Translate_RCOORD_By_Obj(&circleCenter, 1, pstObj, &circleCenter);
						circleCenter.x += pstRec->ptr->rcoRef.x; circleCenter.y += pstRec->ptr->rcoRef.y;
						circleCenter.x = circleCenter.x / reduction;
						circleCenter.y = circleCenter.y / reduction;
						if (points_compute_circletype(&ubbSrc, pointsInCAD, segPointNums, circleCenter, circleType, searCount) != 0
							|| circleType != tempSeg.circleType)
						{
							segScore[m*imgNums + i] = -1.f;
						}

					}
				}

				
				vecCoor.clear();

				//memset(ubbufEdge.ptr, 0, sizeof(IMG_UBYTE)*width*height);
				if (Stinput.uwDebug & ALIGN_DEBUG_TIME)
				{
					clock.Click("after match cad");
				}
			}

		}

	}
	int index;
	IMG_REAL rMaxSeg;
	for (m = 0; m < Stinput.num_of_segment; m++)
	{
		ippsMaxIndx_32f(segScore + m*imgNums, imgNums, &rMaxSeg, &index);
		if (fabs(rMaxSeg + 1) < 1e-7)
		{
			Stinput.segment[m].valid = 0;
		}
		else
		{
			Stinput.segment[m].valid = index + 1;
		}
	}

	if (Stinput.uwDebug & ALIGN_DEBUG_TIME)
	{
		clock.Click("after select segments");
	}
	//IMG_RCOORD rco_Arc[3], coor;
	//IMG_ARCT temp_Arc;
	//IMG_REAL temp_Angle, angle1, angle2;
	//IMG_CIRCLE temp_circle;
	
	if (Stinput.uwDebug & 513)
	{
		
		writeLog("Final result:(red is valid)\n");
		HL_PutLineBreak(m_pHtmlLog);
		for (i = 0; i < imgNums; i++)
		{
			writeLog("------------SearchImg%d------------", i + 1);
			_snprintf(pathname1, FILENAME_MAX_LENGTH, "%s\\LOG%05uS_SearchImg%d.bmp", Stinput.strLogPath, g_SearchLogIndex, i + 1);
			p1 = strrchr(pathname1, '\\') + 1;
			//HL_InsertImage(m_pHtmlLog, p1);

			/*HL_PutLineBreak(m_pHtmlLog);
			writeLog("\n");
			writeLog("Search segment result:\n");
			writeLog("num of segment : %d:\n", Stinput.num_of_segment);*/

			/*IMG_UBBUF SrcImage;
			SrcImage.size.width = Stinput.width; SrcImage.size.height = Stinput.height;
			SrcImage.linestep = SrcImage.size.width;
			SrcImage.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*SrcImage.size.width*SrcImage.size.height);
			memset(SrcImage.ptr, 0, SrcImage.size.width*SrcImage.size.height);*/

			IMG_UBBUF ubbTemp;
			srcImg[i].GetImage(&ubbTemp);
			IMG_UBBUF buf[3];
			buf[0] = ubbTemp;
			buf[1] = ubbTemp;
			buf[2] = ubbTemp;
			CVisImage img(buf);

			//IMG_UBBUF bufEdge[3];
			//bufEdge[0] = ubbufEdge[i];
			//bufEdge[1] = ubbufEdge[i];
			//bufEdge[2] = ubbufEdge[i];
			imgEdge.SetImage(ubbufEdge[i]);
			imgEdge.GrayToRGB();

			IMG_RCOORD rTempCoor1, rTempCoor2, rTempCoor3, rTempCoor4;
			pstObj = result->ptr;
			ALIGN_REC_SEGMENT drawSeg;
			for (j = 0; j < Stinput.num_of_segment; j++)
			{
				drawSeg = *(Stinput.segment + j);

				rTempCoor1.x = drawSeg.start.x - Stinput.xOffset; rTempCoor1.y = drawSeg.start.y - Stinput.yOffset;
				rTempCoor1.x *= reduction; rTempCoor1.y *= reduction;
				rTempCoor2.x = drawSeg.end.x - Stinput.xOffset; rTempCoor2.y = drawSeg.end.y - Stinput.yOffset;
				rTempCoor2.x *= reduction; rTempCoor2.y *= reduction;
				rTempCoor3.x = drawSeg.center[0].x - Stinput.xOffset; rTempCoor3.y = drawSeg.center[0].y - Stinput.yOffset;
				rTempCoor3.x *= reduction; rTempCoor3.y *= reduction;
				Align_Reverse_Translate_RCOORD_By_Obj(&rTempCoor1, 1, pstObj, &rTempCoor1);
				rTempCoor1.x += pstRec->ptr->rcoRef.x; rTempCoor1.y += pstRec->ptr->rcoRef.y;
				rTempCoor1.x = rTempCoor1.x / reduction + coWindowOff.x;
				rTempCoor1.y = rTempCoor1.y / reduction + coWindowOff.y;
				
				Align_Reverse_Translate_RCOORD_By_Obj(&rTempCoor2, 1, pstObj, &rTempCoor2);
				rTempCoor2.x += pstRec->ptr->rcoRef.x; rTempCoor2.y += pstRec->ptr->rcoRef.y;
				rTempCoor2.x = rTempCoor2.x / reduction + coWindowOff.x;
				rTempCoor2.y = rTempCoor2.y / reduction + coWindowOff.y;
			
				Align_Reverse_Translate_RCOORD_By_Obj(&rTempCoor3, 1, pstObj, &rTempCoor3);
				rTempCoor3.x += pstRec->ptr->rcoRef.x; rTempCoor3.y += pstRec->ptr->rcoRef.y;
				rTempCoor3.x = rTempCoor3.x / reduction + coWindowOff.x;
				rTempCoor3.y = rTempCoor3.y / reduction + coWindowOff.y;

				vector<IMG_RCOORD>vec_tmpCoor;
				if (drawSeg.seg_type == ALIGN_REC_BSPLINE_SEGMENT &&drawSeg.curve.num_points != 0)
				{
					for (k = 0; k < drawSeg.curve.num_points; k++)
					{
						rTempCoor4.x = drawSeg.curve.control_points[k].x - Stinput.xOffset;
						rTempCoor4.y = drawSeg.curve.control_points[k].y - Stinput.yOffset;
						rTempCoor4.x *= reduction; rTempCoor4.y *= reduction;
						Align_Reverse_Translate_RCOORD_By_Obj(&rTempCoor4, 1, pstObj, &rTempCoor4);
						rTempCoor4.x += pstRec->ptr->rcoRef.x; rTempCoor4.y += pstRec->ptr->rcoRef.y;
						rTempCoor4.x = rTempCoor4.x / reduction + coWindowOff.x;
						rTempCoor4.y = rTempCoor4.y / reduction + coWindowOff.y;
						vec_tmpCoor.push_back(rTempCoor4);
					}
					
				}
		
				switch (Stinput.segment[j].seg_type)
				{

				case ALIGN_REC_LINE_SEGMENT:
					/*writeLog("LineSeg (%f,%f) (%f,%f) %d\n", Stinput.segment[j].start.x, Stinput.segment[j].start.y,
						Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);*/
					if (/*fabs(segScore[j*imgNums+i] + 1) < 1e-5*/drawSeg.valid != i + 1)
					{
						img.DrawLine(rTempCoor1, rTempCoor2, COLORS::Yellow);
					}
					else
					{
						img.DrawLine(rTempCoor1, rTempCoor2, COLORS::Red);
					}
					break;
				case ALIGN_REC_ARC_SEGMENT:
					/*writeLog("ArcSeg (%f,%f) (%f,%f) (%f,%f) %d\n", Stinput.segment[j].center[0].x, Stinput.segment[j].center[0].y,
						Stinput.segment[j].start.x, Stinput.segment[j].start.y, Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);*/
					
					if (/*fabs(segScore[j*imgNums + i] + 1) < 1e-5*/drawSeg.valid != i + 1)
					{

						//rco_Arc[0] = { Stinput.segment[j].start.x - Stinput.xOffset, Stinput.segment[j].start.y - Stinput.yOffset }; 
						//rco_Arc[1] = { Stinput.segment[j].center[0].x - Stinput.xOffset, Stinput.segment[j].center[0].y - Stinput.yOffset };
						//rco_Arc[2] = { Stinput.segment[j].end.x - Stinput.xOffset, Stinput.segment[j].end.y - Stinput.yOffset };
						rcoArc[0] = rTempCoor1;
						rcoArc[1] = rTempCoor3;
						rcoArc[2] = rTempCoor2;
						VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
						tempAngle = tempArc.end_angle - tempArc.start_angle;
						if (tempAngle < 0)tempAngle += 360;
						length = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);

						for (k = 0; k < length - 1; k++)
						{
							angle1 = tempAngle*k / length + tempArc.start_angle;
							tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle1*D2R));
							tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle1*D2R));
							angle2 = tempAngle*(k + 1) / length + tempArc.start_angle;
							coor.x = (tempArc.center.x + tempArc.radius*cos(angle2*D2R));
							coor.y = (tempArc.center.y + tempArc.radius*sin(angle2*D2R));
							img.DrawLine(tempCoor, coor, COLORS::Yellow);
						}
					}
					else
					{
						//IMG_RCOORD rco_Arc[3] = { 0 };
						//rco_Arc[0] = { Stinput.segment[j].start.x - Stinput.xOffset, Stinput.segment[j].start.y - Stinput.yOffset };
						//rco_Arc[1] = { Stinput.segment[j].center[0].x - Stinput.xOffset, Stinput.segment[j].center[0].y - Stinput.yOffset };
						//rco_Arc[2] = { Stinput.segment[j].end.x - Stinput.xOffset, Stinput.segment[j].end.y - Stinput.yOffset };
						rcoArc[0] = rTempCoor1;
						rcoArc[1] = rTempCoor3;
						rcoArc[2] = rTempCoor2;
						VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
						tempAngle = tempArc.end_angle - tempArc.start_angle;
						if (tempAngle < 0)tempAngle += 360;
						length = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);

						for (k = 0; k < length - 1; k++)
						{
							angle1 = tempAngle*k / length + tempArc.start_angle;
							tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle1*D2R));
							tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle1*D2R));
							angle2 = tempAngle*(k + 1) / length + tempArc.start_angle;
							coor.x = (tempArc.center.x + tempArc.radius*cos(angle2*D2R));
							coor.y = (tempArc.center.y + tempArc.radius*sin(angle2*D2R));
							img.DrawLine(tempCoor, coor, COLORS::Red);

						}
					}
					break;
				case ALIGN_REC_BSPLINE_SEGMENT:
				{
					ALIGN_SEGMENT_CURVE curve = drawSeg.curve;
					if (curve.num_points == 0 || !curve.control_points)
					{
						THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
					}
					IMG_RCOORD *pCoor = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*curve.num_points);
					for (int mm = 0; mm < vec_tmpCoor.size(); mm++)
					{
						pCoor[mm] = vec_tmpCoor[mm];
					}
					CVisNURBSCurve nurbsCurve(curve.isClosed);
					nurbsCurve.SetInputPara(pCoor, curve.num_points, curve.dims);
					vector<PARA_POINT> vecDstPoints;
					nurbsCurve.GetCurvePts(200, vecDstPoints);
					PARA_POINT tmpParaPt;
					if (drawSeg.valid != i + 1)
					{
						for (k = 0; k < vecDstPoints.size() - 1; k++)
						{
							tempCoor.x = vecDstPoints[k].pt.x;
							tempCoor.y = vecDstPoints[k].pt.y;
							coor.x = vecDstPoints[k + 1].pt.x;
							coor.y = vecDstPoints[k + 1].pt.y;
							
							img.DrawLine(tempCoor, coor, COLORS::Yellow);
						}
					}
					else
					{
						for (k = 0; k < vecDstPoints.size() - 1; k++)
						{
							tempCoor.x = vecDstPoints[k].pt.x;
							tempCoor.y = vecDstPoints[k].pt.y;
							coor.x = vecDstPoints[k + 1].pt.x;
							coor.y = vecDstPoints[k + 1].pt.y;

							img.DrawLine(tempCoor, coor, COLORS::Red);
						}
					}
					if (pCoor)
					{
						delete[]pCoor;
						pCoor = nullptr;
					}
					vecDstPoints.clear();
				}
				break;
				default:
					THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
					break;
				}

			}
			writeLog("\n");
			//HL_PutLineBreak(m_pHtmlLog);
			//writeLog("red is valid :\n");
			writeLog("img%d result:\n", i+1);

			//IMG_CHAR pathname[FILENAME_MAX_LENGTH], *p;
			if (img.Width()*img.Height() < 2096 * 2096 || img.Width()>JPG_SIZE_LIMITATION ||img.Height()>JPG_SIZE_LIMITATION)
				_snprintf(pathname1, FILENAME_MAX_LENGTH, "%s\\LOG%05uML\\LOG%05uS_MatchResult%d.png", Stinput.strLogPath, g_SearchLogIndex, g_SearchLogIndex, i+1);
			else
				_snprintf(pathname1, FILENAME_MAX_LENGTH, "%s\\LOG%05uML\\LOG%05uS_MatchResult%d.jpg", Stinput.strLogPath, g_SearchLogIndex, g_SearchLogIndex, i+1);
			img.WriteImage(pathname1);
			p1 = strrchr(pathname1, '\\') - 10;
			HL_InsertImage(m_pHtmlLog, p1);
			//IMG_ARCT tempArc;
			for (m = 0; m < Stinput.num_of_segment; m++)
			{
				tempSeg = *(Stinput.segment + m);
				tempSeg.start.x -= Stinput.xOffset; tempSeg.start.y -= Stinput.yOffset;
				tempSeg.end.x -= Stinput.xOffset; tempSeg.end.y -= Stinput.yOffset;
				tempSeg.center[0].x -= Stinput.xOffset; tempSeg.center[0].y -= Stinput.yOffset;
				tempSeg.center[1].x -= Stinput.xOffset; tempSeg.center[1].y -= Stinput.yOffset;
				rTempCoor1.x = tempSeg.start.x * reduction; rTempCoor1.y = tempSeg.start.y * reduction;
				rTempCoor2.x = tempSeg.end.x * reduction; rTempCoor2.y = tempSeg.end.y * reduction;
				rTempCoor3.x = tempSeg.center[0].x * reduction; rTempCoor3.y = tempSeg.center[0].y * reduction;

				vector<IMG_RCOORD>vec_tmpCoor;
				if (tempSeg.seg_type == ALIGN_REC_BSPLINE_SEGMENT &&tempSeg.curve.num_points != 0)
				{
					for (k = 0; k < tempSeg.curve.num_points; k++)
					{
						rTempCoor4.x = tempSeg.curve.control_points[k].x - Stinput.xOffset;
						rTempCoor4.y = tempSeg.curve.control_points[k].y - Stinput.yOffset;
						rTempCoor4.x *= reduction; rTempCoor4.y *= reduction;
						vec_tmpCoor.push_back(rTempCoor4);
					}

				}
				switch (tempSeg.seg_type)
				{
				case ALIGN_REC_LINE_SEGMENT:
					/*length = (IMG_INT)pow(pow(tempSeg.start.x - tempSeg.end.x, 2) + pow(tempSeg.start.y - tempSeg.end.y, 2), 0.5);
					length *= reduction;
					angle = atan2(tempSeg.end.y - tempSeg.start.y, tempSeg.end.x - tempSeg.start.x) / D2R - 90;
					if (angle < 0)angle += 360;
					for (k = 0; k < length; k++)
					{
						tempCoor.x = ((tempSeg.end.x - tempSeg.start.x)*k / length + tempSeg.start.x)*reduction;
						tempCoor.y = ((tempSeg.end.y - tempSeg.start.y)*k / length + tempSeg.start.y)*reduction;
						if (fabs(segScore[m*imgNums + i] + 1) < 1e-5)
						{
							imgEdge.DrawPoint(&tempCoor, 1, COLORS::Yellow);
						}
						else
						{
							imgEdge.DrawPoint(&tempCoor, 1, COLORS::Red);
						}
					}*/
					if (fabs(segScore[m*imgNums + i] + 1) < 1e-5)
					{
						imgEdge.DrawLine(rTempCoor1, rTempCoor2, COLORS::Yellow);
					}
					else
					{
						imgEdge.DrawLine(rTempCoor1, rTempCoor2, COLORS::Red);
					}
					break;
				case ALIGN_REC_ARC_SEGMENT:
					//IMG_RCOORD rcoArc[3]; //rcoArc[0] = tempSeg.start; rcoArc[1] = tempSeg.center[0]; rcoArc[2] = tempSeg.end;
					rcoArc[0] = rTempCoor1;
					rcoArc[1] = rTempCoor3;
					rcoArc[2] = rTempCoor2;
					VisMath::MATH_CreateArcBySCEPts(rcoArc, &tempArc);
					//IMG_REAL tempAngle;
					tempAngle = tempArc.end_angle - tempArc.start_angle;
					if (tempAngle < 0)tempAngle += 360;
					/*length = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);
					length *= reduction;

					for (k = 0; k < length; k++)
					{
						angle = tempAngle*k / length + tempArc.start_angle;
						tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle*D2R))*reduction;
						tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle*D2R))*reduction;
						if (fabs(segScore[m*imgNums + i] + 1) < 1e-5)
						{
							imgEdge.DrawPoint(&tempCoor, 1, COLORS::Yellow);
						}
						else
						{
							imgEdge.DrawPoint(&tempCoor, 1, COLORS::Red);
						}
					}*/
					length = (IMG_INT)(tempArc.radius*fabs(tempAngle)*D2R);

					if (fabs(segScore[m*imgNums + i] + 1) < 1e-5)
					{
						for (k = 0; k < length - 1; k++)
						{
							angle1 = tempAngle*k / length + tempArc.start_angle;
							tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle1*D2R));
							tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle1*D2R));
							angle2 = tempAngle*(k + 1) / length + tempArc.start_angle;
							coor.x = (tempArc.center.x + tempArc.radius*cos(angle2*D2R));
							coor.y = (tempArc.center.y + tempArc.radius*sin(angle2*D2R));
							imgEdge.DrawLine(tempCoor, coor, COLORS::Yellow);
						}
					}
					else
					{
						for (k = 0; k < length - 1; k++)
						{
							angle1 = tempAngle*k / length + tempArc.start_angle;
							tempCoor.x = (tempArc.center.x + tempArc.radius*cos(angle1*D2R));
							tempCoor.y = (tempArc.center.y + tempArc.radius*sin(angle1*D2R));
							angle2 = tempAngle*(k + 1) / length + tempArc.start_angle;
							coor.x = (tempArc.center.x + tempArc.radius*cos(angle2*D2R));
							coor.y = (tempArc.center.y + tempArc.radius*sin(angle2*D2R));
							imgEdge.DrawLine(tempCoor, coor, COLORS::Red);
						}
					}
					break;
				case ALIGN_REC_BSPLINE_SEGMENT:
				{
					ALIGN_SEGMENT_CURVE curve = tempSeg.curve;
					if (curve.num_points == 0 || !curve.control_points)
					{
						THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
					}
					IMG_RCOORD *pCoor = (IMG_RCOORD *)pool.Malloc(sizeof(IMG_RCOORD)*curve.num_points);
					for (int mm = 0; mm < vec_tmpCoor.size(); mm++)
					{
						pCoor[mm] = vec_tmpCoor[mm];
					}
					CVisNURBSCurve nurbsCurve(curve.isClosed);
					nurbsCurve.SetInputPara(pCoor, curve.num_points, curve.dims);
					vector<PARA_POINT> vecDstPoints;
					nurbsCurve.GetCurvePts(200, vecDstPoints);
					PARA_POINT tmpParaPt;
					if (fabs(segScore[m*imgNums + i] + 1) < 1e-5)
					{
						for (k = 0; k < vecDstPoints.size() - 1; k++)
						{
							tempCoor.x = vecDstPoints[k].pt.x;
							tempCoor.y = vecDstPoints[k].pt.y;
							coor.x = vecDstPoints[k + 1].pt.x;
							coor.y = vecDstPoints[k + 1].pt.y;

							imgEdge.DrawLine(tempCoor, coor, COLORS::Yellow);
						}
					}
					else
					{
						for (k = 0; k < vecDstPoints.size() - 1; k++)
						{
							tempCoor.x = vecDstPoints[k].pt.x;
							tempCoor.y = vecDstPoints[k].pt.y;
							coor.x = vecDstPoints[k + 1].pt.x;
							coor.y = vecDstPoints[k + 1].pt.y;

							imgEdge.DrawLine(tempCoor, coor, COLORS::Red);
						}
					}
					if (pCoor)
					{
						delete[]pCoor;
						pCoor = nullptr;
					}
					vecDstPoints.clear();
				}
				break;
				default:
					THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
					break;
				}
				vec_tmpCoor.clear();
			}
			if (imgEdge.Width()*imgEdge.Height() < 2096 * 2096)
				_snprintf(pathname1, FILENAME_MAX_LENGTH, "%s\\LOG%05uML\\LOG%05uS_EdgeMatchResult%d.png", Stinput.strLogPath, g_SearchLogIndex, g_SearchLogIndex, i + 1);
			else
				_snprintf(pathname1, FILENAME_MAX_LENGTH, "%s\\LOG%05uML\\LOG%05uS_EdgeMatchResult%d.jpg", Stinput.strLogPath, g_SearchLogIndex, g_SearchLogIndex, i + 1);
			imgEdge.WriteImage(pathname1);
			p1 = strrchr(pathname1, '\\') - 10;
			HL_InsertImage(m_pHtmlLog, p1);

			HL_PutLineBreak(m_pHtmlLog);

		}
		
		//IMG_UBBUF SrcImage;
		//SrcImage.size.width = Stinput.width; SrcImage.size.height = Stinput.height;
		//SrcImage.linestep = SrcImage.size.width;
		//SrcImage.ptr = (IMG_UBYTE*)pool.PMalloc(sizeof(IMG_UBYTE)*(size_t)SrcImage.size.width*SrcImage.size.height);
		//memset(SrcImage.ptr, 0, SrcImage.size.width*SrcImage.size.height);


		_snprintf(pathname1, FILENAME_MAX_LENGTH, "%s\\LOG%05uML\\LOG%05uS_MatchResult.txt", Stinput.strLogPath, g_SearchLogIndex, g_SearchLogIndex);
		FILE *resultScore;
		resultScore = fopen(pathname1, "w+");
		fprintf(resultScore, "rows is segments, cols is imgs\n");
		for (i = 0; i < Stinput.num_of_segment; i++)
		{
			for (j = 0; j < imgNums; j++)
			{
				fprintf(resultScore, "%.6f ", segScore[i*imgNums + j]);
			}
			fprintf(resultScore, "\n");
		}
		fclose(resultScore);

		//ALIGN_SRCH_RESULT *result = m_AlignResult.Result();
		writeLog("Result:\n");
		HL_PutLineBreak(m_pHtmlLog);

		HTMLLOGGING_TABLE_DATA stTable;
		HL_InitTableData(&stTable);
		_snprintf(pathname1, FILENAME_MAX_LENGTH, "Match Result%d", Stinput.num_of_segment);
		stTable.title = pathname1;
		stTable.tablelinewidth = 0;
		stTable.column = 2;
		stTable.fontweight = FW_Medium;
		stTable.tablealign = TX_CENTER;
		stTable.tablewidth = 50;
		stTable.tablelinewidth = 1;
		stTable.bgColorOddLine = 0xffff7f;
		stTable.formatstring = "%.6f";
		stTable.datatype = DT_REAL;
		stTable.heading = (IMG_CHAR **)pool.Malloc(2 * sizeof(IMG_CHAR *));
		//_snprintf(pathname1, FILENAME_MAX_LENGTH, "img%d", i + 1);
		stTable.heading[0] = "segment";
		stTable.heading[1] = "imgs";
		HL_CreateTableHeader(m_pHtmlLog, &stTable);
		IMG_CHAR segChar[FILENAME_MAX_LENGTH];
		
		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			_snprintf(segChar, FILENAME_MAX_LENGTH, "");
			for (i = 0; i < imgNums; i++)
			{
				_snprintf(pathname1, FILENAME_MAX_LENGTH, "%f_", segScore[j*imgNums + i]);
				strcat(segChar, pathname1);
			}
			_snprintf(pathname1, FILENAME_MAX_LENGTH, "%d", Stinput.segment[j].valid);
			strcat(segChar, pathname1);
			char value[20];
			if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
			else			stTable.bgColorOddLine = 0xffffcf;
			_snprintf(value, sizeof(value), "segment%d", j + 1);
			HL_CreateTableRow(m_pHtmlLog, &stTable, value, segChar);
		}
		HL_CloseTable(m_pHtmlLog);
		HL_Printf(m_pHtmlLog, "\n");
		writeLog("\n");
		HL_PutLineBreak(m_pHtmlLog);

		/*for (i = 0; i < Stinput.num_of_segment; i++)
		{
			for (j = 0; j < imgNums; j++)
			{

			}
		}*/
		/*for (i = 0; i < imgNums; i++)
		{
			HTMLLOGGING_TABLE_DATA stTable;
			HL_InitTableData(&stTable);
			_snprintf(pathname1, FILENAME_MAX_LENGTH, "Match Result%d", i + 1);
			stTable.title = pathname1;
			stTable.tablelinewidth = 0;
			stTable.column = 1;
			stTable.fontweight = FW_Medium;
			stTable.tablealign = TX_CENTER;
			stTable.tablewidth = 50;
			stTable.tablelinewidth = 1;
			stTable.bgColorOddLine = 0xffff7f;
			stTable.formatstring = "%.6f";
			stTable.datatype = DT_REAL;
			stTable.heading = (IMG_CHAR **)pool.Malloc(1 * sizeof(IMG_CHAR *));
			_snprintf(pathname1, FILENAME_MAX_LENGTH, "img%d", i + 1);
			stTable.heading[0] = pathname1;
			HL_CreateTableHeader(m_pHtmlLog, &stTable);
			
			for (int j = 0; j < Stinput.num_of_segment; j++)
			{
				char value[20];
				if (i % 2)		stTable.bgColorOddLine = 0xffffaf;
				else			stTable.bgColorOddLine = 0xffffcf;
				_snprintf(value, sizeof(value), "%.6f", segScore[j*imgNums + i]);
				HL_CreateTableRow(m_pHtmlLog, &stTable, value);
			}
			HL_CloseTable(m_pHtmlLog);
			HL_Printf(m_pHtmlLog, "\n");
			writeLog("\n");
			HL_PutLineBreak(m_pHtmlLog);
		}*/

		//logfinish();
	}

	ALIGN_REC_SEGMENT *finalSeg;
	for (j = 0; j < result->size; j++)
	{
		pstObj = result->ptr + j;
		for (m = 0; m < Stinput.num_of_segment; m++)
		{
			finalSeg = Stinput.segment + m;
			finalSeg->start.x -= Stinput.xOffset; finalSeg->start.y -= Stinput.yOffset; finalSeg->start.x *= reduction; finalSeg->start.y *= reduction;
			finalSeg->end.x -= Stinput.xOffset; finalSeg->end.y -= Stinput.yOffset; finalSeg->end.x *= reduction; finalSeg->end.y *= reduction;
			finalSeg->center[0].x -= Stinput.xOffset; finalSeg->center[0].y -= Stinput.yOffset;
			finalSeg->center[0].x *= reduction; finalSeg->center[0].y *= reduction;
			finalSeg->center[1].x -= Stinput.xOffset; finalSeg->center[1].y -= Stinput.yOffset;
			finalSeg->center[1].x *= reduction; finalSeg->center[1].y *= reduction;

			vector<IMG_RCOORD>vec_tmpCoor;
			if (finalSeg->seg_type == ALIGN_REC_BSPLINE_SEGMENT &&finalSeg->curve.num_points != 0)
			{
				for (k = 0; k < finalSeg->curve.num_points; k++)
				{
					coor.x = finalSeg->curve.control_points[k].x - Stinput.xOffset;
					coor.y = finalSeg->curve.control_points[k].y - Stinput.yOffset;
					coor.x *= reduction; coor.y *= reduction;
					vec_tmpCoor.push_back(coor);
				}

			}
			switch (finalSeg->seg_type)
			{
			case ALIGN_REC_LINE_SEGMENT:
				{
					Align_Reverse_Translate_RCOORD_By_Obj(&finalSeg->start, 1, pstObj, &tempCoor);
					finalSeg->start = tempCoor;
					finalSeg->start.x += pstRec->ptr->rcoRef.x; finalSeg->start.y += pstRec->ptr->rcoRef.y;
					finalSeg->start.x = finalSeg->start.x / reduction + coWindowOff.x;
					finalSeg->start.y = finalSeg->start.y / reduction + coWindowOff.y;
					Align_Reverse_Translate_RCOORD_By_Obj(&finalSeg->end, 1, pstObj, &tempCoor);
					finalSeg->end = tempCoor;
					finalSeg->end.x += pstRec->ptr->rcoRef.x; finalSeg->end.y += pstRec->ptr->rcoRef.y;
					finalSeg->end.x = finalSeg->end.x / reduction + coWindowOff.x;
					finalSeg->end.y = finalSeg->end.y / reduction + coWindowOff.y;
				}
				break;
			case ALIGN_REC_ARC_SEGMENT:
				{
					Align_Reverse_Translate_RCOORD_By_Obj(&finalSeg->start, 1, pstObj, &tempCoor);
					finalSeg->start = tempCoor;
					finalSeg->start.x += pstRec->ptr->rcoRef.x; finalSeg->start.y += pstRec->ptr->rcoRef.y;
					finalSeg->start.x = finalSeg->start.x / reduction + coWindowOff.x;
					finalSeg->start.y = finalSeg->start.y / reduction + coWindowOff.y;
					Align_Reverse_Translate_RCOORD_By_Obj(&finalSeg->end, 1, pstObj, &tempCoor);
					finalSeg->end = tempCoor;
					finalSeg->end.x += pstRec->ptr->rcoRef.x; finalSeg->end.y += pstRec->ptr->rcoRef.y;
					finalSeg->end.x = finalSeg->end.x / reduction + coWindowOff.x;
					finalSeg->end.y = finalSeg->end.y / reduction + coWindowOff.y;
					Align_Reverse_Translate_RCOORD_By_Obj(&finalSeg->center[0], 1, pstObj, &tempCoor);
					finalSeg->center[0] = tempCoor;
					finalSeg->center[0].x += pstRec->ptr->rcoRef.x; finalSeg->center[0].y += pstRec->ptr->rcoRef.y;
					finalSeg->center[0].x = finalSeg->center[0].x / reduction + coWindowOff.x;
					finalSeg->center[0].y = finalSeg->center[0].y / reduction + coWindowOff.y;
				}
				break;
			case ALIGN_REC_BSPLINE_SEGMENT:
				{
				for (k = 0; k < finalSeg->curve.num_points; k++)
				{
					Align_Reverse_Translate_RCOORD_By_Obj(&vec_tmpCoor[k], 1, pstObj, &tempCoor);
					finalSeg->curve.control_points[k] = tempCoor;
					finalSeg->curve.control_points[k].x += pstRec->ptr->rcoRef.x; finalSeg->curve.control_points[k].y += pstRec->ptr->rcoRef.y;
					finalSeg->curve.control_points[k].x = finalSeg->curve.control_points[k].x / reduction + coWindowOff.x;
					finalSeg->curve.control_points[k].y = finalSeg->curve.control_points[k].y / reduction + coWindowOff.y;
				}
				}
				break;
			default:
				THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
				break;
			}
		}

		if (Stinput.uwDebug&ALIGN_DEBUG_TIME)
		{
			clock.Click("transf segment 2 img");
		}
	} 

	if (Stinput.uwDebug & 513)
	{
		writeLog("\n");
		writeLog("Match segment result:\n");
		writeLog("num of segment : %d:\n", Stinput.num_of_segment);
		for (j = 0; j < Stinput.num_of_segment; j++)
		{
			switch (Stinput.segment[j].seg_type)
			{

			case ALIGN_REC_LINE_SEGMENT:
				writeLog("LineSeg (%f,%f) (%f,%f) %d\n", Stinput.segment[j].start.x, Stinput.segment[j].start.y,
					Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);

				break;
			case ALIGN_REC_ARC_SEGMENT:
				writeLog("ArcSeg (%f,%f) (%f,%f) (%f,%f) %d\n", Stinput.segment[j].center[0].x, Stinput.segment[j].center[0].y,
					Stinput.segment[j].start.x, Stinput.segment[j].start.y, Stinput.segment[j].end.x, Stinput.segment[j].end.y, Stinput.segment[j].valid);
				break;
			case ALIGN_REC_BSPLINE_SEGMENT:
			{
				ALIGN_SEGMENT_CURVE curve = Stinput.segment[j].curve;
				writeLog("CurveSeg:num_points dims valid isClosed%d  %d\n", curve.num_points, curve.dims, Stinput.segment[j].valid, curve.isClosed);
				for (int mm = 0; mm < curve.num_points; mm++)
				{
					writeLog("CurveSeg (%f,%f)\n", curve.control_points[mm].x, curve.control_points[mm].y);
				}
			}
				break;
			default:
				THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "segment seg_type error");
				break;
			}

		}
	}
exit:
	if (Stinput.uwDebug & ALIGN_DEBUG_TIME)
	{
		char name[MAX_FILE_NAME];
		clock.Click("finish all");
		_snprintf_s(name, sizeof(name), "%s\\LOG%05uMT.log", Stinput.strLogPath, g_SearchLogIndex);
		clock.SetPath(name);
		clock.SaveToFile();
	}
	if (pstSrchOpt->uwDebug & 513)
	{


		logfinish();
	}
}

IMG_INT CVisAlignSearch::points_compute_circletype(IMG_UBBUF *ubbfImg, IMG_RCOORD *pCoor, IMG_INT ptNums, IMG_RCOORD centerPt, IMG_ULWORD &circleType, IMG_INT count)
{
	IMG_INT status = 0;
	IMG_INT width = ubbfImg->size.width;
	IMG_INT height = ubbfImg->size.height;
	IMG_INT i, j, mark;
	mark = 0;
	IMG_REAL length, angle;
	IMG_COORD coorPt1, coorPt2;
	IMG_REAL grayDiff;
	grayDiff = 0.f;
	for (i = 0; i < ptNums; i++)
	{
		length = sqrt((pCoor[i].x - centerPt.x)*(pCoor[i].x - centerPt.x) + (pCoor[i].y - centerPt.y)*(pCoor[i].y - centerPt.y));
		angle = atan2(pCoor[i].y - centerPt.y, pCoor[i].x - centerPt.x);
		for (j = 1; j <= count; j++)
		{
			coorPt1.x = (IMG_WORD)((length - 1 - j)*cos(angle) + centerPt.x + 0.5);   //inner
			coorPt1.y = (IMG_WORD)((length - 1 - j)*sin(angle) + centerPt.y + 0.5);
			coorPt2.x = (IMG_WORD)((length + 1 + j)*cos(angle) + centerPt.x + 0.5);    //outer
			coorPt2.y = (IMG_WORD)((length + 1 + j)*sin(angle) + centerPt.y + 0.5);
			if (coorPt1.x<0 || coorPt1.x>width-1 || coorPt1.y<0 || coorPt1.y>height-1
				|| coorPt2.x<0 || coorPt2.x>width-1 || coorPt2.y<0 || coorPt2.y>height-1)
			{
				continue;
			}

			grayDiff += (ubbfImg->ptr[(size_t)coorPt1.y*ubbfImg->linestep + coorPt1.x] - ubbfImg->ptr[(size_t)coorPt2.y*ubbfImg->linestep + coorPt2.x]);
			mark++;
		}
	}
	if (mark == 0)
	{
		return -1;
	}

	grayDiff /= mark;
	if (grayDiff > 0)
	{
		circleType = 2;
	}
	else
	{
		circleType = 1;
	}
	return 0;
}

void CVisAlignResult::GetCoutoursOfObjs(IMG_ULWORD & num_of_pts, CONTOUR_FEATURE * contour_pts, CVisAlignRecord *record)
{
	IMG_ULWORD index;
	IMG_INT i, j, k;
	VIS_ALIGN_RECORD *pstRec;
	if (record == nullptr )THROW_VIS_EXCEPTION_MESG(VIS_ERR_NULLPTR,"pstRec could not be nullptr");
	pstRec = record->GetRecord();
	if(pstRec == nullptr || pstRec->ulNumOfLayer == 0)THROW_VIS_EXCEPTION_MESG(VIS_ERR_NULLPTR, "empty record");
	if (contour_pts == nullptr)
	{
		num_of_pts = pstRec->ptr[0].ulNumOfContourPts*Size();
		return;
	}
	IMG_REAL scale = pow(2.0, pstRec->ulHighestLayer);

	for (i = 0, index = 0; i < Size(); i++)
	{
		IMG_OBJ obj = *GetIMG_OBJ(i);
		obj.rco.x -= pstRec->rcoRefVector.x*cos(obj.rotation*PI / 180)*obj.scale*obj.rMx - pstRec->rcoRefVector.y*sin(obj.rotation*PI / 180)*obj.scale*obj.rMy;
		obj.rco.y -= pstRec->rcoRefVector.x*sin(obj.rotation*PI / 180)*obj.scale*obj.rMx + pstRec->rcoRefVector.y*cos(obj.rotation*PI / 180)*obj.scale*obj.rMy;
		obj.rotation -= pstRec->rOrientation;
		obj.scale *= scale;
		
		for (j = index, k = 0; j < pstRec->ptr[0].ulNumOfContourPts + index && j<num_of_pts; j++, k++)
		{
			contour_pts[j] = pstRec->ptr[0].pstContourPts[k];
			Align_Translate_RCOORD_By_Obj(&pstRec->ptr[0].pstContourPts[k].fpoint, 1, &obj, &contour_pts[j].fpoint);
			contour_pts[j].point.x = round(contour_pts[j].fpoint.x);
			contour_pts[j].point.y = round(contour_pts[j].fpoint.y);
		}
		index += pstRec->ptr[0].ulNumOfContourPts;
	}
	num_of_pts = j;
	return;

}
void CVisAlignResult::GetPointsOfObjs(IMG_ULWORD & num_of_pts, IMG_RCOORD * contour_pts, CVisAlignRecord *record)
{
	IMG_ULWORD index;
	IMG_INT i, j, k;
	VIS_ALIGN_RECORD *pstRec;
	if (record == nullptr)THROW_VIS_EXCEPTION_MESG(VIS_ERR_NULLPTR, "pstRec could not be nullptr");
	pstRec = record->GetRecord();
	if (pstRec == nullptr || pstRec->ulNumOfLayer == 0)THROW_VIS_EXCEPTION_MESG(VIS_ERR_NULLPTR, "empty record");
	if (contour_pts == nullptr)
	{
		num_of_pts = pstRec->ptr[0].ulNumOfContourPts*Size();
		return;
	}
	IMG_REAL scale = pow(2.0, pstRec->ulHighestLayer);

	for (i = 0, index = 0; i < Size(); i++)
	{
		IMG_OBJ obj = *GetIMG_OBJ(i);
		obj.rco.x -= pstRec->rcoRefVector.x*cos(obj.rotation*PI / 180)*obj.scale*obj.rMx - pstRec->rcoRefVector.y*sin(obj.rotation*PI / 180)*obj.scale*obj.rMy;
		obj.rco.y -= pstRec->rcoRefVector.x*sin(obj.rotation*PI / 180)*obj.scale*obj.rMx + pstRec->rcoRefVector.y*cos(obj.rotation*PI / 180)*obj.scale*obj.rMy;
		obj.rotation -= pstRec->rOrientation;
		obj.scale *= scale;

		for (j = index, k = 0; j < pstRec->ptr[0].ulNumOfContourPts + index && j < num_of_pts; j++, k++)
		{
			Align_Translate_RCOORD_By_Obj(&pstRec->ptr[0].pstContourPts[k].fpoint, 1, &obj, &contour_pts[j]);
		}
		index += pstRec->ptr[0].ulNumOfContourPts;
	}
	num_of_pts = j;
	return;

}


void CVisCircleResult::GetEdgeOfCircle(IMG_UWORD uwID, IMG_ULWORD & ulNumPts, IMG_RCOORD * Points)
{
	IMG_UINT ulNumPairs;
	IMG_FEATUREPT *feature;
	EDGE_INFORMATION *edge, *src;
	if (m_match == nullptr)
	{
		ulNumPts = 0;
		return;
	}
	IMG_REAL scale = pow(2.0, m_match->reduction);
	m_match->GetObjMatchedPt(uwID, feature, src, edge, ulNumPairs);
	if (ulNumPairs == 0)
	{
		ulNumPts = 0;
		return;
	}
	ulNumPts = ulNumPairs;
	if (Points != nullptr)
	{
		for (IMG_INT i = 0; i < ulNumPairs && i<ulNumPts; i++)
		{
			Points[i] = edge[i].rcoPos;
			Points[i].x *= scale;
			Points[i].y *= scale;
		}
	}
}
__declspec(dllexport) void *testmem(void)
{
	CVisMemPool pool;
	return pool.PMalloc(10);
}
