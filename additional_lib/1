
//#define _OUTPUT_LOG
//#pragma pack(push, 16)
#include <windows.h>
#include <ViType.h>
#include <VisAlign.h>
#include <VisLog.h>
#include <VisMEM.h>
#include <ippi.h>
#include <assert.h>
#include "emmintrin.h"
#include "VisAlignHtmlLog.h"
#include <VisClock.h>
extern thread_local CVisClock *g_pstClock;
extern thread_local IMG_ULWORD g_SearchLogIndex;


#ifdef _OUTPUT_LOG
#include <imdebug.h>
#endif
static struct output_{
	IMG_INT x, y;
	IMG_REAL rX, rY;
	IMG_REAL angle;
	IMG_REAL errorX;
	IMG_REAL errorY;
}output_1 = {0};
//#ifndef WIN32
//typedef union{
//	char m128i_i8[16];
//	short m128i_i16[8];
//	long m128i_i32[4];	
//	__int64			 m128i_i64[2];
//	unsigned char m128i_u8[16];
//	unsigned short m128i_u16[8];
//	unsigned long m128i_u32[4];
//	unsigned __int64	m128i_u64[2];
//}
//__m128i;
//#endif
//#ifdef WIN32
//#include "emmintrin.h"
//#endif
#ifdef _WIN64
#define _EAX rax
//#define _EBX rbx
#define _ECX rcx
#define _EDX rdx
#define _ESI rsi
#define _EDI rdi
//#define _MOV movsxd
#else
#define _EAX eax
//#define _EBX ebx
#define _ECX ecx
#define _EDX edx
#define _ESI esi
#define _EDI edi
//#define _MOV mov
#endif

#define SYS_GetTimeInUS

#define MAX_COARSE_SRCH_REDUCTION (3)
#define MAX_NUM_OF_DIRECTION (32)

//CVisLog	//m_pHtmlLog;
thread_local IMG_UWBUF g_uwbufCoarseSrchCombined[4] = {0};
thread_local IMG_VVOID **g_ppEdgeDirection[20] = {0};
thread_local IMG_ULWORD	g_ulSrchTimestamp[20] = {0};
thread_local IMG_WORD	wAlignFileIndex = 0;
thread_local IMG_UBYTE	g_ptdebug = 0;
thread_local HTMLLOGGING *m_pHtmlLog;

IMG_WORD VIS_FillBuffer_w(IMG_WORD wValue, IMG_WBUF *pwbufSrc, IMG_COORD *pcoOff, IMG_SIZE *pszOp)
{
	IMG_WORD *p;
	BUF_OFF(p, pwbufSrc, pcoOff);
	for (int i = 0; i < pszOp->height; i++)
	{
		memset(p, 0, sizeof(IMG_WORD)*pszOp->width);
		p += pwbufSrc->linestep;
	}
	return OK;
}
IMG_WORD VIS_FillBuffer_ub(IMG_UBYTE ubValue, IMG_UBBUF *pubbufSrc, IMG_COORD *pcoOff, IMG_SIZE *pszOp)
{
	IMG_UBYTE *p;
	BUF_OFF(p, pubbufSrc, pcoOff);
	for (int i = 0; i < pszOp->height; i++)
	{
		memset(p, 0, sizeof(IMG_UBYTE)*pszOp->width);
		p += pubbufSrc->linestep;
	}
	return OK;
}
IMG_WORD ALIGN_DistanceTransform_d_SSE(IMG_UWBUF *puwbufSrc,
	IMG_COORD *pcoSoff,
	IMG_UWBUF *puwbufDst,
	IMG_COORD *pcoDoff,
	IMG_SIZE *pszOp,
	IMG_UBYTE ubKernelSize,		//only 3 or 5
	IMG_UBYTE *pubKernel);
IMG_WORD VIS_Local_Max_w(IMG_WBUF	const *pwbSrc,
	IMG_COORD	const *pcoOffset,
	IMG_SIZE	const *pszOp,
	IMG_WORD	const wThreshold,
	IMG_UBYTE	const ubKernelWidth,
	IMG_COORD	*pcoLocalMax,
	IMG_ULWORD	*pulNumLocalMax);
IMG_WORD VIS_RLEDecoding(const IMG_LWBUF *lwbufSource, IMG_UBBUF *ubbufDest, IMG_COORD const *pcoDoff,
	IMG_SIZE const  *pszOpsize);
IMG_WORD VIS_RLEEncoding(const IMG_UBBUF *ubbufSource, IMG_COORD const *pcoSoff,
	IMG_SIZE const  *pszOpsize, IMG_LWBUF *lwbufDest);
IMG_WORD VIS_RLEDilate(const IMG_LWBUF *lwbufSource, const IMG_SIZE *szSource,
	IMG_LWBUF *lwbufKernel, const IMG_SIZE *szKernel, IMG_LWBUF *lwbufDest);
IMG_WORD	ALIGN_SwapBuffer(void *p1, void *p2, const IMG_LWORD lwSize)
{
#ifdef WIN32
	__m128i m1, m2, *pm1 = (__m128i *)p1, *pm2 = (__m128i *)p2;
#else
	IMG_LWORD m1, m2, *pm1 = (IMG_LWORD *)p1, *pm2 = (IMG_LWORD *)p2;
#endif
	IMG_CHAR *pc1, *pc2, c1, c2;
	IMG_LWORD i;
	if (p1 == NULL || p2 == NULL)
	{
		assert(0);
		return ALIGN_ERR_INVALID_ARG;
	}
#ifdef WIN32
	for (i = 0; i < lwSize - (IMG_LWORD)sizeof(__m128i); i += (IMG_LWORD)sizeof(__m128i))
	{
		m1 = _mm_loadu_si128(pm1);
		m2 = _mm_loadu_si128(pm2);
		_mm_storeu_si128(pm1, m2);
		_mm_storeu_si128(pm2, m1);
		pm1++, pm2++;
	}
#else
	for (i = 0; i < lwSize - (IMG_LWORD)sizeof(IMG_LWORD); i += (IMG_LWORD)sizeof(IMG_LWORD))
	{
		m1 = *(pm1);
		m2 = *(pm2);
		*pm1 = m2;
		*pm2 = m1;
		pm1++, pm2++;
	}
#endif
	pc1 = (IMG_CHAR *)pm1, pc2 = (IMG_CHAR *)pm2;
	for (; i < lwSize; i++)
	{
		c1 = *pc1;
		c2 = *pc2;
		*pc1 = c2;
		*pc2 = c1;
		pc1++, pc2++;
	}
	return OK;
}

IMG_VVOID	ALIGN_InitOBJ(IMG_OBJ	*pstObj)
{
	//IMG_UWORD	i;

	if (pstObj != NULL)
	{
		memset(pstObj, 0, sizeof(IMG_OBJ));
		pstObj->scale = 1.0;
		pstObj->rMSE = -1.0;

		pstObj->uwID = USHRT_MAX;
		pstObj->rLikeScore = -1.0;
		pstObj->rMx = 1.0;
		pstObj->rMy = 1.0;
	}
}


IMG_WORD	ALIGN_ND_RTS(IMG_FEATUREPT		*pstSpA,
	IMG_REAL		rNDx,
	IMG_REAL		rNDy,
	IMG_REAL		rcostheta,
	IMG_REAL		rsintheta,
	IMG_REAL		rX,
	IMG_REAL		rY,
	IMG_REAL		rScaleX,
	IMG_REAL		rScaleY,
	IMG_RCOORD		*prcoImage)
{						 // Scale and Rotation for SHA-ND
	//IMG_RCOORD			rcoTemp;
	IMG_LREAL			lrTempX = 0, lrTempY = 0;
	IMG_LREAL			rWNxyA;
	IMG_LREAL			rWNxyB;
	IMG_REAL			rAngle;


	if ((pstSpA == NULL) || (prcoImage == NULL))
	{
		THROW_VIS_EXCEPTION_MESG(VIS_ERR_INVALID_ARG, "pstSpA or prcoImage is Null");
		return ALIGN_ERR_INVALID_ARG;
	}

	if(ALIGN_IS_NCOLOR_NORMAL(pstSpA->angle))
	{
		rAngle = ALIGN_NORMAL_DIR_NCOLOR((IMG_WORD)pstSpA->angle);
	}
	else
	{
		rAngle = pstSpA->angle;
	}


	rWNxyA = (IMG_LREAL)fabs(cos(rAngle*D2R))*(IMG_LREAL)rNDx + (IMG_LREAL)fabs(sin(rAngle*D2R))*(IMG_LREAL)rNDy;
	rWNxyB = (IMG_LREAL)fabs(cos(rAngle*D2R))*(IMG_LREAL)rNDx + (IMG_LREAL)fabs(sin(rAngle*D2R))*(IMG_LREAL)rNDy;

	//rWNxyA = rNDx;
	//rWNxyB = rNDy;

	lrTempX = (IMG_LREAL)pstSpA->rco.x + rWNxyA*(IMG_LREAL)cos(rAngle*D2R);
	lrTempY = (IMG_LREAL)pstSpA->rco.y + rWNxyB*(IMG_LREAL)sin(rAngle*D2R);

	prcoImage->x = (IMG_REAL)(((IMG_LREAL)rcostheta*lrTempX - (IMG_LREAL)rsintheta*lrTempY)*(IMG_LREAL)rScaleX + (IMG_LREAL)rX);
	prcoImage->y = (IMG_REAL)(((IMG_LREAL)rsintheta*lrTempX + (IMG_LREAL)rcostheta*lrTempY)*(IMG_LREAL)rScaleY + (IMG_LREAL)rY);

	return 0;
}

IMG_VVOID ALIGN_GetCoarseSrchErr(IMG_REAL *prErrX, IMG_REAL *prErrY)
{
	*prErrX = output_1.errorX;
	*prErrY = output_1.errorY;
}
IMG_VVOID ALIGN_SetCoarsePos(IMG_REAL x, IMG_REAL y, IMG_REAL angle)
{
	output_1.x = (IMG_INT)((IMG_LREAL)x+0.5);
	output_1.y = (IMG_INT)((IMG_LREAL)y+0.5);
	output_1.rX = x;
	output_1.rY = y;
	output_1.angle = angle;
}
IMG_VVOID *ALIGN_ROUND_PTR16(IMG_VVOID *ptr);


IMG_WORD ALIGN_MallocForCoarseSearchVoting(IMG_SIZE *pszOpsize, ALIGN_SEARCH_OPTION *pstSrchOpt, CVisMemPool &mem_pool)
{
	int tid = GetCurrentThreadId();
	IMG_WORD wState = OK;
	IMG_UBYTE ubColor = pstSrchOpt ->ubNumChannel;
	IMG_LWORD i, sizex;
	IMG_LWORD lwChannel = pstSrchOpt ->ubNumChannel == IMG_CHANNEL_COLOR ? 4:1;
	IMG_ULWORD ulLinestep = (pszOpsize->width+15) & (~0xF);
	IMG_SIZE szOp;
	szOp.width = pszOpsize->width; szOp.height = pszOpsize->height+2;
	g_uwbufCoarseSrchCombined[0].ptr = (IMG_UWORD *)mem_pool.Malloc((ulLinestep*szOp.height+16) * sizeof(IMG_UWORD));
	if(g_uwbufCoarseSrchCombined[0].ptr == NULL) 
	{
		THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
		goto end;
	}
	g_uwbufCoarseSrchCombined[0].linestep = ulLinestep;
	g_uwbufCoarseSrchCombined[0].size.width = szOp.width;
	g_uwbufCoarseSrchCombined[0].size.height = szOp.height-2;

	if(ubColor == IMG_CHANNEL_COLOR)
	{
		for(i = 1; i<4; i++)
		{
			g_uwbufCoarseSrchCombined[i].ptr = (IMG_UWORD *)mem_pool.Malloc((ulLinestep*szOp.height+16)*sizeof(IMG_UWORD));
			if(g_uwbufCoarseSrchCombined[i].ptr == NULL) 
			{
				wState = MEM_ERR_MALLOC;
				THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
				goto end;
			}
			g_uwbufCoarseSrchCombined[i].linestep = ulLinestep;
			g_uwbufCoarseSrchCombined[i].size.width = szOp.width;
			g_uwbufCoarseSrchCombined[i].size.height = szOp.height-2;

		}
	}
	szOp.width = pszOpsize->width;
	szOp.height = pszOpsize->height;
	for(i = 0; i<=MAX_COARSE_SRCH_REDUCTION; i++)
	{
		szOp.width = (szOp.width >>1)+1;
		szOp.height = (szOp.height >>1)+1;
		sizex = (szOp.width+15)&(~0xF);
		g_ppEdgeDirection[i]= (IMG_VVOID **)mem_pool.Malloc(((IMG_ULWORD)lwChannel*MAX_NUM_OF_DIRECTION+16)*sizeof(IMG_VVOID *));
		if(g_ppEdgeDirection[i] == NULL )
		{
			THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
			wState = MEM_ERR_MALLOC;	goto end;
		}
		g_ppEdgeDirection[i][0] = (IMG_UBYTE *)mem_pool.Malloc((IMG_ULWORD)(lwChannel*sizex*((size_t)szOp.height*MAX_NUM_OF_DIRECTION+1)+16));
		if(g_ppEdgeDirection[i][0] == NULL)
		{
			THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
			wState = MEM_ERR_MALLOC;
			goto end;
		}
	}
	memset(g_ulSrchTimestamp, 0, sizeof(g_ulSrchTimestamp));
end:
	return wState;
}
IMG_VVOID ALIGN_FreeVotingInformation(ALIGN_VOTING_INFORMATION *pstVoteInfo)
{
	if(pstVoteInfo->pwbVoting!=NULL)CVisMemPool::PFree(pstVoteInfo->pwbVoting);
	if(pstVoteInfo->prAngle != NULL)CVisMemPool::PFree(pstVoteInfo->prAngle);
}

//IMG_WORD ALIGN_DistanceTransform_d_SSE(	IMG_UWBUF *puwbufSrc, 
//									 IMG_COORD *pcoSoff,
//									 IMG_UWBUF *puwbufDst,
//									 IMG_COORD *pcoDoff,
//									 IMG_SIZE *pszOp,
//									 IMG_UBYTE ubKernelSize,		//only 3 or 5
//									 IMG_UBYTE *pubKernel);
int	ALIGN_Comp_OBJ_By_RTS(void const *pvPtr1,	void const *pvPtr2) 
{
	IMG_OBJ 
		*ptr1 = ((IMG_OBJ *)pvPtr1),
		*ptr2 = ((IMG_OBJ *)pvPtr2);

	if(ptr1->rMSE+1e-6< ptr2->rMSE)
	{
		return -1;
	}
	if(ptr1->rMSE> ptr2->rMSE+1e-6)
	{
		return 1;
	}
	if(ptr1->rco.y+1e-6 < ptr2->rco.y)
	{
		return -1;
	}	
	if(ptr1->rco.y-1e-6 > ptr2->rco.y)
	{
		return 1;
	}
	if(ptr1->rco.x+1e-6 < ptr2->rco.x)
	{
		return -1;
	}	
	if(ptr1->rco.x-1e-6 > ptr2->rco.x)
	{
		return 1;
	}
	return 0;
}
int	ALIGN_Comp_OBJ_By_Score_A(void const *pvPtr1,	void const *pvPtr2) 
{
	IMG_REAL
		s1 = ((IMG_OBJ *)pvPtr1)->rMatched,
		s2 = ((IMG_OBJ *)pvPtr2)->rMatched;

	if( s1 > s2 )
		return -1;
	if( s1 < s2 )
		return 1;
	return 0;
}
IMG_VVOID check_heap(char *s, int i)
//
{
	int tid = GetCurrentThreadId();
	char msg[256];
#ifdef _DEBUG
	if(true)
	{
		int sts;
		sts= _CrtCheckMemory();
		if(!sts)
		{
			_snprintf(msg, sizeof(msg), "heap check fail code %d, at file %s line %d\n", sts, s, i);
			THROW_VIS_EXCEPTION_MESG(VIS_ERR_HEAP_DAMAGE, msg);
			SYS_Assert(0);
		}
	}

#else
	return;
#endif
}
//



//}}}
IMG_WORD   ALIGN_GetReTablePercentageInROI(CVisAlignRecordTable	const	*pstEptable,
		// 
											IMG_SIZE		const	*pszImage,		  
											IMG_OBJ			const	*pstObj,
											IMG_REAL		*prFeaturePercentage) 
{
	IMG_WORD		wStatus = OK;
	IMG_UWORD		uwNumOfFeat = 0, uwNumOfFeInROI = 0;
	IMG_LWORD		i;
	IMG_FEATUREPT	stRepInfo;
	IMG_RCOORD		rcoResult;
	IMG_REAL		rCosObjOri=0.0, rSinObjOri=0.0;

	uwNumOfFeat = pstEptable->uwNumOfSpAFeature;
	rCosObjOri = (IMG_REAL)cos(pstObj->rotation*PI/180);
	rSinObjOri = (IMG_REAL)sin(pstObj->rotation*PI/180);

	// Calculate number of align feature points in ROI within search region
	*prFeaturePercentage = 0;
	for(i=0;i<uwNumOfFeat;i++) 
	{
		stRepInfo.rco = pstEptable->pstSpA[i].rco;
		stRepInfo.angle = pstEptable->pstSpA[i].angle;
		wStatus = ALIGN_ND_RTS(	&stRepInfo,
								0,
								0,
								rCosObjOri, 
								rSinObjOri,
								pstObj->rco.x,
								pstObj->rco.y,
								pstObj->scale,
								pstObj->scale,
								&rcoResult);
		if (wStatus != OK) 
		{
			int tid = GetCurrentThreadId();
			THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
			goto exit;
		}

		if ((rcoResult.x<pszImage->width) && (rcoResult.y<pszImage->height) && rcoResult.x > 0 && rcoResult.y > 0) 
		{
			uwNumOfFeInROI++;
		}
	}



	// Calculate percentage of align feature points within search region and percentage of region area within search region.
	*prFeaturePercentage = uwNumOfFeInROI/(IMG_REAL)uwNumOfFeat;

exit:
	return	wStatus;
}
//
IMG_VVOID	ALIGN_GetScoreThresholdByDistribution(IMG_OBJ const *pstObj, IMG_ULWORD const ulNum, IMG_REAL *prScoreThrd)
	//
{
	IMG_ULWORD i, ulCurNum;
	IMG_REAL rThrd, rMax, rLastThrd, rMean, rStd, rA;
	if(ulNum < 10)
	{
		for( i = 0, rMax = 0; i<ulNum; i++)
		{
			if(pstObj[i].rVoteScore > rMax)
			{
				rMax = pstObj[i].rVoteScore;
			}
		}
		*prScoreThrd = rMax*0.7f; //0.7 for margin
	}
	else
	{
		rLastThrd = 0, rThrd = 1e10f;
		for(i = 0, rMean = 0, rMax = 0; i<ulNum; i++)
		{
			rMean += pstObj[i].rVoteScore;
			rMax = rMax > pstObj[i].rVoteScore ? rMax : pstObj[i].rVoteScore;
		}
		rMean = rMean / ulNum;
		for(i = 0, rStd = 0; i<ulNum; i++)
		{
			rA = pstObj[i].rVoteScore - rMean;
			rStd += rA*rA;
		}
		if(ulNum > 1)	rStd = (IMG_REAL)sqrt(rStd/(ulNum-1));	//stupid pclint want me to do this
		rThrd = rMean+rStd*2;
		while(fabs(rThrd - rLastThrd)>1 && rThrd > rMax*0.7)
		{
			for(i = 0, rMean = 0, ulCurNum = 0; i<ulNum; i++)
			{
				if(pstObj[i].rVoteScore < rThrd)
				{
					rMean += pstObj[i].rVoteScore;
					ulCurNum++;
				}
			}
			rMean = rMean / (ulCurNum+1e-5f);
			for(i = 0, rStd = 0; i<ulNum; i++)
			{
				if(pstObj[i].rVoteScore < rThrd)
				{
					rA = pstObj[i].rVoteScore - rMean;
					rStd += rA*rA;
				}
			}
			if(ulCurNum > 1) rStd = (IMG_REAL)sqrt(rStd/(ulCurNum-1)); //stupid pclint want me to do this
			rLastThrd = rThrd;
			rThrd = rMean+rStd*2;			
		}
		if(rThrd < rMax*0.7f ||  rMean+rStd*3 > rMax) rThrd = rMax * 0.7f;
		*prScoreThrd = rThrd;
	}
}
//
int comparebyscore(const void *src1, const void *src2)
//
{
	IMG_OBJ *psrc1 = (IMG_OBJ *)src1, *psrc2 = (IMG_OBJ *)src2;
	IMG_WORD diff = (IMG_WORD)psrc1->rVoteScore-(IMG_WORD)psrc2->rVoteScore; 
	return -diff;
}





IMG_WORD ALIGN_FindMax_w(IMG_WBUF const *pwbufSrc, IMG_COORD const *pcoOff, IMG_SIZE const *pszOp, IMG_COORD *pcoMax, IMG_WORD *pwVal)
{
	IMG_WORD wStatus = OK;
#ifdef WIN32
	Ipp16s wVal, *pwbuf;
	IppiSize szOp;
	IppStatus status;
	int x, y;
	BUF_OFF(pwbuf, pwbufSrc, pcoOff);
	szOp.width = pszOp->width;
	szOp.height = pszOp->height;

	status = ippiMaxIndx_16s_C1R(pwbuf, pwbufSrc->linestep*sizeof(IMG_WORD), szOp, &wVal, &x, &y);
	if(status != ippStsNoErr)
	{
		wStatus = VIS_ERR_FAIL_IN_IPPI;
	}
	pcoMax->x = x+pcoOff->x;
	pcoMax->y = y+pcoOff->y;
	pwVal[0] = wVal;
#else
	wStatus = DSP_FindMax_w(pwbufSrc, pcoOff, pszOp, pcoMax, pwVal);
#endif
	return wStatus;
}
IMG_WORD ALIGN_FindMin_w(IMG_WBUF const *pwbufSrc, IMG_COORD const *pcoOff, IMG_SIZE const *pszOp, IMG_COORD *pcoMin, IMG_WORD *pwVal)
{
	IMG_WORD wStatus = OK;
#ifdef WIN32
	Ipp16s wVal, *pwbuf;
	IppiSize szOp;
	IppStatus status;
	int x, y;
	BUF_OFF(pwbuf, pwbufSrc, pcoOff);
	szOp.width = pszOp->width;
	szOp.height = pszOp->height;

	status = ippiMinIndx_16s_C1R(pwbuf, sizeof(IMG_WORD)*pwbufSrc->linestep, szOp, &wVal, &x, &y);
	if(status != ippStsNoErr)
	{
		wStatus = VIS_ERR_FAIL_IN_IPPI;
	}
	pcoMin->x = x+pcoOff->x;
	pcoMin->y = y+pcoOff->y;
	pwVal[0] = wVal;
#else
	wStatus = DSP_FindMin_w(pwbufSrc, pcoOff, pszOp, pcoMin, pwVal);
#endif
	return wStatus;
}


/*lint -esym(550, pS) */
IMG_WORD ALIGN_Scale2X_w(
						//
						IMG_WBUF *pwbufSrc,
						IMG_COORD *pcoS,
						IMG_WBUF *pwbufDst,
						IMG_COORD *pcoD,
						IMG_SIZE *pszOp)
{
	IMG_WORD wState = OK;
	IMG_WORD *pS, *pD;
	IMG_LWORD lwLinestepS, lwLinestepD, i, sizex;
	BUF_OFF(pS, pwbufSrc, pcoS);
	BUF_OFF(pD, pwbufDst, pcoD);
	lwLinestepS = pwbufSrc->linestep;
	lwLinestepD = pwbufDst->linestep;
	sizex = pszOp->width;
	if((size_t)pszOp->width*pszOp->height == 0) goto end;

	//first line
	//for(j = 0, k=0; j<sizex; j+=2, k++)
	//{
	//	pD[j] = pS[k];
	//	pD[j+1] = (pS[k]+pS[k+1])>>1;
	//}
	__asm
	{
		mov 		_ESI, pS
		mov			_EDI, pD
		xor			_ECX, _ECX
		mov			ecx, sizex
		shl			_ECX, 1
		add			_ECX, _ESI
		pxor		xmm7, xmm7
		mov			eax, 1
		movd		xmm6, eax
		shl			edx, 1
	start1:
		movq		xmm0, qword ptr[_ESI]
		add			_ESI, 6
		punpcklwd	xmm0, xmm7
		movdqa		xmm2, xmm0
		pslldq		xmm2, 4
		paddd		xmm2, xmm0
		psrld		xmm2, xmm6
		psrldq		xmm2, 2
		paddw		xmm0, xmm2
		psrldq		xmm0, 2
		movdqu		[_EDI], xmm0
		add			_EDI, 12
		cmp			_ESI, _ECX 
		jb			start1
		shr			_ECX, 1
	}
	pS += lwLinestepS;
	for(i = 0; i<pszOp->height-1; i++)
	{
		__asm
		{
			mov 		_ESI, pS
			mov			_EDI, pD
			xor			_ECX, _ECX
			mov			ecx, sizex
			shl			_ECX, 1
			add			_ECX, _ESI 
			pxor		xmm7, xmm7
			mov			eax, 1
			movd		xmm6, eax
			xor			_EDX, _EDX
			mov			edx, lwLinestepD
			shl			edx, 1
		start2:
			movq		xmm0, qword ptr[_ESI]
			movdqu		xmm4, [_EDI]
			add			_ESI, 6
			punpcklwd	xmm0, xmm7
			movdqa		xmm2, xmm0
			pslldq		xmm2, 4
			paddd		xmm2, xmm0
			psrld		xmm2, xmm6
			psrldq		xmm2, 2
			paddw		xmm0, xmm2
			psrldq		xmm0, 2
			movdqu		[_EDI+2*_EDX], xmm0
			psrld		xmm0, xmm6
			psrld		xmm4, xmm6
			paddw		xmm4, xmm0
			movdqu		[_EDI+_EDX], xmm4
			add			_EDI, 12
			cmp			_ESI, _ECX 
			jb			start2
			shr			_ECX, 1
		}
		pS += lwLinestepS;
		pD += lwLinestepD*2;
	}
	pD += lwLinestepD;
	memcpy(pD, pD-lwLinestepD, sizeof(IMG_WORD)*(IMG_ULWORD)sizex);
end:
	return wState;
}
/*lint -restore */




IMG_WORD ALIGN_Convert360To180(IMG_WBUF *pwbSrc, IMG_COORD *pcoSrc, IMG_UBBUF *pubbDest, IMG_COORD *pcoDest, IMG_SIZE *pszOp)
{
	IMG_WORD wState = OK;
	IMG_WORD *pwSrc;
	IMG_UBYTE *pubDst;
	IMG_LWORD i,j, width = pszOp->width, Slinestep = pwbSrc->linestep, Dlinestep = pubbDest->linestep;
	BUF_OFF(pwSrc, pwbSrc, pcoSrc);
	BUF_OFF(pubDst, pubbDest, pcoDest);
	if(width > 8)
	{
		__asm emms;
		for(i = 0, j = 0; i<pszOp->height; i++)
		{
				__asm
				{
					mov 			_ESI, pwSrc
					mov 			_EDI, pubDst
					mov				eax, 180
					mov 			ecx, width
					movd 			xmm7, eax
					pshuflw 		xmm7, xmm7, 0
					pshufd 			xmm7, xmm7, 0
					mov				eax, 0xFFFFFFFF
					movd			xmm6, eax
					pshufd 			xmm6, xmm6, 0
					mov				eax, 0x01ff01ff
					movd			xmm5, eax
					pshufd 			xmm5, xmm5, 0
					xor				eax, eax
					loopstart:
					movdqu 			xmm0, [_ESI]
					pand			xmm0, xmm5
					movdqa			xmm1, xmm0
					movdqa			xmm2, xmm0
					pcmpgtw			xmm0, xmm7
					pand			xmm0, xmm7
					psubw			xmm1, xmm0
					packuswb		xmm1, xmm6
					movdq2q			mm0, xmm1

					movq			[_EDI], mm0
					add				_ESI, 16
					add				_EDI, 8
					add				eax, 8
					cmp				eax, ecx
					jng				loopstart
					mov				j, ecx
				}
			for(;j<width; j++)
			{
				if(pwSrc[j] > 180) pubDst[j] -= 180;
			}
			pwSrc += Slinestep;
			pubDst += Dlinestep;
		}
		__asm emms;
	}
	else
	{
		for(i = 0; i<pszOp->height; i++)
		{
			for(j = 0;j<width; j++)
			{
				if((pwSrc[j]&511) > 180) pubDst[j] = (IMG_UBYTE)((pwSrc[j]&511)-180);
			}
			pwSrc += Slinestep;
			pubDst += Dlinestep;
		}
	}
	return wState;
}
IMG_WORD ALIGN_Convert360To90(IMG_WBUF *pwbSrc, IMG_COORD *pcoSrc, IMG_UBBUF *pubbDest, IMG_COORD *pcoDest, IMG_SIZE *pszOp)
{
	IMG_WORD wState = OK;
	IMG_WORD *pwSrc, val;
	IMG_UBYTE *pubDst;
	IMG_LWORD i,j, width = pszOp->width, Slinestep = pwbSrc->linestep, Dlinestep = pubbDest->linestep;
	BUF_OFF(pwSrc, pwbSrc, pcoSrc);
	BUF_OFF(pubDst, pubbDest, pcoDest);
	if(width > 8)
	{
		__asm emms;
		for(i = 0, j = 0; i<pszOp->height; i++)
		{
				__asm
				{
					mov 			_ESI, pwSrc
					mov 			_EDI, pubDst
					mov				eax, 180
					mov				ecx, width
					movd 			xmm7, eax
					pshuflw 		xmm7, xmm7, 0
					pshufd 			xmm7, xmm7, 0
					mov				eax, 0xFFFFFFFF
					movd			xmm6, eax
					pshufd 			xmm6, xmm6, 0
					mov				eax, 90
					movd			xmm5, eax
					pshuflw 		xmm5, xmm5, 0
					pshufd 			xmm5, xmm5, 0
					mov				eax, 270
					movd			xmm4, eax
					pshuflw 		xmm4, xmm4, 0
					pshufd 			xmm4, xmm4, 0
					mov				eax, 0x01ff01ff
					movd			xmm3, eax
					pshufd 			xmm3, xmm3, 0
					xor				eax, eax

loopstart:
					movdqu 			xmm0, [_ESI]	//xmm0, src
					pand			xmm0, xmm3
					movdqa			xmm1, xmm0
					movdqa			xmm2, xmm0
					//movdqa			xmm3, xmm0
					pcmpgtw			xmm1, xmm5
					pcmpgtw			xmm2, xmm4
					pand			xmm1, xmm7
					pand			xmm2, xmm7			
					psubw			xmm0, xmm1
					psubw			xmm0, xmm2
					paddw			xmm0, xmm5
					packuswb		xmm0, xmm6
					movdq2q			mm0, xmm0

					movq			[_EDI], mm0
					add				esi, 16
					add				edi, 8
					add				eax, 8
					cmp				eax, ecx
					jng				loopstart
					mov				j, ecx
				}
			for(;j<width; j++)
			{
				val = pwSrc[j] & 0x1ff;
				if(val > 90) val -= 180;
				if(val > 90) val -= 180;
				pubDst[j] = (IMG_UBYTE)(val+90);
			}
			pwSrc += Slinestep;
			pubDst += Dlinestep;
		}
		__asm emms;
	}
	else
	{
		for(i = 0; i<pszOp->height; i++)
		{
			for(j = 0;j<width; j++)
			{
				val = pwSrc[j] & 0x1ff;
				if(val > 90) val -= 180;
				if(val > 90) val -= 180;
				pubDst[j] = (IMG_UBYTE)(val+90);
			}
			pwSrc += Slinestep;
			pubDst += Dlinestep;
		}
	}
	return wState;
}










//
/*lint -e644 */
/*lint -esym(550, _xmmT16, szx, buf, ) */
IMG_WORD ALIGN_Compare_SSE(
	//
	IMG_UBBUF *pubbufSrc,
	IMG_COORD *pcoSrc,
	IMG_UBBUF *pubbufDst,		//can be same as source
	IMG_COORD *pcoDst,
	IMG_UBYTE	ubThrd,
	IMG_UBYTE	ubOp,
	IMG_SIZE *pszOp);
//
IMG_WORD ALIGN_Compare_SSE_w(
	//
	IMG_WBUF *pwbufSrc,
	IMG_COORD *pcoSrc,
	IMG_WBUF *pwbufDst,		//can be same as source
	IMG_COORD *pcoDst,
	IMG_WORD	wThrd,
	IMG_UBYTE	ubOp,
	IMG_SIZE *pszOp);
//
IMG_WORD ALIGN_Compare_SSE_wub(
	//
	IMG_WBUF *pwbufSrc,
	IMG_COORD *pcoSrc,
	IMG_UBBUF *pubbufDst,		//can be same as source
	IMG_COORD *pcoDst,
	IMG_WORD	wThrd,
	IMG_UBYTE ubValue,			//fill this value
	IMG_UBYTE	ubOp,
	IMG_SIZE *pszOp);












//
/*lint -e87 */
/*lint -e530 */
/*lint -esym(550, scale, szx, maxd, _xmmvalid, _xmmfactor, _xmmmaxd) */
/*lint -esym(529, scale, szx, maxd, _xmmvalid, _xmmfactor, _xmmmaxd) */

void combine_distance_and_direction(
									//
									IMG_UBBUF *pubbufDist, 
									IMG_COORD *pcoDist,
									IMG_UWBUF *puwbufDir, 
									IMG_COORD *pcoDir,
									IMG_UWBUF *puwbufC, 
									IMG_COORD *pcoC,
									IMG_SIZE *pszOp, 
									IMG_UBYTE distance, 
									IMG_UBYTE scalefactor)
{
	IMG_LWORD i,j=0,k, maxd = distance*distance, szx = pszOp->width;
	char buf[64+15] = {0};
	__m128i *_xmmzero, *_xmmvalid, *_xmmfactor, *_xmmmaxd;
	IMG_UBYTE *pS1;
	IMG_UWORD *pS2, *pD;
	BUF_OFF(pS1, pubbufDist, pcoDist);
	BUF_OFF(pS2, puwbufDir, pcoDir);
	BUF_OFF(pD, puwbufC, pcoC);
	//_xmmzero = (__m128i *)Malloc_align(sizeof(__m128i)*4+15);
	_xmmzero = (__m128i *)(ALIGN_ROUND_PTR16(buf));
	_xmmvalid = _xmmzero+1;
	_xmmfactor = _xmmzero+2;
	_xmmmaxd = _xmmzero+3;
	//IMG_WORD *pD2 = (IMG_WORD *)Malloc_align(szx);
	__asm
	{
		mov			_EDX, _xmmzero
		// _xmmzero.m128i_i64[0] = _xmmzero.m128i_i64[1] = 0;
		pxor		xmm1, xmm1
		movdqa		[_EDX], xmm1
		//_xmmvalid = _mm_set1_epi16(360);	//361 for invalid angle
		mov			 eax, 360
		movd		xmm1, eax
		movdqa		xmm0, xmm1
		punpcklwd	xmm1, xmm0
		pshufd		xmm1, xmm1, 0
		movdqa		[_EDX+16], xmm1
		//_xmmfactor = _mm_set1_epi16(23211); //23211 for 32768*255/360, 
		mov			 eax, 23211 
		movd		xmm1, eax
		movdqa		xmm0, xmm1
		punpcklwd	xmm1, xmm0
		pshufd		xmm1, xmm1, 0
		movdqa		[_EDX+32], xmm1
		// _xmmmaxd = _mm_set1_epi16(maxd);					 //set 8 for max distance
		mov			 eax,maxd 
		movd		xmm1, eax
		movdqa		xmm0, xmm1
		punpcklwd	xmm1, xmm0
		pshufd		xmm1, xmm1, 0
		movdqa		[_EDX+48], xmm1
	}
	__asm emms;
	for(i = 0; i<pszOp->height; i++)
	{
		if(i<pszOp->height-1)	szx = pszOp->width;
		else				szx = pszOp->width-16;
		
		j = 0;
		__asm
		{
			// for(j = 0, k=0; j< pszOp->width; j+=16)
			mov			ecx, 16
			cmp			ecx, szx
			jg			loop_quit
			mov			_EDX, _xmmzero
			xor			_ECX, _ECX				//_ECX for j
			mov			_EAX, pS1
			mov			_ESI, pS2
			mov			_EDI, pD
			movdqa		xmm6, [_EDX+48]
			movdqa		xmm0, [_EDX+32]
loop_start_1:
			//_xmm1 = _mm_load_si128((__m128i *)(pS1+j));
			//_xmm2 = _mm_loadu_si128((__m128i *)(pS2+j));
			pxor		xmm5, xmm5
			movdqu		xmm1, [_EAX+_ECX]
			movdqu		xmm2, [_ESI+_ECX*2]
			//_xmm3 = _mm_loadu_si128((__m128i *)(pS2+j+8));//next 8 dir WORD data
			movdqu		xmm3, [_ESI+_ECX*2+16]
			psllw		xmm2, 7			//pwDir & 0x1FF
			psllw		xmm3, 7
			psrlw		xmm2, 7
			psrlw		xmm3, 7
			movdqa		xmm4, xmm1
			//by now, xmm4 for distance, xmm2/xmm3 for dir
			//xmm1 free, xmm5 zero, xmm6 for maxd, xmm7 free
			//_xmm4 = _mm_mullo_epi16(_xmm2, _xmmfactor);	 //low 16bit
			//_xmm5 = _mm_mulhi_epi16(_xmm2, _xmmfactor);	 //high 16bit
			//_xmm6 = _mm_unpacklo_epi16(_xmm4, _xmm5);			//low 16bit
			//_xmm4 = _mm_unpackhi_epi16(_xmm4, _xmm5);			//high 16bit
			//_xmm6 = _mm_srli_epi32(_xmm6, 15);					
			//_xmm4 = _mm_srli_epi32(_xmm4, 15);
			//_xmm4 = _mm_packs_epi32(_xmm6, _xmm4);				//_xmm4 for unscaled direction, 0 to 255
			//_xmm2 = _mm_packus_epi16(_xmm4, _xmmzero);			//_xmm2 for 8 byte dir, 
			movdqa		xmm1, xmm2
			pmullw		xmm2, xmm0			//low
			pmulhw		xmm1, xmm0			//high
			movdqa		xmm7, xmm2
			punpcklwd	xmm2, xmm1
			punpckhwd	xmm7, xmm1			
			psrld		xmm2, 15
			psrld		xmm7, 15
			packssdw	xmm2, xmm7
			packuswb	xmm2, xmm5													//xmm2 for 8 byte dir, low 8byte
			//_xmm4 = _mm_mullo_epi16(_xmm3, _xmmfactor);
			//_xmm5 = _mm_mulhi_epi16(_xmm3, _xmmfactor);
			//_xmm6 = _mm_unpacklo_epi16(_xmm4, _xmm5);
			//_xmm4 = _mm_unpackhi_epi16(_xmm4, _xmm5);
			//_xmm6 = _mm_srli_epi32(_xmm6, 15);
			//_xmm4 = _mm_srli_epi32(_xmm4, 15);
			//_xmm4 = _mm_packs_epi32(_xmm6, _xmm4);
			//_xmm3 = _mm_packus_epi16(_xmmzero, _xmm4);			//_xmm3 for next 8byte dir
			movdqa		xmm1, xmm3
			pmullw		xmm3, xmm0
			pmulhw		xmm1, xmm0
			movdqa		xmm7, xmm3
			punpcklwd	xmm3, xmm1
			punpckhwd	xmm7, xmm1
			psrld		xmm3, 15
			psrld		xmm7, 15
			packssdw	xmm3, xmm7
			packuswb	xmm5, xmm3													//xmm3 for next 8byte dir

			//_xmm2 = _mm_unpacklo_epi8(_xmm2, _xmm1);				//dist/edge dir
			//_xmm3 = _mm_unpackhi_epi8(_xmm3, _xmm1);				//
			//_mm_store_si128((__m128i *)(pD+j), _xmm2);
			//_mm_store_si128((__m128i *)(pD+j+8), _xmm3);
			punpcklbw	xmm2, xmm4
			punpckhbw	xmm5, xmm4
			movdqu		[_EDI+_ECX*2], xmm2
			movdqu		[_EDI+_ECX*2+16], xmm5

			// loop code
			add			 ecx, 16
			cmp			 ecx, szx
			jl			loop_start_1	
			mov			 j, ecx
loop_quit:
		}
		for(;j<pszOp->width; j++)
		{
			k = ((pS2[j]&0x1ff)*23211);
			k >>= 15;
			//i = pS1[j]<<8;
			pD[j] = (IMG_UWORD)((pS1[j]<<8) | k);
		}

		pS1 +=pubbufDist->linestep;
		pS2 += puwbufDir->linestep;
		pD += puwbufC->linestep;
	}


	__asm emms;
//#ifdef _OUTPUT_LOG
//	imdebug("luma rgba=rg__ b=8 w=%d h=%d *auto t='combined' %p", puwbufC->linestep, pszOp->height, puwbufC->ptr);
//#endif
}












//
/*lint -esym(550, x) */
void combine_edge_and_direction(
									//
									IMG_UBBUF *pubbEdge, 
									IMG_COORD *pcoEdge,
									IMG_UWBUF *puwbufDir, 
									IMG_COORD *pcoDir,
									IMG_UWBUF *puwbufOutput, 
									IMG_COORD *pcoOutput,
									IMG_ULWORD ulScale, //scale of greylevel 
									IMG_SIZE *pszOp)
{
	IMG_LWORD i,j, x;
	IMG_UBYTE *pEdge;
	IMG_UWORD *pDir, *pOutput;
	BUF_OFF(pEdge, pubbEdge, pcoEdge);
	BUF_OFF(pDir, puwbufDir, pcoDir);
	BUF_OFF(pOutput, puwbufOutput, pcoOutput);
	for(i = 0; i<pszOp->height; i++)
	{
		if(i < pszOp->height-1)		x = pszOp->width;
		else					x = pszOp->width-7;
		j = 0;
		__asm
		{
			mov			ecx, 8
			cmp			ecx, x
			jg			loop_quit
			mov 		_EAX, pEdge
			mov 		_ESI, pDir
			mov 		_EDI, pOutput
			mov 		edx, x;
			mov			ecx, 23211	//32768*255/360
			movd		xmm7, ecx
			pshufd		xmm7, xmm7, 0
			packssdw	xmm7, xmm7
			mov			ecx, ulScale
			movd		xmm5, ecx
			xor 		_ECX, _ECX
			pxor		xmm6, xmm6
loop1:
			movq		xmm0, qword ptr[_EAX+_ECX]
			movdqu		xmm1, [_ESI+2*_ECX]
			punpcklbw	xmm0, xmm6
			psrlw		xmm0, xmm5
			packuswb	xmm0, xmm6
			movdqa		xmm2, xmm1
			movdqa		xmm3, xmm1
			pmullw		xmm2, xmm7
			pmulhw		xmm3, xmm7
			movdqa		xmm4, xmm2
			punpcklwd	xmm4, xmm3
			punpckhwd	xmm2, xmm3
			psrld		xmm4, 15
			psrld		xmm2, 15
			packssdw	xmm4, xmm2
			packuswb	xmm4, xmm6
			punpcklbw	xmm4, xmm0
			movdqu		[_EDI+2*_ECX], xmm4
			add			ecx, 8
			cmp			ecx, edx
			jng			loop1
			sub			ecx, 8
			mov			j, ecx
loop_quit:
		}
		for(;j<pszOp->width; j++)
		{
			x = ((pDir[j]&0x1ff)*23211)&0x7FFFFF;
			x >>= 15;
			pOutput[j] = (IMG_UWORD)(((pEdge[j]>>ulScale)<<(8)) | x);
		}
		pEdge += pubbEdge->linestep;
		pDir += puwbufDir->linestep;
		pOutput += puwbufOutput->linestep;
	}
}
//lint -restore

/*lint -esym(550, _xmmfactor, _xmmmaxd, _xmmzero) */
/*lint -esym(529, scale)*/
void distance_adjust(
					 //
					 IMG_UWBUF *puwbufC, 
					 IMG_COORD *pcoC,
					 IMG_SIZE *pszOp, 
					 IMG_UBYTE distance, 
					 IMG_UBYTE scalefactor)
{
	IMG_LWORD i,j=0,k, maxd = distance*distance, szx = pszOp->width, scale = scalefactor, linestep = puwbufC->linestep;
	char buf[64+15];
	__m128i *_xmmvalid, *_xmmfactor, *_xmmzero, *_xmmmaxd;
	IMG_UWORD *pS;
	//_xmmvalid = (__m128i *)Malloc_align(sizeof(__m128i)*4+15);
	_xmmvalid = (__m128i *)(ALIGN_ROUND_PTR16(buf));
	_xmmfactor = _xmmvalid+1;
	_xmmmaxd = _xmmvalid+2;
	_xmmzero = _xmmvalid+3;
	BUF_OFF(pS, puwbufC, pcoC);
	//IMG_WORD *pD2 = (IMG_WORD *)Malloc_align(szx);
	__asm
	{
		// _xmmzero.m128i_i64[0] = _xmmzero.m128i_i64[1] = 0;
		mov			_EDX, _xmmvalid
		pxor		xmm1, xmm1
		movdqa		[_EDX+48], xmm1
		// _xmmmaxd = _mm_set1_epi16(maxd);					 //set 8 for max distance
		mov			eax,maxd 
		movd		xmm1, eax
		movdqa		xmm0, xmm1
		punpcklwd	xmm1, xmm0
		pshufd		xmm1, xmm1, 0
		movdqa		[_EDX+32], xmm1
	}
	__asm emms;
	for(i = 0; i<pszOp->height-1; i++)
	{
		j = 0;
		__asm
		{
			// for(j = 0, k=0; j< pszOp->width; j+=8)
			mov			_EDI, _xmmvalid
			mov			eax, szx
			shl			eax, 1	
			xor			_ECX, _ECX				//_ECX for j
			mov			_ESI, pS
			movdqa		xmm6, [_EDI+32]		//_xmmmaxd
			mov			edx, scale
			movd		xmm7, edx
loop_start_1:
			//_xmm1 = _mm_load_si128((__m128i *)(pS+j));
			//_xmm2 = _mm_slli_epi16(_xmm1, 8);		//dir
			//_xmm3 = _mm_srli_epi16(_xmm1, 8);		//dist
			//_xmm3 = _mm_mullo_epi16(_xmm3, _xmm3);
			//_xmm2 = _mm_srli_epi16(_xmm1, 8);		
			//_xmm3 = _mm_subs_epu16(_xmmmaxd, _xmm3);
			//_xmm3 = _mm_srli_epi16(_xmm3, scalefactor);
			//_xmm3 = _mm_slli_epi16(_xmm3, 8);
			//_xmm3 = _mm_or_si128(_xmm3, _xmm2);
			//_mm_store_si128((__m128i *)(pD+j), _xmm3);
			movdqu		xmm1, [_ESI+_ECX]
			movdqa		xmm4, xmm6
			movdqa		xmm2, xmm1
			movdqa		xmm3, xmm1
			psllw		xmm2, 8
			psrlw		xmm3, 8		//dist
			pmullw		xmm3, xmm3
			psrlw		xmm2, 8
			psubusw		xmm4, xmm3
			psrlw		xmm4, xmm7
			psllw		xmm4, 8
			por			xmm2, xmm4
			movdqu		[_ESI+_ECX], xmm2
			// loop code
			add			ecx, 16
			cmp			ecx, eax
			jl			loop_start_1
			mov			j, ecx
		}
		memset(pS+szx, 0, (IMG_ULWORD)(linestep-szx)*sizeof(IMG_UWORD));
			/*
			for(j = 0; j<pszOp->width; j++)
			{
					if(pD[j] != pD2[j])
							SYS_Assert(0);
			}
			*/
		pS +=puwbufC->linestep;
	}
	szx-=16;
	__asm
	{
		// for(j = 0, k=0; j< pszOp->width; j+=16)
		xor			eax, eax
		cmp			eax, szx
		jg			loop_quit
		mov			_EDI, _xmmvalid
		mov			eax, szx
		shl			eax, 1	
		xor			_ECX, _ECX				//_ECX for j
		mov			_ESI, pS
		movdqa		xmm6, [_EDI+32]			//_xmmmaxd
		mov			edx, scale
		movd		xmm7, edx
loop_start_2:
		movdqu		xmm1, [_ESI+_ECX]
		movdqa		xmm4, xmm6
		movdqa		xmm2, xmm1
		movdqa		xmm3, xmm1
		psllw		xmm2, 8
		psrlw		xmm3, 8		//dist
		pmullw		xmm3, xmm3
		psrlw		xmm2, 8
		psubusw		xmm4, xmm3
		psrlw		xmm4, xmm7
		psllw		xmm4, 8
		por			xmm2, xmm4
		movdqu		[_ESI+_ECX], xmm2

		// loop code
		add			ecx, 16
		cmp			ecx, eax
		jl			loop_start_2	
		mov			j, ecx
loop_quit:
	}
	for(;j<pszOp->width; j++)
	{
		i = pS[j]>>8;
		i = i*i > maxd ? maxd : i*i;
		i = maxd-i, k = pS[j]&&0xFF;
		pS[j] = (IMG_UWORD)((i<<8)| k);
	}
	memset(pS+szx, 0, (IMG_ULWORD)(linestep-szx)*sizeof(IMG_UWORD));
	__asm emms;
/*lint -e87*/

#ifdef _OUTPUT_LOG
	imdebug("luma rgba=__ba b=8 w=%d h=%d *auto t='adjust' %p", puwbufC->linestep, pszOp->height, puwbufC->ptr);
#endif
}
//
IMG_WORD ALIGN_GenMaskMul_wub(IMG_WBUF *pubbSrc, IMG_COORD *pcoSOff, IMG_UBBUF *pubbSrc2, IMG_COORD *pcoSOff2, IMG_SIZE *pszOp, IMG_ULWORD ulScale)
//
{
	IMG_WORD *pS1;
	IMG_UBYTE *pS2;
	IMG_SIZE szOp;
	IMG_LWORD lwLinestep1, lwLinestep2, x, y;
	szOp.width = pszOp->width;
	szOp.height = pszOp->height;
	lwLinestep1 = pubbSrc->linestep;
	lwLinestep2 = pubbSrc2->linestep;

	BUF_OFF(pS1, pubbSrc, pcoSOff);
	BUF_OFF(pS2, pubbSrc2, pcoSOff);

	/******************************
	pwD = pwbLevel[i].ptr;
	pD = ubbufWeight.ptr;
	for(y = 0; y<szLevel[1].height; y++)
	{
		for(x = 0; x<szLevel[1].width; x++)
		{
			pwD[x] = (IMG_UWORD)((pwD[x]*(IMG_ULWORD)pD[x])>>7);
		}	
		pwD+= pwbLevel[i].linestep;
		pD += ubbufWeight.linestep;
	}
	******************************/
	__asm emms;
	for(y = 0; y<szOp.height; y++)
	{
		x = szOp.width-7;
		__asm
		{
			xor			eax, eax
			cmp			eax, x
			jg			loop_quit
			mov 		_ESI, pS1
			mov 		_EDI, pS2
			xor 		_ECX, _ECX
			pxor 		xmm7, xmm7
			movd		xmm6, ulScale
start:
			movq 		mm0, [_EDI+_ECX]
			movdqu 		xmm0, [_ESI+_ECX*2]
			movq2dq 	xmm1, mm0
			punpcklbw 	xmm1, xmm7
			movdqa 		xmm2, xmm1
			pmullw		xmm1, xmm0		//low
			pmulhw		xmm2, xmm0		//high
			//low 4 word
			movq		xmm3, xmm1
			movq		xmm4, xmm2
			punpcklwd	xmm3, xmm4
			psrld		xmm3, xmm6
			packssdw	xmm3, xmm7		//
			movdq2q		mm0, xmm3
			movq		[_ESI+_ECX*2], mm0
			//high 4 word
			punpckhwd	xmm1, xmm2
			psrld		xmm1, xmm6
			packssdw	xmm1, xmm7
			movdq2q		mm0, xmm1
			movq		[_ESI+_ECX*2+8], mm0
			//all 8 word
			add			ecx, 8
			cmp			ecx, x
			jng			start
			mov			x, ecx
loop_quit:
		}
		for(;x<szOp.width; x++)
		{
			pS1[x] = (IMG_UWORD)((pS1[x]*(IMG_LWORD)pS2[x])>>7);
		}
		pS1 += lwLinestep1;
		pS2 += lwLinestep2;
	}
	__asm emms;
	return OK;
}











//
IMG_VVOID feature_voting(	IMG_UBYTE *pubS, 
				   IMG_ULWORD Slinestep, //
				   IMG_WORD *pwD, 
				   IMG_ULWORD Dlinestep, 
				   IMG_WORD wValue,
				   IMG_SIZE *pszOp, 
				   IMG_VVOID *psrcstart,
				   IMG_VVOID *psrcend,
				   IMG_VVOID *pdststart,
				   IMG_VVOID *pdstend)
{
	/* equivalent c code
	for(y = starty; y<=endy; y++)
	{
		for(x = startx; x<=endx; x++)
		{
			pwD[x] += (pS[x])>0;					
		}
		pS += lwXLinestep2;
		pwD += lwXLinestep2;
	}
	*/
	IMG_LWORD x, y, sizex = pszOp->width;
	IMG_UXLWORD start_ptr, margin;
	IMG_UBYTE buf[32];
	IMG_WORD *pwValue;
	__m128i *xmmValue;

	xmmValue = (__m128i *)ALIGN_ROUND_PTR16(buf);
	for(x = 0, pwValue = (IMG_WORD *)xmmValue; x<8; x++)
		pwValue[x] = wValue;

	__asm emms;
	for(y = 0; y<pszOp->height; y++)
	{
		if(pwD < pdststart || pubS < psrcstart)
		{
			assert(0);
		}
		start_ptr = (IMG_UXLWORD)pwD;
		margin = (IMG_UXLWORD)((IMG_UXLWORD)(ALIGN_ROUND_PTR16(pwD)) - (IMG_UXLWORD)pwD)>>1;
		SYS_Assert((((start_ptr+15) & (~15)) - start_ptr)%2==0);
		for(x = 0; x<(IMG_LWORD)margin; x++)
		{
			pwD[x] += (pubS[x]>0 ? wValue : 0);
		}
		if(sizex > 7)
		{
			__asm
			{
				xor			_EAX, _EAX
				mov 		eax, x
				mov 		_ESI, pubS
				mov 		_EDI, pwD
				mov			_ECX, xmmValue
				movdqa		xmm2, [_ECX]
				mov			ecx, sizex
				sub			ecx, 7
				pxor 		xmm7, xmm7
start:
				//movq 		mm0, [esi+eax]
				movdqa		xmm1, [_EDI+_EAX*2]
				movq 		xmm0, qword ptr[_ESI+_EAX]
				punpcklbw	xmm0, xmm7
				pcmpgtw		xmm0, xmm7
				pand		xmm0, xmm2
				paddw		xmm1, xmm0
				//psubsw		xmm1, xmm0
				movdqa		[_EDI+_EAX*2], xmm1
				add			eax, 8
				cmp			eax, ecx
				jng			start
				mov			x, eax
			}
		}
		for(; x<sizex; x++)
		{
			pwD[x] += (pubS[x]>0?wValue:0);
		}
		pwD += Dlinestep;
		pubS += Slinestep;
		if(pwD-((IMG_LWORD)Slinestep-sizex) > pdstend || pubS-((IMG_LWORD)Slinestep-sizex) > psrcend)
		{
			assert(0);
		}
	}
	__asm emms;
	return;
}












//
IMG_VVOID get_main_dir(IMG_FEATUREPT const *pstVote,IMG_ULWORD ulFeatNum, IMG_ULWORD ulNumOfRotation, IMG_LWORD *lwMean, IMG_REAL *rStd)
//
{
	IMG_REAL rDir, rDiv;
	IMG_ULWORD ulHist[361] = {0}, ulAccu[361];
	IMG_LWORD i,j;
	IMG_REAL mean, stdvar, sum;
	rDiv = 360.0f/ulNumOfRotation;
	for(i = 0; i<(IMG_LWORD)ulFeatNum; i++)
	{
		rDir = ALIGN_NORMAL_DIR_NCOLOR( (IMG_WORD)pstVote[i].angle)-(IMG_REAL)floor(ALIGN_NORMAL_DIR_NCOLOR( pstVote[i].angle)/rDiv)*rDiv;
		j = (IMG_LWORD)(rDir < rDiv-rDir ? rDir+0.5f : rDir-rDiv-0.5f);
		ulHist[j+180]++;
	}
	ulAccu[0] = ulHist[0];
	for(i = 1; i<361; i++)ulAccu[i] = ulAccu[i-1]+ulHist[i];
	for(i = 0, mean = 0, sum = 0; i<361; i++)
	{
		if(ulAccu[i] > 5 && ulAccu[i] < ulFeatNum-5)
		{
			mean += (IMG_REAL)(ulHist[i])*(i-180);
			sum += ulHist[i];
		}
	}
	mean /= (sum+1);
	for(i = 0, stdvar = 0; i<361; i++)
	{
		if(ulAccu[i] > 5 && ulAccu[i] < ulFeatNum-5)
			stdvar += (IMG_REAL)(ulHist[i])*(i-180-mean)*(i-180-mean);
	}
	stdvar /= (sum+1);
	if(mean > 0)mean+=0.5f;
	else		mean-=0.5f;
	*lwMean = (IMG_LWORD)mean;
	*rStd = stdvar;
}












//
IMG_REAL quadratic_interpolation(IMG_REAL *x, IMG_REAL *y)
//
{
	IMG_REAL a, b;
	if(y[0] > 0 && y[1] > 0 && y[2] > 0)
	{
		if(fabs(((x[0]*x[0]-x[1]*x[1])*(x[1]-x[2])-(x[1]*x[1]-x[2]*x[2])*(x[0]-x[1])))>1e-6)
		{
			a = ((y[0]-y[1])*(x[1]-x[2])-(y[1]-y[2])*(x[0]-x[1]))/((x[0]*x[0]-x[1]*x[1])*(x[1]-x[2])-(x[1]*x[1]-x[2]*x[2])*(x[0]-x[1]));
			if(fabs(a) < 1e-6)
			{
				return x[1];
			}
			else
			{
				if(fabs(x[0]-x[1])<1e-6)
					b = ((y[1]-y[2])-(x[1]*x[1]-x[2]*x[2])*a)/(x[1]-x[2]);
				else
					b = ((y[0]-y[1])-(x[0]*x[0]-x[1]*x[1])*a)/(x[0]-x[1]);
			}
			return -b/(2*a);
		}
	}
	return x[1];
}












//
//merge line block nearer than given length
IMG_VVOID merge_line_block(	IMG_LWBUF *pulbufSrcDst,
						   //
						   IMG_ULWORD ulMinLineInter)
{
	IMG_LWORD i,j,k;
	IMG_LWORD end, start2, end2;
	IMG_LWORD *p;
	for(i = 0; i<pulbufSrcDst->size.height; i++)
	{
		p = pulbufSrcDst->ptr+(size_t)i*pulbufSrcDst->linestep;
		j = 0;
		while(p[j])
		{
			end = p[j+1], start2 = p[j+2];
			if(start2 > end)
			{
				if(start2 <= end+(IMG_LWORD)ulMinLineInter)
				{
					end2 = p[j+3];
					//merge this two
					p[j+1] = end2;
					k = 4;
					while(p[j+k])
					{
						p[j+k-2] = p[j+k];
						p[j+k-1] = p[j+k+1];
						k+=2;
					}
					p[j+k-2] = p[j+k];
					//p[j+k-1] = p[j+k+1];
				}
				else
				{
					j+=2;
				}
			}
			else
			{
				break;
			}
		}
	}
}

IMG_WORD get_vote_range(const IMG_SIZE *pszOp, IMG_FEATUREPT *pstVote, IMG_ULWORD ulFeatNum, 
		const IMG_REAL rStartAngle, const IMG_REAL rEndAngle, 
		const IMG_REAL rScaleX,const IMG_REAL rScaleY, 
		const IMG_ULWORD ulAbsoluteScale, const IMG_UWORD uwCompleteObj, 
		IMG_LWORD *plwMinX, IMG_LWORD *plwMinY, IMG_LWORD *plwMaxX, IMG_LWORD *plwMaxY)
{
	IMG_WORD 	wState = OK;
	IMG_ULWORD 	ulAngle;
	IMG_LWORD	i;
	IMG_REAL 	cose, sine, rAngle;
	IMG_LWORD 	startx, endx, starty, endy;
	IMG_RCOORD 	rcoNewCoord;
	IMG_LWORD 	lwMinX = 100000, lwMinY = 100000, lwMaxX = 0, lwMaxY = 0;
	for(ulAngle = 0; ulAngle < 10; ulAngle++)
	{
		startx = starty = 0;
		endx = pszOp->width-1; endy = pszOp->height-1;
		rAngle =(IMG_REAL) (rStartAngle + (rEndAngle-rStartAngle)*
			(ulAngle)/(8));
		rAngle = (IMG_REAL)(rAngle*PI/180);
		if(ulAngle == 9) rAngle = 0.0f;
		cose = (IMG_REAL)cos(rAngle), sine = (IMG_REAL)sin(rAngle);

		//recalculate each vector's direction and position
		if(uwCompleteObj)//in case whole object are going to be look for
		{
			for(i = 0; i<(IMG_LWORD)ulFeatNum; i++)
			{
				rcoNewCoord.x = (cose*pstVote[i].rco.x - sine*pstVote[i].rco.y)*rScaleX/ulAbsoluteScale;
				rcoNewCoord.y = (sine*pstVote[i].rco.x + cose*pstVote[i].rco.y)*rScaleY/ulAbsoluteScale;
				//if(rcoNewCoord[i].x < 0)
				startx = startx > (IMG_LWORD)-rcoNewCoord.x ? startx : (IMG_LWORD)-rcoNewCoord.x;
				//else
				endx = endx < (IMG_LWORD)pszOp->width-(IMG_LWORD)rcoNewCoord.x-1 ? endx : (IMG_LWORD)pszOp->width-(IMG_LWORD)rcoNewCoord.x-1;
				//if(rcoNewCoord[i].y < 0)
				starty = starty > (IMG_LWORD)-rcoNewCoord.y ? starty : (IMG_LWORD)-rcoNewCoord.y;
				//else
				endy = endy < pszOp->height-(IMG_LWORD)rcoNewCoord.y-1 ? endy : pszOp->height-(IMG_LWORD)rcoNewCoord.y-1;
			}
			if(lwMinX > startx) lwMinX = startx;
			if(lwMinY > starty) lwMinY = starty;
			if(lwMaxX < endx) lwMaxX = endx;
			if(lwMaxY < endy) lwMaxY = endy;

		}
		else	//incompleted object
		{
			lwMinX = 0;
			lwMinY = 0;
			lwMaxX = pszOp->width-1;
			lwMaxY = pszOp->height-1;
		}
	}
	if(lwMinX-3 < 0) 	*plwMinX = 0;
	else				*plwMinX = lwMinX-3;
	if(lwMinY-3 < 0) 	*plwMinY = 0;
	else				*plwMinY = lwMinY-3;
	if(lwMaxX+4 > pszOp->width)	*plwMaxX = pszOp->width-1;
	else					*plwMaxX = lwMaxX+3;
	if(lwMaxY+4 > pszOp->height)	*plwMaxY = pszOp->height-1;
	else					*plwMaxY = lwMaxY+3;
	return wState;
}
//
/*lint -e668*/
/*lint -e18*/
/*lint -e64*/
/*lint -e574*/
/*lint -e737*/
/*lint -e734*/
/*lint -e653*/
/*lint -e663*/
/*lint -e826*/
/*lint -e713*/
/*lint -e550*/
IMG_WORD CVisAlignSearch::generate_mask_core(IMG_UWBUF const *puwbCombined, 
					   //
					   IMG_UBYTE **ppubDirEdge, 
					   IMG_UBBUF const *pubMask, 
					   IMG_SIZE const *pszOpsize, 
					   CVisAlignRecordTable const *pstEptable,
					   IMG_REAL const rScaleX,
					   IMG_REAL const rScaleY,
					   IMG_ULWORD const ulNumOfRotation, 
					   IMG_REAL const rAcceptLevel,
					   IMG_REAL const rMaxVectorLength,
					   IMG_UWORD		uwPhase,
					   IMG_REAL const rStartAngle,
					   IMG_REAL const rEndAngle,
					   IMG_UWORD const uwCompleteObj,
					   IMG_UWORD const uwScaleLoopIndex,
					   IMG_LWBUF **pplwbufMask,
					   IMG_UBYTE *pubMaskflag, //0 for disable, 1 for enable
					   IMG_ULWORD *pulMaskNum,
					   IMG_UWORD uwMultipleObj,
					   ALIGN_SEARCH_OPTION	const *pstSrchOpt,
					   IMG_ULWORD const ulReductionLevel,
					   ALIGN_INPUT_TYPE InputType,
					   IMG_UWORD uwDebug
		)
{
	IMG_LWORD i,j,k, m=0, n=0, o, x, y, xs, xe;
	IMG_LWORD startx, starty, endx, endy;
	IMG_LWORD lwMinX, lwMinY, lwMaxX, lwMaxY, lwMax = 0, lwThrd;
	IMG_ULWORD ulReduction, ulXLinestep, ulXLinestep2 = 0;
	size_t 	ulMaskSize;
	IMG_ULWORD ulNumOfRot2=0, ulNumOfRot=0, ulFeat, ulAngle, ulAbsoluteScale;//, ulNumPos;
	IMG_ULWORD ulAngleMask, ulAngleShift, ulFeatNum = pstEptable->uwNumOfVoteFeature;
	IMG_LWORD *plw=NULL, *plw2=NULL;
	IMG_UBYTE **pSource=NULL, *pS=NULL, **ppD=NULL, *pD=NULL, *pubMaskflagPreviousLevel=NULL, *pubSrcStart=NULL, *pubSrcEnd=NULL;
	IMG_WORD state = OK, wLocalAngle, *pwD, *pwDstStart, *pwDstEnd;
	IMG_WORD wLocalMax = 0;
	IMG_UWORD *puwS=NULL;
	IMG_WBUF *pwbLevel=NULL, wbLevel2X;
	IMG_SIZE szLevel[2], szOP, szOPV, *pszOpVote;
	IMG_REAL cose, sine, rAngle, a,b, rWeight;
	IMG_REAL rRatio = 0.7f, rScaleMax = rScaleX > rScaleY ? rScaleX : rScaleY;
	IMG_RCOORD rco;
	IMG_COORD coR, coZ = {0}, coUL, coBR, coMaxPos, coMaxPosLocal, *pcoULVote;
	IMG_LWBUF *plwbufLevel=NULL, *plwbufMask = NULL;
	IMG_UBBUF ubbufMask, ubbEdgeSource;//, ubbufWeight;
	IMG_BYTE bWeight;
	IMG_LWORD lwScaleFactor;//, lwSumWeight;
	IMG_LWORD lwChannel = pstSrchOpt ->ubNumChannel == IMG_CHANNEL_COLOR ? 4:1, lwColorChannelIndex;
	IMG_FEATUREPT	*pstVote = pstEptable->pstVote;

	IMG_COORD coDst;
	IMG_SIZE szDst;

	IMG_UINT tid = GetCurrentThreadId();

	//IMG_LWORD kernel[] = {1,9,0,0,0,0,0,0,0};

	IMG_UBBUF ubbImage;
	IMG_WORD wMaxValue, wMinValue;
	IMG_CHAR *pathname=NULL;
	IMG_SIZE szImg;
	char *buf=NULL;

	IMG_LWBUF lwbufDest, lwbufKernel, lwbufEncoding;
	IMG_LWORD lwKernel[9]={1,3,0,1,3,0,1,3,0};
	IMG_SIZE szRLE, szKernel;

	CVisMemPool mem_pool;


	//const variable
	IMG_REAL SEARCH_ANGLE_INTERVAL;	 //search angle interval, if it is 3, means next rotation, the longest feature point changed 3 pixel
	IMG_ULWORD NUM_OF_DIRECTION, MAX_SCORE;
	for(i = 0, ulAbsoluteScale = 2; i<(IMG_LWORD)ulReductionLevel; i++) ulAbsoluteScale <<=1;
	//init
	if(InputType == ALIGN_2DCode)
		SEARCH_ANGLE_INTERVAL = 1.5f;
	else
		SEARCH_ANGLE_INTERVAL = 1.0f + 1.5f/(ulReductionLevel+1.0f);
	//
	if (uwDebug & 256) g_pstClock->Click("before_mask");
	check_heap(__FILE__, __LINE__);

	// Stack reduction 20141201 by vincent
	if((pathname = (IMG_CHAR *)mem_pool.Malloc(FILENAME_MAX_LENGTH *sizeof(IMG_CHAR))) == NULL)
	{
		state = MEM_ERR_MALLOC;
		goto end;
	}
	if((buf = (char *)mem_pool.Malloc(256*sizeof(char))) == NULL)
	{
		state = MEM_ERR_MALLOC;
		goto end;
	}

	szLevel[0].width = pszOpsize->width;
	szLevel[0].height = pszOpsize->height;
	szLevel[1].width = (pszOpsize->width >> 1)+1;
	szLevel[1].height = (pszOpsize->height >> 1)+1;
	if((size_t)szLevel[0].width * szLevel[0].height< 2500 || 
		rMaxVectorLength*rScaleMax < 5*ulAbsoluteScale || 
		ulReductionLevel >= MAX_COARSE_SRCH_REDUCTION /*||
		ulReductionLevel >= pstEptable->uwExpVotingReduction*/)	//size < 50*50 or max vector length small than 8 pixel
	{
		ulReduction = 0;
	}
	else 
	{
		if(InputType == ALIGN_POINT && ulReductionLevel >= MAX_COARSE_SRCH_REDUCTION-2)
			ulReduction = 0;
		else if(InputType == ALIGN_2DCode && ulReductionLevel >= MAX_COARSE_SRCH_REDUCTION-1)
			ulReduction = 0;
		else
			ulReduction = 1;
	}
	if(InputType == ALIGN_2DCode)
		NUM_OF_DIRECTION = 16;
	else
		NUM_OF_DIRECTION = 32;

	szRLE.width = szLevel[0].width+2;
	szRLE.height = szLevel[0].height;

	//get_main_dir(pstVote, ulFeatNum, NUM_OF_DIRECTION, &lwFeatAngleBias, &rStd);
	//if(rMaxVectorLength*rScaleMax < 16 && rStd > 70)
	//{
	//	NUM_OF_DIRECTION = 32;
	//}
	if(uwDebug & 5)
	{
		HL_Printf(m_pHtmlLog,  "mask generation\n");
		_snprintf(buf, 256, "reduction = %lu, direction = %lu \n", ulReductionLevel, NUM_OF_DIRECTION);
		HL_Printf(m_pHtmlLog,  buf);
	}
	for(ulFeat = 0, MAX_SCORE = 0; ulFeat<ulFeatNum; ulFeat++)
	{
		MAX_SCORE += ((IMG_BYTE)pstVote[ulFeat].rWeighting) > 0 ? pstVote[ulFeat].rWeighting : 0;
		//if((pstVote[ulFeat].ubVoteHalfAngle & 0x80) && (pstSrchOpt ->wAdvLrnOpt & 1)) uwPhase = 1;
	}
	switch(NUM_OF_DIRECTION)
	{
	case 32:
		ulAngleShift = 3;
		break;
	case 16:
		ulAngleShift = 4;
		break;
	case 8:
		ulAngleShift = 5;
		break;
	case 4:
		ulAngleShift = 6;
		break;
	default:
		state = VIS_ERR_INVALID_ARG;
		goto end;
	}
	switch(uwPhase)
	{
	case 0:
	case 3:
	case 4:
		ulAngleMask = 0xFF;
		break;
	case 1:
	case 2:
		ulAngleMask = 0x7F;
		break;
	default:
		state = VIS_ERR_INVALID_ARG;
		goto end;
	}
	if(pubMaskflag == NULL) 
	{
		THROW_VIS_EXCEPTION(VIS_ERR_NULLPTR);
		state = MEM_ERR_MALLOC;
		goto end;
	}
	//decide weight scale factor
	for(i = 0, lwScaleFactor = 1; i<32; i++)
	{
		if(MAX_SCORE*lwScaleFactor > 8192)break;
		lwScaleFactor *= 2;
	}
	//

	//decide search range
	//
	get_vote_range(pszOpsize, pstVote, ulFeatNum, rStartAngle, rEndAngle, rScaleX, rScaleY, ulAbsoluteScale>>1, 
				uwCompleteObj, &lwMinX, &lwMinY, &lwMaxX, &lwMaxY);
	if(lwMinX > lwMaxX || lwMinY > lwMaxY)
	{
		state = ALIGN_ERR_NO_OBJECT_FOUND;
		goto end;
	}
	//
	//
	//generate dir edge map
	//

	lwThrd = (IMG_LWORD)(((IMG_LREAL)rAcceptLevel)*(IMG_LREAL)MAX_SCORE*lwScaleFactor+0.5);
	ulXLinestep = (szLevel[0].width+15) & (~0xF);
	ulXLinestep2 = (szLevel[1].width+15) & (~0xF);

	ubbEdgeSource.size.width = szLevel[1].width;
	ubbEdgeSource.size.height = (szLevel[1].height*NUM_OF_DIRECTION);
	ubbEdgeSource.linestep = ulXLinestep2;
	if(false)
	{
		//g_ppEdgeDirection[ulReductionLevel]= (IMG_VVOID **)CVisMemPool::PMalloc(lwChannel*NUM_OF_DIRECTION*sizeof(IMG_UBYTE *)+16);
		pSource = (IMG_UBYTE **)mem_pool.Malloc(lwChannel*NUM_OF_DIRECTION*sizeof(IMG_UBYTE *));
		if(g_ppEdgeDirection[ulReductionLevel] == NULL || pSource==NULL)
		{
			if(g_ppEdgeDirection[ulReductionLevel] == NULL)
			{
				if(uwDebug & 1)
				{
					HL_Printf(m_pHtmlLog,  "Did not call ALIGN_MallocForCoarseSearchVoting before voting\n");
				}
			}
			THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
			state = MEM_ERR_MALLOC;	goto end;
		}
		//add some margin
		//g_ppEdgeDirection[ulReductionLevel][0] = (IMG_UBYTE *)CVisMemPool::PMalloc(lwChannel*ulXLinestep2*(szLevel[1].height*NUM_OF_DIRECTION+1)+16);
		//clear margin memory
		memset((char *)g_ppEdgeDirection[ulReductionLevel][0]+(size_t)ulXLinestep2*szLevel[1].height*NUM_OF_DIRECTION, 0, ulXLinestep2+16);

		pSource[0] = (IMG_UBYTE *)ALIGN_ROUND_PTR16(g_ppEdgeDirection[ulReductionLevel][0]);
		ubbEdgeSource.ptr = pSource[0];
		if(g_ppEdgeDirection[ulReductionLevel][0] == NULL)
		{
			THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
			state = MEM_ERR_MALLOC;
			goto end;
		}
		for(i = 1; i<(IMG_LWORD)NUM_OF_DIRECTION*lwChannel; i++)pSource[i] = pSource[0]+i*(IMG_LWORD)ulXLinestep2*szLevel[1].height;
		//check_heap(__FILE__, __LINE__);
		if (uwDebug & 256) g_pstClock->Click("after_mask_init");
		if(puwbCombined == NULL && ppubDirEdge != NULL)
		{
			__asm emms;
			for(n = 0; n<lwChannel; n++)
			{
				for(i = 0; i<(IMG_LWORD)NUM_OF_DIRECTION; i++)
				{
					memset(pSource[n*NUM_OF_DIRECTION+i], 0, ulXLinestep2*szLevel[1].height);
					for(j = 0; j<szLevel[0].height; j++)
					{
						pS = ppubDirEdge[n*NUM_OF_DIRECTION+i]+j*(IMG_LWORD)ulXLinestep;
						pD = pSource[n*NUM_OF_DIRECTION+i]+(j>>1)*ulXLinestep2;
						//for(k = 0; k<szLevel[0].width; k++)
						//{
						//	pD[k>>1] |= pS[k];
						//}
						k = szLevel[1].width-7;
						__asm
						{
							mov		_ESI, pS
							mov		_EDI, pD
							xor		_ECX, _ECX
							mov		eax, k
start:
							movdqa	xmm0, [_ESI+_ECX*2]
							movq	mm0, [_EDI+_ECX]
							movdqa	xmm1, xmm0
							psllw	xmm0, 8
							psrlw	xmm1, 8
							psrlw	xmm0, 8
							por		xmm0, xmm1
							packuswb xmm0, xmm0
							movq2dq	xmm1, mm0
							por		xmm0, xmm1
							movdq2q	mm0, xmm0
							movq	[_EDI+_ECX], mm0
							add		ecx, 8
							cmp		ecx, eax
							jl 		start
							shl		ecx, 1
							mov		k, ecx
						}
						for(;k<szLevel[0].width; k++)
						{
							pD[k>>1] |= pS[k];
						}
					}
				}
			}
			__asm emms;
			g_ulSrchTimestamp[ulReductionLevel] = pstSrchOpt ->ulSrchTimestamp;
		}
		else if(puwbCombined != NULL)
		{
			IMG_UWORD uwStep = (IMG_UWORD)((pstSrchOpt ->ubAngleMatchTolerance+1+20)*256.0/360.0+0.5);
			if(uwStep < 14) uwStep = 14;
			if(uwStep > 64) uwStep = 64;
			for(n = 0; n<lwChannel; n++)
			{
				for(m = 0; m<(IMG_LWORD)NUM_OF_DIRECTION; m++)
				{
					memset(pSource[n*NUM_OF_DIRECTION+m], 0, ulXLinestep2*szLevel[1].height);
					for(i = 0; i<szLevel[0].height; i++)
					{
						puwS = puwbCombined[n].ptr+(size_t)i*puwbCombined[n].linestep;
						pD = pSource[n*NUM_OF_DIRECTION+m]+(i>>1)*(IMG_LWORD)ulXLinestep2;
						j = szLevel[0].width;
						//o = (i>>1)*(IMG_LWORD)ulXLinestep2;
						x = (256>>(8-ulAngleShift))*m;	//angle
						//if(x < 64 || x > 192)
						//{
						//	if(x > 192) x = x-256;
						//	for(j = 0; j<szLevel[0].width; j++)
						//	{
						//		k = (IMG_BYTE)(puwS[j] & ulAngleMask);	//dir
						//		if(k>=x-uwStep && k<=x+uwStep)	pD[o+(j>>1)] |= (puwS[j]>>8);
						//	}
						//}
						//else
						//{
						//	x += 256;
						//	for(j = 0; j<szLevel[0].width; j++)
						//	{
						//		k = (puwS[j] & ulAngleMask)+256;	//dir
						//		if(k>=x-uwStep && k<=x+uwStep)	pD[o+(j>>1)] |= (puwS[j]>>8);
						//	}
						//}
						__asm
						{
							mov				_ESI, puwS
							mov				_EDI, pD
							mov				eax, x
							mov				edx, eax
							xor				ecx, ecx
							mov				cx, uwStep
							sub 			edx, ecx
							movd			xmm6, edx
							mov				edx, eax
							add				edx, ecx
							movd			xmm5, edx
							pshuflw			xmm6, xmm6, 0
							punpcklwd		xmm6, xmm6
							pshuflw			xmm5, xmm5, 0
							punpcklwd		xmm5, xmm5
							psllw			xmm6, 8
							psllw			xmm5, 8
							psrlw			xmm6, 8
							psrlw			xmm5, 8
							packuswb 		xmm6, xmm6		//x-uwStep
							packuswb 		xmm5, xmm5		//x+uwStep
							mov				eax, ulAngleMask
							movd			xmm4, eax
							pshuflw			xmm4, xmm4, 0
							punpcklwd		xmm4, xmm4
							pxor			xmm7, xmm7
							mov				ecx, j
							xor				_EAX, _EAX
	loopstart:
							movdqa			xmm0, [_ESI+4*_EAX]	
							movd			xmm3, dword ptr[_EDI+_EAX]				
							movdqa			xmm1, xmm0
							pand			xmm1, xmm4		//mask apply
							packuswb		xmm1, xmm7		//
							movdqa			xmm2, xmm5		//upper bound
							psubb			xmm2, xmm1		
							psubb			xmm1, xmm6		//lower bound
							pcmpgtb			xmm2, xmm7
							pcmpgtb			xmm1, xmm7
							pand			xmm1, xmm2		//result
							psrlw			xmm0, 8
							packuswb		xmm0, xmm7
							pand			xmm0, xmm1
							packsswb		xmm0, xmm7
							por				xmm3, xmm0
							movd			dword ptr[_EDI+_EAX], xmm3

							add				eax, 4
							sub				ecx, 8
							ja				loopstart

						}
					}
				}
			}
			//check_heap(__FILE__, __LINE__);
		}
		else
		{
			state = ALIGN_ERR_INVALID_ARG;
			goto end;
		}
	}
	else
	{
		pSource = (IMG_UBYTE **)mem_pool.Malloc(lwChannel*NUM_OF_DIRECTION*sizeof(IMG_UBYTE *));
		if(pSource==NULL)
		{
			THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
			state = MEM_ERR_MALLOC;	goto end;
		}
		pSource[0] = (IMG_UBYTE *)ALIGN_ROUND_PTR16(g_ppEdgeDirection[ulReductionLevel][0]);
		ubbEdgeSource.ptr = pSource[0];
		for(i = 1; i<(IMG_LWORD)NUM_OF_DIRECTION*lwChannel; i++)pSource[i] = pSource[0]+i*(IMG_LWORD)ulXLinestep2*szLevel[1].height;
		SYS_Assert(pSource);
		SYS_Assert(pSource[0]);
	}
	if(uwDebug & 2048)
	{
		IMG_ULWORD	ulTime;
		IMG_CHAR *p;
		SYS_GetTimeInUS(&ulTime);
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uCoarseMaskEdgeSrc%02d.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, ulReductionLevel);
		CVisImage img(ubbEdgeSource);
		img.WriteImage(pathname);
		p = strrchr(pathname, '\\')-10;
		writeLog("GMask Edge Source at reduction %d\n", ulReductionLevel);
		HL_InsertImage(m_pHtmlLog, p);

		//_snprintf((char *)pathname, FILENAME_MAX_LENGTH, "edgesrc_%u_R%02u_03%d.bmp", ulTime, ulReductionLevel, kwAlignFileIndex);
		//ALIGN_SaveImage(&ubbEdgeSource, (IMG_UBYTE *)pathname);
	}
	if (uwDebug & 256) g_pstClock->Click("after_dirmap");
#ifdef _OUTPUT_LOG
	imdebug("lum *auto b=8 w=%d h=%d t='mask source level1' %p", ulXLinestep2, szLevel[1].height*NUM_OF_DIRECTION, pSource[0]);
#endif
	if(uwDebug & 4)
	{
		IMG_UBBUF bufSrc;
		//char name[20];
		//_snprintf(name, sizeof(name), "gsi_%d", ulReductionLevel);
		bufSrc.linestep = bufSrc.size.width = (ulXLinestep2);
		bufSrc.size.height = (szLevel[1].height*NUM_OF_DIRECTION);
		bufSrc.ptr = pSource[0];
		//create_filename((IMG_UBYTE *)buf,(IMG_UBYTE*)name,wAlignFileIndex,(IMG_UBYTE*)".bmp");
		//FILE_SaveImage((IMG_UBBUF *)&bufSrc,&coZ,(IMG_SIZE *)&bufSrc.size,(IMG_UBYTE *)buf);

		HL_Printf(m_pHtmlLog, "Max score is %d\n", MAX_SCORE*lwScaleFactor);
		HL_Printf(m_pHtmlLog, "Scale 1 position [%3d %3d],[%3d %3d],[%3d %3d],[%3d %3d],[%3d %3d],\n",
			(IMG_LWORD)((output_1.x >> (ulReductionLevel + 1))), (IMG_LWORD)((output_1.y >> (ulReductionLevel + 1))),
			(IMG_LWORD)((output_1.x >> (ulReductionLevel + 1))), (IMG_LWORD)((output_1.y >> (ulReductionLevel + 1)) + szLevel[1].height),
			(IMG_LWORD)((output_1.x >> (ulReductionLevel + 1))), (IMG_LWORD)((output_1.y >> (ulReductionLevel + 1)) + szLevel[1].height * 2),
			(IMG_LWORD)((output_1.x >> (ulReductionLevel + 1))), (IMG_LWORD)((output_1.y >> (ulReductionLevel + 1)) + szLevel[1].height * 3),
			(IMG_LWORD)((output_1.x >> (ulReductionLevel + 1))), (IMG_LWORD)((output_1.y >> (ulReductionLevel + 1)) + szLevel[1].height * 4)
		);
		if (uwDebug & 2048)
		{
			IMG_CHAR *p;
			_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uCoarseMasSource%02d.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, ulReductionLevel);
			CVisImage img(bufSrc);
			img.WriteImage(pathname);
			p = strrchr(pathname, '\\') - 10;
			writeLog("GMask Edge Source at reduction %d, in difference direction\n", ulReductionLevel);
			HL_InsertImage(m_pHtmlLog, p);
		}

	}
	//ulReduction would never equal to 2, 
	//Set to 2 for debug reason
	if(ulReduction == 2 && ulReductionLevel == 0)
	{
		szOP.width = (pszOpsize->width);
		szOP.height = (pszOpsize->height);
		plwbufMask = (IMG_LWBUF *)CVisMemPool::PMalloc(sizeof(IMG_LWBUF));
		VALIDATE_MALLOC(plwbufMask);
		plwbufMask[0].size.width = 3; 
		plwbufMask[0].size.height = szOP.height;
		plwbufMask[0].linestep = 3;
		plwbufMask[0].ptr = (IMG_LWORD *)CVisMemPool::PMalloc(3* szOP.height*sizeof(IMG_LWORD));
		VALIDATE_MALLOC(plwbufMask[0].ptr);

		for(i = 0; i<szOP.height; i++)
		{
			plwbufMask[0].ptr[i*plwbufMask[0].linestep+0] = 0;
		}
		for(i = lwMinY; i<lwMaxY; i++)
		{
			plwbufMask[0].ptr[i*plwbufMask[0].linestep] = (lwMinX+1);
			plwbufMask[0].ptr[i*plwbufMask[0].linestep+1] = (lwMaxX+1);
			plwbufMask[0].ptr[i*plwbufMask[0].linestep+2] = 0;
		}

		*pulMaskNum = 1;
		*pplwbufMask = plwbufMask;
		pubMaskflag[0] = IMG_TRUE;
#ifdef _OUTPUT_LOG
		MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)&ubbufMask, sizeof(IMG_UBYTE), sizeof(IMG_UBYTE));
		DSP_RLEDecoding(plwbufMask, &ubbufMask, &coZ, &szOP);
		imdebug("lum *256 b=8 w=%d h=%d t='Mask buffer 0' %p", ubbufMask.linestep, ubbufMask.size.height, ubbufMask.ptr);
#endif
		goto end;
	}

	{
		//voting with mask
		//
		{
			//check_heap(__FILE__, __LINE__);
			ulNumOfRot = (IMG_ULWORD)(((rMaxVectorLength*rScaleMax)/ulAbsoluteScale) *
				(rEndAngle - rStartAngle)*
				PI/180.0f/SEARCH_ANGLE_INTERVAL)+1; 
			if(ulNumOfRot%2==0)ulNumOfRot++;
			if((rEndAngle-rStartAngle)/ulNumOfRot > 5.0f*ulAbsoluteScale)
			{
				ulNumOfRot =(IMG_ULWORD)((IMG_LREAL)(rEndAngle-rStartAngle)/5.0/ulAbsoluteScale+0.5); 
				if(ulNumOfRot%2==0)ulNumOfRot++;
			}
			szOP.width = ((lwMaxX-lwMinX+1))>>1;
			szOP.height = ((lwMaxY-lwMinY+1))>>1;
			szOP.width++, szOP.height++;

			pwbLevel = (IMG_WBUF *)mem_pool.Malloc(sizeof(IMG_WBUF)*ulNumOfRot);
			//ulNumPos = (20+szOP.width*szOP.height/20);
			//pcoMaxPos = (IMG_COORD *)mem_pool.Malloc(sizeof(IMG_COORD)*ulNumPos);
			pubMaskflagPreviousLevel = (IMG_UBYTE *)mem_pool.Malloc(ulNumOfRot);
			pszOpVote = (IMG_SIZE *)mem_pool.Malloc(sizeof(IMG_SIZE)*ulNumOfRot);
			pcoULVote = (IMG_COORD *)mem_pool.Malloc(sizeof(IMG_COORD)*ulNumOfRot);

			if(pwbLevel == NULL || /*pcoMaxPos == NULL || */pubMaskflagPreviousLevel == NULL||
				pszOpVote == NULL)
			{
				THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
				state = MEM_ERR_MALLOC;
				goto end;
			}
			memset(pszOpVote, 0, sizeof(IMG_SIZE)*ulNumOfRot);
			memset(pcoULVote, 0, sizeof(IMG_COORD)*ulNumOfRot);
			memset(pwbLevel, 0, sizeof(IMG_UBBUF)*ulNumOfRot);

			MEM_AllocBufAtBank_align(szLevel, (IMG_VVBUF *)&ubbufMask, sizeof(IMG_UBYTE));
			if(ubbufMask.ptr == nullptr)	goto end;

			//check_heap(__FILE__, __LINE__);
			szDst.width = (szLevel[1].width+1)*2;
			szDst.height = (szLevel[1].height+1)*2;
			MEM_AllocBufAtBank_align(&szDst, (IMG_VVBUF *)&wbLevel2X, sizeof(IMG_WORD));
			if(wbLevel2X.ptr == nullptr)	goto end;
			state = VIS_FillBuffer_w(0, &wbLevel2X, &coZ, &szDst);
			if (state != OK) goto end;


			MEM_AllocBufAtBank(&szRLE, (IMG_VVBUF *)&lwbufEncoding, sizeof(IMG_LWORD));
			MEM_AllocBufAtBank(&szRLE, (IMG_VVBUF *)&lwbufDest, sizeof(IMG_LWORD));
			if (lwbufDest.ptr == nullptr) goto end;
						
			lwbufKernel.size.width = lwbufKernel.size.height = 3;
			szKernel.width = szKernel.height = 3;
			lwbufKernel.linestep = 3;
			lwbufKernel.ptr = lwKernel;

			plwbufMask = (IMG_LWBUF *)CVisMemPool::PMalloc(sizeof(IMG_LWBUF)*ulNumOfRot);
			VALIDATE_MALLOC(plwbufMask);

			memset(plwbufMask, 0, sizeof(IMG_LWBUF)*ulNumOfRot);
			*pulMaskNum = ulNumOfRot;
			for(i = 0; i<(IMG_LWORD)ulNumOfRot; i++)
			{
				pubMaskflagPreviousLevel[i] = IMG_TRUE;
			}
			//voting
			if (uwDebug & 256) g_pstClock->Click("before_voting");
			//check_heap(__FILE__, __LINE__);
			lwMax = 0;
			if(ulReduction == 0)
			{
				plwbufLevel = NULL;
				ulNumOfRot2 = 0;
			}
			else
			{
				//generate mask of level 1
				if (uwDebug & 256) g_pstClock->Click("before_submask");
				check_heap(__FILE__, __LINE__);
				state = generate_mask_core(NULL, pSource,pubMask, szLevel+1, pstEptable, rScaleX, rScaleY,
					ulNumOfRotation, rAcceptLevel, rMaxVectorLength, uwPhase, rStartAngle, rEndAngle,
					uwCompleteObj, uwScaleLoopIndex, &plwbufLevel, pubMaskflagPreviousLevel, &ulNumOfRot2, uwMultipleObj,
					pstSrchOpt, ulReductionLevel+1, InputType, uwDebug);
				if(state != OK)	goto end;
				if (uwDebug & 256) g_pstClock->Click("after_submask");
			}
			/*
			for(i = 0; i<(IMG_LWORD)ulNumOfRot; i++)
			{
				state = MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)pwbLevel+i);
				if(state != OK)	goto end;
				//check_heap(__FILE__, __LINE__);
			}
			*/
			//
			for(ulAngle = 0; ulAngle<ulNumOfRot; ulAngle++)
			{
				for(x = 0; x<(IMG_LWORD)ulNumOfRot; x++)
				{
					rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
						((IMG_LREAL)x+0.5)/(ulNumOfRot)));
					if(ulAngle == 0 && uwDebug & 2048)	
						HL_Printf(m_pHtmlLog, "%02d Search Angle at %f\n", x, rAngle);
				}
				//check repeat angle 
				if(pstSrchOpt ->rRepeatingAngle >= 10)
				{
					m = IMG_FALSE;
					rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
						(ulAngle+0.5)/(ulNumOfRot)));

					for(a = 0; a<360; a+= pstSrchOpt ->rRepeatingAngle)
					{
						b = rAngle + a - (pstSrchOpt ->rMinAngle+pstSrchOpt->rMaxAngle)/2.0;
						while(b < -180) b+=360.0f;
						while(b > 270) b-=360.0f;
						if(fabs(b) < IMG_MAX((pstSrchOpt->rMaxAngle-pstSrchOpt->rMinAngle)*2/3,(rEndAngle-rStartAngle)/ulNumOfRot)+1e-3)
						{
							m = IMG_TRUE;
							break;
						}
					}
					if(!m)	
					{
						pcoULVote[ulAngle].x = pcoULVote[ulAngle].y = 0;
						pszOpVote[ulAngle].width = pszOpVote[ulAngle].height = 0;
						pszOpVote[ulAngle].width = szLevel[1].width-1;
						pszOpVote[ulAngle].height = szLevel[1].height-1;
						pubMaskflag[ulAngle] = IMG_FALSE;
						if(uwDebug & 2048)
							HL_Printf(m_pHtmlLog,  "%02d: Max voting score: 0\n", ulAngle);
						continue;
					}
				}

				//get mask size
				ulMaskSize = (size_t)szLevel[1].width*szLevel[1].height+1;
				rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
							(ulAngle+0.5)/(ulNumOfRot))*PI/180.0f);
				if(plwbufLevel)
				{
					for(x = 0, a = 1000; x<(IMG_LWORD)ulNumOfRot2; x++)
					{
						b = (IMG_REAL)fabs(rAngle - (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
										(x+0.5f)/(ulNumOfRot2))*(IMG_REAL)PI/180.0f));
						if(a > b)
						{
							a = b; n = x;
						}
					}
					ulMaskSize = 0;
					for(y = 0; y<plwbufLevel[n].size.height; y++)
					{
						plw = plwbufLevel[n].ptr+y*plwbufLevel[n].linestep;
						while(plw[0])
						{
							ulMaskSize+= plw[1]-plw[0]+1;
							plw+=2;
						}
					}
				}
				if(pubMaskflagPreviousLevel && pubMaskflagPreviousLevel[n] == IMG_FALSE && plwbufLevel!=NULL)
				{
					pubMaskflag[ulAngle] = IMG_FALSE;
					continue;
				}
				MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)pwbLevel+ulAngle, sizeof(IMG_WORD));
				if(pwbLevel[ulAngle].ptr == nullptr)	goto end;
				//init mask
				memset(pwbLevel[ulAngle].ptr, 0, sizeof(IMG_UWORD)*pwbLevel[ulAngle].linestep*pwbLevel[ulAngle].size.height);



				//check_heap(__FILE__, __LINE__);
				//if mask size large or no mask, full voting, otherwise vote by mask
				if((size_t)(25*ulMaskSize) > ((size_t)szLevel[1].width*szLevel[1].height) || plwbufLevel==NULL)
				//{{{
				{
					for(ulFeat = 0; ulFeat<ulFeatNum; ulFeat++)
					{
						rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
							(ulAngle+0.5)/(ulNumOfRot))*PI/180.0f);
						cose = (IMG_REAL)cos(rAngle), sine = (IMG_REAL)sin(rAngle);
						rco.x = ((cose*pstVote[ulFeat].rco.x - sine*pstVote[ulFeat].rco.y)*rScaleX);
						rco.y = ((sine*pstVote[ulFeat].rco.x + cose*pstVote[ulFeat].rco.y)*rScaleY);
						if(InputType == ALIGN_POINT)
							wLocalAngle = (IMG_WORD)(ALIGN_NORMAL_DIR_NCOLOR( (IMG_LREAL)pstVote[ulFeat].angle)*256/360+0.5);
						else
							wLocalAngle = (IMG_WORD)(rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( (IMG_LREAL)pstVote[ulFeat].angle)*256/360+0.5);
						//if((pstVote[ulFeat].ubVoteHalfAngle & 0x80) && (pstSrchOpt ->wAdvLrnOpt & 1)) //feature phase inv
						//{
						//	wLocalAngle = (IMG_WORD)(((wLocalAngle+(256>>(8-ulAngleShift+1))) & 0x7f) >> ulAngleShift);
						//}
						//else
						wLocalAngle = (IMG_WORD)(((wLocalAngle+(256>>(8-ulAngleShift+1))) & ulAngleMask) >> ulAngleShift);
						SYS_Assert(wLocalAngle < (IMG_LWORD)NUM_OF_DIRECTION);

						coR.x = ((floor((IMG_LREAL)rco.x+65536+0.5))/(ulAbsoluteScale))-(65536/((IMG_WORD)ulAbsoluteScale));
						coR.y = ((floor((IMG_LREAL)rco.y+65536+0.5))/(ulAbsoluteScale))-(65536/((IMG_WORD)ulAbsoluteScale));

						//if(coR.x < 0)						startx = -coR.x > (lwMinX>>1) ? -coR.x : (lwMinX>>1);
						//else								startx = (lwMinX>>1);
						//if(coR.y < 0)						starty = -coR.y > (lwMinY>>1) ? -coR.y : (lwMinY>>1);
						//else								starty = (lwMinY>>1);
						//if(coR.x >= (pszOpsize->width-lwMaxX)>>1)	endx = ((pszOpsize->width-1)>>1)-coR.x;
						//else								endx = lwMaxX>>1;
						//if(coR.y >= (pszOpsize->height-lwMaxY)>>1)	endy = ((pszOpsize->height-1)>>1)-coR.y;
						//else								endy = lwMaxY>>1;
						if(-coR.x>(lwMinX>>1))					startx = -coR.x;
						else									startx = (lwMinX>>1);
						if(-coR.y>(lwMinY>>1))					starty = -coR.y;
						else									starty = (lwMinY>>1);
						if(coR.x>((pszOpsize->width>>1)-(lwMaxX>>1))-1)	endx   = (pszOpsize->width>>1)-coR.x-1;
						else									endx   = (lwMaxX>>1);
						if(coR.y>((pszOpsize->height>>1)-(lwMaxY>>1))-1)	endy   = (pszOpsize->height>>1)-coR.y-1;
						else									endy   = (lwMaxY>>1);

						if(ALIGN_IS_NCOLOR_NORMAL((IMG_WORD)pstVote[ulFeat].angle) && pstSrchOpt->ubColorMatchOpt != ALIGN_NCOLOR_DIR_MATCH_SEARCHMAX)
							lwColorChannelIndex = ALIGN_INDEX_NCOLOR((IMG_WORD)pstVote[ulFeat].angle)+1;
						else 
							lwColorChannelIndex = 0;
						pS = pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(starty+coR.y)*(ulXLinestep2)+coR.x;
						pwD = pwbLevel[ulAngle].ptr+(size_t)pwbLevel[ulAngle].linestep*(starty-(lwMinY>>1))+startx-(lwMinX>>1);

						if(endx >= startx && endy >= starty)
						{
							szOPV.width = (endx-startx+1);
							szOPV.height = (endy-starty+1);
							if( ulReductionLevel>0 )
							{
								bWeight = (IMG_BYTE)(pstVote[ulFeat].rWeighting+0.5);
								if(bWeight < 0) continue; //only vote positive feature
								feature_voting(pS+startx, ulXLinestep2, pwD, pwbLevel[ulAngle].linestep, (IMG_WORD)(bWeight*lwScaleFactor), &szOPV, 
									pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle], pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(size_t)szLevel[1].height*ulXLinestep2, 
									pwbLevel[ulAngle].ptr, pwbLevel[ulAngle].ptr+ (size_t)pwbLevel[ulAngle].size.height*(IMG_UINT)pwbLevel[ulAngle].linestep);
							}
							else
							{
								bWeight = (IMG_BYTE)(pstVote[ulFeat].rWeighting+0.5);
								if(bWeight < 0) continue; //only vote positive feature
								rco.x /= ulAbsoluteScale, rco.y /=ulAbsoluteScale;
								if(rco.x > coR.x)	{	j = 1;	a = coR.x+1-rco.x;	}
								else				{	j = 0;	a = coR.x-rco.x;	}
								if(rco.y > coR.y)	{	k = 1;	b = coR.y+1-rco.y;	}
								else				{	k = 0;	b = coR.y-rco.y;	}
								if(starty+(k-1)+coR.y < 0)
								{
									pS+=ulXLinestep2;
									pwD+=pwbLevel[ulAngle].linestep;
									szOPV.height--;
								}
								if(starty+(k-1)+coR.y <= 0)
								{
									if(j == 0) 
									{
										pS++, pwD++;
										szOPV.width--;
									}
								}
								rWeight = (bWeight*lwScaleFactor*a*b+0.5f);
								if(rWeight > 1 && a*b > 0.04f)
                                    feature_voting(pS+startx+j-1+(k-1)*(IMG_LWORD)ulXLinestep2, ulXLinestep2, pwD, pwbLevel[ulAngle].linestep, (IMG_WORD)rWeight, &szOPV, 
										pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle], pSource[lwColorChannelIndex*NUM_OF_DIRECTION+(size_t)wLocalAngle]+(size_t)szLevel[1].height*ulXLinestep2+1, 
										pwbLevel[ulAngle].ptr, pwbLevel[ulAngle].ptr+ (size_t)pwbLevel[ulAngle].size.height*(IMG_UINT)pwbLevel[ulAngle].linestep);
								rWeight = (bWeight*lwScaleFactor*(1-a)*b+0.5f);
								if(rWeight > 1 && (1-a)*b > 0.04f)
									feature_voting(pS+startx+j-0+(k-1)*(IMG_LWORD)ulXLinestep2, ulXLinestep2, pwD, pwbLevel[ulAngle].linestep, (IMG_WORD)rWeight, &szOPV, 
										pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle], pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(size_t)szLevel[1].height*ulXLinestep2+1, 
										pwbLevel[ulAngle].ptr, pwbLevel[ulAngle].ptr+ (size_t)pwbLevel[ulAngle].size.height*(IMG_UINT)pwbLevel[ulAngle].linestep);
								if(endy+coR.y+k > szLevel[1].height-1)
								{
									szOPV.height--;
								}
								if(endy+coR.y+k >= szLevel[1].height-1)
								{
									if(j == 1) szOPV.width--;
								}
								rWeight = (bWeight*lwScaleFactor*a*(1-b)+0.5f);
								if(rWeight > 1 && a*(1-b) > 0.04f)
									feature_voting(pS+startx+j-1+(k-0)*(IMG_LWORD)ulXLinestep2, ulXLinestep2, pwD, pwbLevel[ulAngle].linestep, (IMG_WORD)rWeight, &szOPV, 
										pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle], pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(size_t)szLevel[1].height*ulXLinestep2+1, 
										pwbLevel[ulAngle].ptr, pwbLevel[ulAngle].ptr+ (size_t)pwbLevel[ulAngle].size.height*(IMG_UINT)pwbLevel[ulAngle].linestep);
								rWeight = (bWeight*lwScaleFactor*(1-a)*(1-b)+0.5f);
								if(rWeight > 1 && (1-a)*(1-b) > 0.04f)
									feature_voting(pS+startx+j-0+(k-0)*(IMG_LWORD)ulXLinestep2, ulXLinestep2, pwD, pwbLevel[ulAngle].linestep, (IMG_WORD)rWeight, &szOPV,
										pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle], pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(size_t)szLevel[1].height*ulXLinestep2+1, 
										pwbLevel[ulAngle].ptr, pwbLevel[ulAngle].ptr+ (size_t)pwbLevel[ulAngle].size.height*(IMG_UINT)pwbLevel[ulAngle].linestep);

							}
							if(g_ptdebug && output_1.x < (endx*ulAbsoluteScale) && output_1.x > (startx*ulAbsoluteScale)  && 
								output_1.y < (endy*ulAbsoluteScale)  && output_1.y > (starty*ulAbsoluteScale) )
							{
								IMG_REAL startangle, endangle;
								IMG_ULWORD val, valS;
								startangle = rStartAngle+(rEndAngle-rStartAngle)*
									(IMG_REAL)ulAngle/(ulNumOfRot);
								endangle = rStartAngle+(rEndAngle-rStartAngle)*
									(ulAngle+1.0f)/(ulNumOfRot);
								if(endangle > output_1.angle && startangle < output_1.angle)
								{
									x = (IMG_ULWORD)((output_1.x>>(ulReductionLevel+1))+0.5);
									y = (IMG_ULWORD)((output_1.y>>(ulReductionLevel+1))+0.5);
									valS = *(pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(x+coR.x)+(y+coR.y)*ulXLinestep2);
									val = (pwbLevel[ulAngle].ptr[x+y*pwbLevel[ulAngle].linestep]);
									if(ulFeat == 0)
									{
										HL_Printf(m_pHtmlLog,  "Srch Angle = %.2f-%.2f, at %.2f\n", startangle, endangle, rAngle*180/PI);
									}
									if(valS > 0)
									{
										HL_Printf(m_pHtmlLog,  "No.% 3d: [% 3d % 3d ][% 3d % 4d ],  hit Level1 % 3d, Score = % 3d(w % 3d /d % 3d , SrchAng %.2f /Index % 3d)\n", 
											ulFeat, x+coR.x, y+coR.y, x+coR.x, wLocalAngle*szLevel[1].height+y+coR.y, pstVote[ulFeat].rWeighting*lwScaleFactor, val, pstVote[ulFeat].rWeighting, ALIGN_NORMAL_DIR_NCOLOR(pstVote[ulFeat].angle), rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle*256/360), wLocalAngle);
									}
									else
									{
										HL_Printf(m_pHtmlLog,  "No.% 3d: [% 3d % 3d ][% 3d % 4d ], miss Level1   0, Score = % 3d(w % 3d /d % 3d , SrchAng %.2f /Index % 3d)\n", 
											ulFeat, x+coR.x, y+coR.y, x+coR.x, wLocalAngle*szLevel[1].height+y+coR.y, val, pstVote[ulFeat].rWeighting*lwScaleFactor, ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle), rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle)*256/360, wLocalAngle);
									}

								}
							}
							else
							{
								//HL_Printf(m_pHtmlLog,  "out of range, [x By r] = [%.2f %.2f %.2f]\n", output_1.x, output_1.y, output_1.angle);
							}
						}
					}
					coUL.x = 0, coUL.y = 0, coBR.x = szOP.width, coBR.y = szOP.height;
					{
						//j = ulNumPos;
						wLocalMax = 0;
						pcoULVote[ulAngle].x = coUL.x;
						pcoULVote[ulAngle].y = coUL.y;
						pszOpVote[ulAngle].width = szOP.width-1;
						pszOpVote[ulAngle].height = szOP.height-1;
						//state = VIS_Local_Max_w(pwbLevel+ulAngle, &coUL, szLevel+1, ((rAcceptLevel)*MAX_SCORE*lwScaleFactor*0.5), 3, pcoMaxPos, (IMG_ULWORD *)&j);
						//if(state != OK) goto end;
						state = ALIGN_FindMax_w(pwbLevel+ulAngle, &coUL, &szOP, &coMaxPosLocal, &wLocalMax);
						if(state != OK) goto end;
						if(lwMax < wLocalMax)
						{
							lwMax = wLocalMax;
							coMaxPos = coMaxPosLocal;
						}
						if(lwMax < ((rAcceptLevel)*MAX_SCORE*lwScaleFactor*0.5))
							pubMaskflag[ulAngle] = IMG_FALSE;
						else				
							pubMaskflag[ulAngle] = IMG_TRUE;
					}
				//
				}
				//}}}
				else
				//{{{
				{
					//
					coUL.x = szLevel[0].width, coUL.y = szLevel[0].height, coBR.x = 0, coBR.y = 0;


					for(ulFeat = 0; ulFeat<ulFeatNum; ulFeat++)
					{
						cose = (IMG_REAL)cos(rAngle), sine = (IMG_REAL)sin(rAngle);
						rco.x = ((cose*pstVote[ulFeat].rco.x - sine*pstVote[ulFeat].rco.y)*rScaleX);
						rco.y = ((sine*pstVote[ulFeat].rco.x + cose*pstVote[ulFeat].rco.y)*rScaleY);
						/*lint -e571*/
						if(InputType == ALIGN_POINT)
							wLocalAngle = (IMG_WORD)(ALIGN_NORMAL_DIR_NCOLOR( (IMG_LREAL)pstVote[ulFeat].angle)*256/360+0.5);
						else
							wLocalAngle = (IMG_WORD)(rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( (IMG_LREAL)pstVote[ulFeat].angle)*256/360+0.5);
						//if((pstVote[ulFeat].ubVoteHalfAngle & 0x80) && (pstSrchOpt ->wAdvLrnOpt & 1)) //feature phase inv
						//{
						//	wLocalAngle = (IMG_WORD)(((wLocalAngle+(256>>(8-ulAngleShift+1))) & 0x7f) >> ulAngleShift);
						//}
						//else
						wLocalAngle = (IMG_WORD)(((wLocalAngle+(256>>(8-ulAngleShift+1))) & ulAngleMask) >> ulAngleShift);
						SYS_Assert(wLocalAngle < (IMG_WORD)NUM_OF_DIRECTION);
						coR.x = ((floor((IMG_LREAL)rco.x+65536+0.5))/(ulAbsoluteScale))-(65536/((IMG_WORD)ulAbsoluteScale));
						coR.y = ((floor((IMG_LREAL)rco.y+65536+0.5))/(ulAbsoluteScale))-(65536/((IMG_WORD)ulAbsoluteScale));

						//if(coR.x < 0)						startx = -coR.x > (lwMinX>>1) ? -coR.x : (lwMinX>>1);
						//else								startx = (lwMinX>>1);
						//if(coR.y < 0)						starty = -coR.y > (lwMinY>>1) ? -coR.y : (lwMinY>>1);
						//else								starty = (lwMinY>>1);
						//if(coR.x >= (pszOpsize->width-lwMaxX)>>1)	endx = ((pszOpsize->width-1)>>1)-coR.x;
						//else								endx = lwMaxX>>1;
						//if(coR.y >= (pszOpsize->height-lwMaxY)>>1)	endy = ((pszOpsize->height-1)>>1)-coR.y;
						//else								endy = lwMaxY>>1;
						if(-coR.x>(lwMinX>>1))					startx = -coR.x;
						else									startx = (lwMinX>>1);
						if(-coR.y>(lwMinY>>1))					starty = -coR.y;
						else									starty = (lwMinY>>1);
						if(coR.x>((pszOpsize->width>>1)-(lwMaxX>>1))-1)	endx   = (pszOpsize->width>>1)-coR.x-1;
						else									endx   = (lwMaxX>>1);
						if(coR.y>((pszOpsize->height>>1)-(lwMaxY>>1))-1)	endy   = (pszOpsize->height>>1)-coR.y-1;
						else									endy   = (lwMaxY>>1);

						if(ALIGN_IS_NCOLOR_NORMAL((IMG_WORD)pstVote[ulFeat].angle) && pstSrchOpt->ubColorMatchOpt != ALIGN_NCOLOR_DIR_MATCH_SEARCHMAX)
							lwColorChannelIndex = ALIGN_INDEX_NCOLOR((IMG_WORD)pstVote[ulFeat].angle)+1;
						else 
							lwColorChannelIndex = 0;

						pS = pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+((IMG_ULWORD)starty+coR.y)*(ulXLinestep2)+startx+coR.x;
						pubSrcStart = pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle];
						pubSrcEnd = pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(size_t)szLevel[1].height*ulXLinestep2;
						//pwD = pwbLevel[ulAngle].ptr+ulXLinestep2*(IMG_ULWORD)starty;
						pwD = pwbLevel[ulAngle].ptr+(size_t)pwbLevel[ulAngle].linestep*(starty-(lwMinY>>1))+startx-(lwMinX>>1);
						pwDstStart = pwbLevel[ulAngle].ptr, pwDstEnd = pwbLevel[ulAngle].ptr+ (size_t)pwbLevel[ulAngle].size.height*(IMG_UINT)pwbLevel[ulAngle].linestep;
						bWeight = (IMG_BYTE)(pstVote[ulFeat].rWeighting+0.5);
						if(bWeight < 0) continue; //only vote positive feature
						rco.x /= ulAbsoluteScale, rco.y /=ulAbsoluteScale;
						if(rco.x > coR.x)	{	j = 1;	a = coR.x+1-rco.x;	}
						else				{	j = 0;	a = coR.x-rco.x;	}
						if(rco.y > coR.y)	{	k = 1;	b = coR.y+1-rco.y;	}
						else				{	k = 0;	b = coR.y-rco.y;	}
						for(y = starty-(lwMinY>>1); y<=endy-(lwMinY>>1); y++)
						{
							plw = plwbufLevel[n].ptr+(y+(lwMinY>>1))*(size_t)plwbufLevel[n].linestep;
							while(plw[0])
							{
								xs = ((plw[0]))-1 > startx ? ((plw[0]))-1-startx : 0;
								xe = ((plw[1]))+1 < endx ? ((plw[1]))+1-startx : endx-startx;
								//xs -= (lwMinX>>1), xe -= (lwMinX>>1);
								SYS_Assert(xe < szOP.width-startx+(lwMinX>>1));
								if( (IMG_LWORD)ulReductionLevel>0)
								{									
									for(x = xs; x<=xe; x++)
									{
										pwD[x] += (IMG_WORD)((pS[x])>0 ? bWeight*lwScaleFactor : 0);
										SYS_Assert(pwD+x >= pwDstStart);
										SYS_Assert(pwD+x <= pwDstEnd);
										SYS_Assert(pS+x >= pubSrcStart);
										SYS_Assert(pS+x <= pubSrcEnd);
									}
								}
								else
								{
									if(y+(lwMinY>>1)+coR.y-(1-k) < 0 ||y+(lwMinY>>1)+coR.y+1 >= szLevel[1].height) 
									{	
										plw+=2;
										continue;
									}
									if(xs+startx+coR.x+j-1<0) 
										xs = -(startx+coR.x+j-1);
									if(xe+startx+coR.x+j>=szLevel[1].width) 
										xe = szLevel[1].width-1-j-coR.x-startx;
									SYS_Assert(xe < szOP.width-startx+(lwMinX>>1));
									pS -= (1-k)*ulXLinestep2;
									rWeight = (bWeight*lwScaleFactor*a*b+0.5f);
									if(rWeight > 1 && a*b > 0.04)
									{
										for(x = xs; x<=xe; x++)
										{
											pwD[x] += pS[x+j-1] > 0 ? (IMG_WORD) rWeight: 0;
											SYS_Assert(pS+x+j-1 >= pubSrcStart);
											SYS_Assert(pwD+x >= pwDstStart);
										}
									}
									rWeight = (bWeight*lwScaleFactor*(1-a)*b+0.5f);
									if(rWeight > 1 && (1-a)*b > 0.04f)
									{
										for(x = xs; x<=xe; x++)
										{
											pwD[x] += pS[x+j-0] > 0 ? (IMG_WORD) rWeight: 0;
											SYS_Assert(pS+x+j-1 >= pubSrcStart);
											SYS_Assert(pwD+x >= pwDstStart);
										}
									}
									rWeight = (bWeight*lwScaleFactor*a*(1-b)+0.5f);
									if(rWeight > 1 && a*(1-b) > 0.04f)
									{
										for(x = xs; x<=xe; x++)
										{
											pwD[x] += pS[x+j-1+ulXLinestep2] > 0 ? (IMG_WORD) rWeight: 0;
											SYS_Assert(pS+x+j-0+ulXLinestep2 <= pubSrcEnd+1);
											SYS_Assert(pwD+x <= pwDstEnd);
										}
									}
									rWeight = (bWeight*lwScaleFactor*(1-a)*(1-b)+0.5f);
									if(rWeight > 1 && (1-a)*(1-b) > 0.04f)
									{
										for(x = xs; x<=xe; x++)
										{
											pwD[x] += pS[x+j-0+ulXLinestep2] > 0 ? (IMG_WORD) rWeight : 0;
											SYS_Assert(pS+x+j-0+ulXLinestep2 <= pubSrcEnd+1);
											SYS_Assert(pwD+x <= pwDstEnd);
										}
									}
									pS += (1-k)*ulXLinestep2;
								}
								plw+=2;
								if(xs+startx-(lwMinX>>1)< coUL.x)coUL.x = (xs+startx-(lwMinX>>1));
								if(xe+startx-(lwMinX>>1)> coBR.x)coBR.x = (xe+startx-(lwMinX>>1));
								if(y < coUL.y)coUL.y = y;
								if(y > coBR.y)coBR.y = y;
							}
							pS += ulXLinestep2;
							pwD += pwbLevel[ulAngle].linestep;
						}
						if(g_ptdebug && output_1.x < (endx*ulAbsoluteScale) && output_1.x > (startx*ulAbsoluteScale)  
							&& output_1.y < (endy*ulAbsoluteScale)  && output_1.y > (starty*ulAbsoluteScale) )
						{
							IMG_REAL startangle, endangle;
							IMG_ULWORD val, valS;
							startangle = rStartAngle+(rEndAngle-rStartAngle)*
								(IMG_REAL)ulAngle/(ulNumOfRot);
							endangle = rStartAngle+(rEndAngle-rStartAngle)*
								(ulAngle+1.0f)/(ulNumOfRot);
							if(endangle > output_1.angle && startangle < output_1.angle)
							{
								x = (IMG_ULWORD)((output_1.x>>(ulReductionLevel+1))+0.5);
								y = (IMG_ULWORD)((output_1.y>>(ulReductionLevel+1))+0.5);
								valS = *(pSource[lwColorChannelIndex*NUM_OF_DIRECTION+wLocalAngle]+(x+coR.x)+(y+coR.y)*ulXLinestep2);
								val = (pwbLevel[ulAngle].ptr[x+y*(size_t)pwbLevel[ulAngle].linestep]);
								if(ulFeat == 0)
								{
									HL_Printf(m_pHtmlLog,  "Srch Angle = %.2f-%.2f, at %.2f\n", startangle, endangle, rAngle*180/PI);
								}
								if(valS > 0)
								{
									HL_Printf(m_pHtmlLog,  "No.% 3d: [% 3d % 3d ][% 3d % 4d ],  hit Level1 % 3d, Score = % 3d(w % 3d /d % 3d , SrchAng %.2f /Index % 3d)\n", 
											ulFeat, x+coR.x, y+coR.y, x+coR.x, wLocalAngle*szLevel[1].height+y+coR.y, pstVote[ulFeat].rWeighting*lwScaleFactor, val, pstVote[ulFeat].rWeighting, ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle), rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle)*256/360, wLocalAngle);
								}
								else
								{
									HL_Printf(m_pHtmlLog,  "No.% 3d: [% 3d % 3d ][% 3d % 4d ], miss Level1   0, Score = % 3d(w % 3d /d % 3d , SrchAng %.2f /Index % 3d)\n", 
											ulFeat, x+coR.x, y+coR.y, x+coR.x, wLocalAngle*szLevel[1].height+y+coR.y, val, pstVote[ulFeat].rWeighting*lwScaleFactor, ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle), rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( pstVote[ulFeat].angle)*256/360, wLocalAngle);
								}

							}
						}
						else
						{
							//HL_Printf(m_pHtmlLog,  "out of range, [x y r] = [%.2f %.2f %.2f]\n", output_1.x, output_1.y, output_1.angle);
						}
					}
					//find max value
					if(coUL.x-3 >= 0)coUL.x -=3;
					else coUL.x = 0;
					if(coUL.y-3 >= 0)coUL.y -=3;
					else coUL.y = 0;
					if(coBR.x+3 < pwbLevel[ulAngle].size.width)coBR.x += 3;
					else	coBR.x = pwbLevel[ulAngle].size.width-1;
					if(coBR.y+3 < pwbLevel[ulAngle].size.height)coBR.y += 3;
					else	coBR.y = pwbLevel[ulAngle].size.height-1;
					if(coBR.x > coUL.x && coBR.y > coUL.y)
					{
						IMG_SIZE szOPMax;
						wLocalMax = 0;
						szOPMax.width = (coBR.x-coUL.x+1);
						szOPMax.height = (coBR.y-coUL.y+1);

						pcoULVote[ulAngle].x = coUL.x;
						pcoULVote[ulAngle].y = coUL.y;
						pszOpVote[ulAngle].width = szOPMax.width > szLevel[1].width-1 ? szLevel[1].width-1:szOPMax.width;
						pszOpVote[ulAngle].height = szOPMax.height > szLevel[1].height-1 ? szLevel[1].height-1:szOPMax.height;

						//j = ulNumPos;
						//state = VIS_Local_Max_w(pwbLevel+ulAngle, &coUL, &szOPMax, (IMG_WORD)((rAcceptLevel)*MAX_SCORE*lwScaleFactor*0.5), 3, pcoMaxPos, (IMG_ULWORD *)&j);
						//if(state != OK) goto end;
						state = ALIGN_FindMax_w(pwbLevel+ulAngle, &coUL, &szOPMax, &coMaxPosLocal, &wLocalMax);
						if(state != OK) goto end;
						if(lwMax < wLocalMax)
						{
							lwMax = wLocalMax;
							coMaxPos = coMaxPosLocal;
						}
						if(lwMax < (IMG_WORD)((IMG_LREAL)(rAcceptLevel)*MAX_SCORE*lwScaleFactor*0.5))
							pubMaskflag[ulAngle] = IMG_FALSE;
						else				
							pubMaskflag[ulAngle] = IMG_TRUE;
					}
					else
					{
						pubMaskflag[ulAngle] = IMG_FALSE;
						pcoULVote[ulAngle].x = pcoULVote[ulAngle].y = 0;
						pszOpVote[ulAngle].width = pszOpVote[ulAngle].height = 0;
					}
				}
				if(uwDebug & 2048)
					HL_Printf(m_pHtmlLog,  "%02d Max voting score: %hd\n", ulAngle, wLocalMax);
				wLocalMax = 0;
				//}}}
			}
			if(plwbufLevel)
			{
				for(i = 0; i<(IMG_LWORD)ulNumOfRot2; i++)
					if(plwbufLevel[i].ptr)CVisMemPool::PFree(plwbufLevel[i].ptr);
				CVisMemPool::PFree(plwbufLevel);
			}
			if (uwDebug & 256) g_pstClock->Click("after_submask_voting");

			check_heap(__FILE__, __LINE__);
#ifdef _OUTPUT_LOG
			for(i = 0; i<ulNumOfRot; i++)
			{
				if(pubMaskflag[i] )
				{
					sprintf(buf, "lum *1 b=16 w=%%d h=%%d t='vote level %d, %d of %d' %%p", ulReductionLevel+1, i, ulNumOfRot);
					imdebug(buf, pwbLevel[i].linestep, pwbLevel[i].size.height, pwbLevel[i].ptr);
				}
			}
#endif
			lwThrd = (IMG_LWORD)((IMG_LREAL)(rAcceptLevel)*MAX_SCORE*lwScaleFactor/(1.0f+ulReductionLevel/10.0f)+0.5);
			for(i = 0, j=IMG_FALSE; i<(IMG_LWORD)ulNumOfRot; i++)
			{
				if(pubMaskflag[i] ) j = IMG_TRUE;
			}
			if(!j)	//none of voting space have candidates
			{
				if(lwMax > 0.2*lwThrd)	//at least have some information
				{
					for(i = 0; i<(IMG_LWORD)ulNumOfRot; i++)
					{
						if((size_t)pszOpVote[i].width*pszOpsize[i].height > 0 && pwbLevel[i].ptr != NULL)
						{
							wLocalMax = 0;
							state = ALIGN_FindMax_w(pwbLevel+i, pcoULVote+i, pszOpVote+i, &coMaxPosLocal, &wLocalMax);
							if(state != OK) goto end;
							if(wLocalMax > 0.2*lwThrd)	pubMaskflag[i] = IMG_TRUE;
						}
					}
				}
			}
			if(uwMultipleObj == SRCH_MO_HIGHEST || (uwMultipleObj == ALIGN_SRCH_MULTIOBJ_NEAREST && pstSrchOpt->uwCompleteObj)) //highest score
			{
				if(lwMax*rRatio > lwThrd)
				{
					lwThrd = (IMG_LWORD)(lwMax*rRatio+0.5f);
				}
				else if(lwMax < lwThrd)
				{
					lwThrd = (IMG_LWORD)(lwMax*0.95f+0.5f);
				}
			}
			else
			{
				if(lwMax*.9f<(IMG_LWORD)lwThrd)					
					lwThrd = (IMG_LWORD)(lwMax*.9f);
			}
			for(i = 0; i<(IMG_LWORD)ulNumOfRot; i++)
			{
				coDst.x = (pcoULVote[i].x+(lwMinX>>1))*2;
				coDst.y = (pcoULVote[i].y+(lwMinY>>1))*2;
				szDst.width = pszOpVote[i].width*2;
				szDst.height = pszOpVote[i].height*2;
				if(coDst.x+(IMG_LWORD)szDst.width > (IMG_LWORD)szLevel[0].width) szDst.width = szLevel[0].width-coDst.x;
				if(coDst.y+(IMG_LWORD)szDst.height > (IMG_LWORD)szLevel[0].height) szDst.height = szLevel[0].height-coDst.y;
				if(pubMaskflag[i] )
				{
					//state = DSP_RTS_Bilinear_SSE_w(pwbLevel+i, &rcoZero, 2.0f, 2.0f, 0, &wbLevel2X, &rcoZero, &coZ, szLevel);
					memset(ubbufMask.ptr, 0, (size_t)ubbufMask.size.width*(size_t)ubbufMask.size.height);
					if(state != OK) goto end;					
					state = ALIGN_Scale2X_w(pwbLevel+i, pcoULVote+i, &wbLevel2X, &coDst, pszOpVote+i);
					if(state != OK) goto end;
					state = ALIGN_Compare_SSE_wub(&wbLevel2X, &coDst, &ubbufMask, &coDst, (IMG_WORD)lwThrd, 1, 2 , &szDst);
					//check_heap(__FILE__, __LINE__);
					if(state != OK) goto end;
#ifdef _OUTPUT_LOG
					if(pubMaskflag[i])
					{
						sprintf(buf, "lum *255 b=8 w=%%d h=%%d t='After thrd level %d %d of %d' %%p", ulReductionLevel+1, i, ulNumOfRot); 
						imdebug(buf, ubbufMask.linestep, ubbufMask.size.height, ubbufMask.ptr);
					}
					HL_Printf(m_pHtmlLog,  "Level1 Thred %d, lwMax %d, [%d %d]\n", lwThrd, lwMax, coMaxPos.x, coMaxPos.y);
					output_1.errorX += sqrt((output_1.rX-coMaxPos.x*ulAbsoluteScale)*(output_1.rX-coMaxPos.x*ulAbsoluteScale));
					output_1.errorY += sqrt((output_1.rY-coMaxPos.y*ulAbsoluteScale)*(output_1.rY-coMaxPos.y*ulAbsoluteScale));

#endif
					//
					//output mask buffer, RLE encoded
					//
					//pD = pD+ulNumOfRot*sizeof(IMG_LWBUF);
					//for(i = 0; i<(IMG_LWORD)ulNumOfRot; i++)
					//if(pubMaskflag[i])
					if(ulReductionLevel>1 && InputType != ALIGN_2DCode)
					{
						size_t lwSizemask;
						state = VIS_RLEEncoding(&ubbufMask, &coZ, szLevel, &lwbufDest);
						if(state != OK)	goto end;
						for(j = 0, lwSizemask = 0; j<lwbufDest.size.height; j++)
						{
							plw = lwbufDest.ptr+j*(size_t)lwbufDest.linestep;
							while(plw[0])
							{
								lwSizemask+=plw[1]-plw[0]+1;
								plw+=2;
							}
						}
						if(25*lwSizemask < (size_t)szLevel[0].width*szLevel[0].height)
						{
							state = VIS_RLEDilate(&lwbufDest, szLevel, &lwbufKernel, &szKernel, &lwbufEncoding);
							if(state != OK)	goto end;
						}
						else
						{
							for(j = 0, lwSizemask = 0; j<lwbufDest.size.height; j++)
							{
								plw = lwbufDest.ptr+j*(size_t)lwbufDest.linestep;
								plw2 = lwbufEncoding.ptr+j*(size_t)lwbufEncoding.linestep;
								plw2[0] = 0;
								while(plw[0])
								{
									plw2[0] = plw[0];
									plw2[1] = plw[1];
									plw+=2;
									plw2+=2;
								}
								plw2[0] = 0;
							}
							//memcpy(lwbufEncoding.ptr, lwbufDest.ptr, sizeof(IMG_LWORD)*lwbufDest.size.width*lwbufDest.linestep);
						}
					}
					else
					{
						state = VIS_RLEEncoding(&ubbufMask, &coZ, szLevel, &lwbufEncoding);
						if(state != OK)	goto end;
					}
					merge_line_block(&lwbufEncoding,  9);

					for(j = 0, x = 0, plw = lwbufEncoding.ptr; j<lwbufEncoding.size.height; j++)
					{
						for(k = 0; k<lwbufEncoding.size.width; k++)
						{
							if(plw[k] == 0)
							{
								if(x < k) x = k;
								break;
							}
						}
						plw += lwbufEncoding.linestep;
					}
					plwbufMask[i].size.width = (x +1);
					plwbufMask[i].size.height = (szLevel[0].height);
					plwbufMask[i].linestep = (x +1);
					plwbufMask[i].ptr = (IMG_LWORD *)CVisMemPool::PMalloc((x+1)*(size_t)szLevel[0].height*sizeof(IMG_LWORD));
					VALIDATE_MALLOC(plwbufMask[i].ptr);

					for(j = 0; j<lwbufEncoding.size.height; j++)
					{
						memcpy(plwbufMask[i].ptr+j*(size_t)plwbufMask[i].linestep, lwbufEncoding.ptr+j*(size_t)lwbufEncoding.linestep, (x+1)*sizeof(IMG_LWORD));
					}

#ifdef _OUTPUT_LOG
				//for(i = 0; i<ulNumOfRot; i++)
					if(pubMaskflag[i])
					{
						sprintf(buf, "lum *256 b=8 w=%%d h=%%d t='Mask buffer %d %d of %d' %%p", ulReductionLevel+1, i, ulNumOfRot);
						imdebug(buf, ubbufMask.linestep, ubbufMask.size.height, ubbufMask.ptr);
					}
#endif
				}
				else
				{
					plwbufMask[i].size.width = 1;
					plwbufMask[i].size.height = szLevel[0].height;
					plwbufMask[i].linestep = 1;
					plwbufMask[i].ptr = (IMG_LWORD *)CVisMemPool::PMalloc(szLevel[0].height*sizeof(IMG_LWORD));
					VALIDATE_MALLOC(plwbufMask[i].ptr);

					memset(plwbufMask[i].ptr, 0, szLevel[0].height*sizeof(IMG_LWORD));
				}
				*pplwbufMask = plwbufMask;
			}
			if(uwDebug & 2048) HL_Printf(m_pHtmlLog,  (char*)"Mask generate threshold/max %d/%d at reduction %d\n", lwThrd, lwMax, ulReductionLevel+1);

			if(uwDebug & 2048)
			{
				n = (IMG_LWORD)ceil(sqrt((IMG_LREAL)ulNumOfRot));
				szImg.width = (szLevel[1].width*n);
				szImg.height = (szLevel[1].height*n);
				MEM_AllocBufAtBank(&szImg, (IMG_VVBUF *)&ubbImage, sizeof(IMG_UBYTE));
				if(ubbImage.ptr == nullptr)	goto end;
				memset(ubbImage.ptr, 64, (size_t)ubbImage.size.height*(IMG_UINT)ubbImage.linestep);
				for(i = 0, j =  -1, k = 100000; i<(IMG_LWORD)ulNumOfRot; i++)
				{
					if(pubMaskflag[i] )
					{
						state = ALIGN_FindMax_w(pwbLevel+i, &coZ, &pwbLevel[i].size, &coR, &wMaxValue);
						if(j<wMaxValue)j=wMaxValue;
						//if(state != OK)	goto end;
						state = ALIGN_FindMin_w(pwbLevel+i, &coZ, &pwbLevel[i].size, &coR, &wMinValue);
						if(k>wMinValue)k=wMinValue;
						//if(state != OK)	goto end;
					}
				}
				if(k<j)
					wMinValue = (IMG_WORD)k, wMaxValue = (IMG_WORD)j;
				else
					wMinValue = 0, wMaxValue = 1000;
				for(o = 0, k = 0; o<n; o++)
				{
					for(m = 0; m<n&&k<(IMG_LWORD)ulNumOfRot; m++, k++)
					{
						pwD = pwbLevel[k].ptr;
						pD = ubbImage.ptr+o*szLevel[1].width+(lwMinX>>1)+(m*szLevel[1].height+(lwMinY>>1))*(size_t)ubbImage.linestep;
						for(i = 0; i<pwbLevel[k].size.height; i++)
						{
							if(pubMaskflag[k])
							{
								for(j = 0; j<pwbLevel[k].size.width; j++)
								{
									SYS_Assert(pwD[j] <= wMaxValue);
									SYS_Assert(pwD[j] >= wMinValue);
									pD[j] = (IMG_UBYTE)((pwD[j]-wMinValue)*255/(IMG_LWORD)(wMaxValue-wMinValue+1));
								}
							}
							else
							{
								for(j = 0; j<pwbLevel[k].size.width; j++) pD[j] = 0;
							}
							pD[0] = pD[pwbLevel[k].size.width-1] = 0x7f;
							pD += ubbImage.linestep;
							pwD += pwbLevel[k].linestep;
						}
					}
				}
				for(i = 0; i<szImg.height; i+=szLevel[1].height)
					memset(ubbImage.ptr+i*(size_t)ubbImage.linestep, 0x7f, ubbImage.size.width);

				//create_filename(pathname,(IMG_UBYTE*)"gsh",wAlignFileIndex,(IMG_UBYTE*)".hs");
				//_snprintf((IMG_CHAR *)pathname, sizeof(pathname), "%s%u%lu.bmp", (IMG_CHAR *)pathname, uwScaleLoopIndex, ulReductionLevel+1);
				//FILE_SaveImage(&ubbImage,&coZ,&ubbImage.size,pathname);
				if (uwDebug & 2048)
				{
					IMG_CHAR *p;
					_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uCoarseMaskVoteSrc%02d_%d.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, uwScaleLoopIndex, ulReductionLevel + 1);
					CVisImage img(ubbEdgeSource);
					img.WriteImage(pathname);
					p = strrchr(pathname, '\\') - 10;
					writeLog("GMask Voting result at scale index %d, reduction %d\n", uwScaleLoopIndex, ulReductionLevel + 1);
					HL_InsertImage(m_pHtmlLog, p);
				}
			}
			if (uwDebug & 256) g_pstClock->Click("after_thresholding");
			//check_heap(__FILE__, __LINE__);
		}
		//	
	}
	if (uwDebug & 256) g_pstClock->Click("after_masking");
	check_heap(__FILE__, __LINE__);


end:
	if(state != OK)
	{
		if (uwDebug & 513)
			HL_Printf(m_pHtmlLog, "error status %d returned at file %s, line %d\n", state, __FILE__, __LINE__);
		if(plwbufMask)
		{
			for(i = 0; i<(IMG_LWORD)ulNumOfRot; i++)
			{
				if(plwbufMask[i].ptr)	
				{
					CVisMemPool::PFree(plwbufMask[i].ptr);
					plwbufMask[i].ptr = NULL;
				}
			}
			CVisMemPool::PFree(plwbufMask);
			plwbufMask = NULL;
			*pplwbufMask = NULL;
			*pulMaskNum = 0;
		}
	}
	return state;
}



//
IMG_VVOID split_edge_map(IMG_UWBUF *puwbDist)
//
{
	IMG_LWORD i,j,k;
	IMG_UWORD *puw[4], *puw0, pix;
	for(i = 1; i<4; i++)
	{
		memset(puwbDist[i].ptr, 0xff, sizeof(IMG_UWORD)*(size_t)puwbDist[i].linestep*puwbDist[i].size.height);
	}
	puw0 = puw[0] = puwbDist[0].ptr;
	puw[1] = puwbDist[1].ptr;
	puw[2] = puwbDist[2].ptr;
	puw[3] = puwbDist[3].ptr;
	for(i = 0; i<puwbDist[0].size.height; i++)
	{
		for(j = 0; j<puwbDist[0].size.width; j++)
		{
			pix = puw0[j];
			if((pix&0xff00)==0)
			{
				k = ((pix+32) & 0xff) >> 6;
				puw0[j] = 0xff00;
				puw[k][j] = pix;
			}
		}
		puw0 += puwbDist[0].linestep;
		puw[0] += puwbDist[0].linestep;
		puw[1] += puwbDist[1].linestep;
		puw[2] += puwbDist[2].linestep;
		puw[3] += puwbDist[3].linestep;
	}	
}









IMG_WORD	add_object_to_table(	IMG_COORD *pcoMax, IMG_ULWORD ulPeakNum, IMG_COORD *pcoS, IMG_WBUF *pwbufVote, 
									IMG_UBYTE *pubVoteState, IMG_REAL *prVoteAngle, IMG_REAL rScale, IMG_ULWORD *pulVoteRegion, 
									IMG_ULWORD ulVotingAreaPartitionX, IMG_ULWORD ulVotingAreaPartitionY, ALIGN_SEARCH_OPTION *pstSrchOpt ,
									ALIGN_SRCH_RESULT *psrOptable, IMG_UWORD *puwNextObjID, IMG_ULWORD ulMaxValue)
{
	IMG_LWORD 	j,x,y, lwPeak;
	IMG_ULWORD 	*pulPtr, ulObj;
	IMG_WORD 	wState = OK, *pS;
	IMG_REAL	rY[3], rMin;
	IMG_OBJ		*pstObj; //, stObj;

	ulObj = 0;
	pulPtr = pulVoteRegion;
	if(pubVoteState[1] == IMG_FALSE) goto end;
	for(j = 0; j<(IMG_LWORD)ulPeakNum; j++)
	{
		for(x = 0; x<j; x++)
		{
			if(pcoMax[x].x == pcoMax[j].x && 
					pcoMax[x].y == pcoMax[j].y)
			{
				x = -1; break;
			}
		}
		if(x==-1)
		{
			continue;
		}
		BUF_OFF(pS, pwbufVote+1, pcoMax+j);
		lwPeak = pS[0];
		if(pubVoteState[0])
		{
			x = pcoMax[j].x*(IMG_LWORD)ulVotingAreaPartitionX/pwbufVote[0].size.width;
			y = pcoMax[j].y*(IMG_LWORD)ulVotingAreaPartitionY/pwbufVote[0].size.height;
			if(pulPtr[x+y*(IMG_LWORD)ulVotingAreaPartitionX])
			{
				BUF_OFF(pS, pwbufVote, pcoMax+j);
				if(pS[0] > lwPeak) lwPeak = 0;							
			}
		}
		if(pubVoteState[2])
		{
			x = pcoMax[j].x*(IMG_LWORD)ulVotingAreaPartitionX/pwbufVote[2].size.width;
			y = pcoMax[j].y*(IMG_LWORD)ulVotingAreaPartitionY/pwbufVote[2].size.height;
			if(pulPtr[x+y*(IMG_LWORD)ulVotingAreaPartitionX+2*(IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY])
			{
				BUF_OFF(pS, pwbufVote+2, pcoMax+j);
				if(pS[0] >= lwPeak) lwPeak= 0;								
			}
		}
		if(lwPeak)
		{
			x = pcoMax[j].x*(IMG_LWORD)ulVotingAreaPartitionX/pwbufVote[1].size.width;
			y = pcoMax[j].y*(IMG_LWORD)ulVotingAreaPartitionY/pwbufVote[1].size.height;
			pstObj = psrOptable->ptr+psrOptable->size;
			ALIGN_InitOBJ(pstObj+ulObj);
			pstObj[ulObj].rco.x = (IMG_REAL)(pcoMax[j].x+pcoS->x);
			pstObj[ulObj].rco.y = (IMG_REAL)(pcoMax[j].y+pcoS->y);
			if(pubVoteState[0]==IMG_FALSE || pubVoteState[2]==IMG_FALSE ||
					pulPtr[x+y*(IMG_LWORD)ulVotingAreaPartitionX]== IMG_FALSE ||
					pulPtr[x+y*(IMG_LWORD)ulVotingAreaPartitionX+2*(IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY] == IMG_FALSE)
			{
				pstObj[ulObj].rotation = prVoteAngle[1];
			}
			else
			{
				rY[0] = (IMG_REAL)(pwbufVote[0].ptr[pcoMax[j].x+pcoMax[j].y*(size_t)pwbufVote[0].linestep]);
				rY[1] = (IMG_REAL)(pwbufVote[1].ptr[pcoMax[j].x+pcoMax[j].y*(size_t)pwbufVote[1].linestep]);
				rY[2] = (IMG_REAL)(pwbufVote[2].ptr[pcoMax[j].x+pcoMax[j].y*(size_t)pwbufVote[2].linestep]);
				pstObj[ulObj].rotation = quadratic_interpolation(prVoteAngle, rY);
			}
			pstObj[ulObj].rMSE = prVoteAngle[1];
			pstObj[ulObj].scale = rScale;
			pstObj[ulObj].rVoteScore = (IMG_UWORD)lwPeak;
			while(pstObj[ulObj].rotation > 180)pstObj[ulObj].rotation -= 360;
			while(pstObj[ulObj].rotation <-180)pstObj[ulObj].rotation += 360;
			pstObj[ulObj].uwID = (*puwNextObjID)++;
			if (*puwNextObjID == 65534) *puwNextObjID = 0;
			pstObj[ulObj].rMatched = 100.0f*pstObj[ulObj].rVoteScore /(ulMaxValue+1e-7f);
			pstObj[ulObj].rVoteScore = (IMG_UWORD)(pstObj[ulObj].rVoteScore/((ulMaxValue+1e-7f)/100.0f));
			if(psrOptable->size+ulObj==psrOptable->maxsize-1 || (psrOptable->size+ulObj==pstSrchOpt ->uwFixedNumObj*2 && pstSrchOpt ->uwFixedNumObj > 0))
			{
				if(psrOptable->maxsize < 20000 && psrOptable->mode == 0 && pstSrchOpt ->uwFixedNumObj == 0)
				{
					IMG_VVOID *p;
					p = (IMG_OBJ *)CVisMemPool::PRealloc(psrOptable->ptr, sizeof(IMG_OBJ)*psrOptable->maxsize*2);
					//psrOptable->ptr_ex = (IMG_OBJ_EX *)asm_realloc(psrOptable->ptr_ex, sizeof(IMG_OBJ_EX)*psrOptable->maxsize*2);
					if(p != NULL)// && psrOptable->ptr_ex != NULL)
					{
						psrOptable->maxsize *= 2;
						psrOptable->ptr = (IMG_OBJ *)p;
					}
					else
					{
						wState = MEM_ERR_MALLOC;
						goto end;
					}
					ulObj++;
				}
				else
				{
					rMin = pstObj[ulObj].rMatched;
					for(x = 0, y = -1; x<(IMG_LWORD)(psrOptable->size+ulObj-1); x++)
					{
						if(psrOptable->ptr[x].rMatched < rMin)
						{
							rMin = psrOptable->ptr[x].rMatched;
							y = x;
						}
					}
					if(y!=-1)
					{
						pstObj[ulObj].uwID = psrOptable->ptr[y].uwID;
						ALIGN_SwapBuffer(pstObj+ulObj, psrOptable->ptr+y,sizeof(IMG_OBJ));
						//pstObj[ulObj].uwID = pstObj[y].uwID;
						//memcpy(&stObj, pstObj+y, sizeof(IMG_OBJ));
						//memcpy(pstObj+y, pstObj+ulObj, sizeof(IMG_OBJ));
						//memcpy(pstObj+ulObj, &stObj, sizeof(IMG_OBJ));
					}
				}
			}
			else
			{
				ulObj++;
			}
		}
	}
	check_heap(__FILE__, __LINE__);
	psrOptable->size += (IMG_UWORD)ulObj;
end:
	return wState;
}


//

/**
 * @ingroup ALIGN_SRCH
 * @brief <B>Destription:</B><br>This function do exhausive coarse search, flowchat as follow
 * @image html ALIGN_Search_exhausive_search.jpg "Exhausive Search Flowchart"
 * @image latex ALIGN_Search_exhausive_search.eps "Exhausive Search Flowchart" width=15cm
 * @param[in] pubbEpbuf Input edge buffer
 * @param[in] pwbDir Input edge direction buffer 
 * @param[in] pstEptable Learned feature Lookup table
 * @param[out] psrOptable Coarse search result
 * @param[in] pstSrchOpt  Search argument (numeric)
 * @param[in] pstSrchOpt Search option, (on/off)
 * @param[in] puwNextObjID Next Object ID, used in case of being called many times, in order to give searched object individual ID\n
 * @brief others Not related to this function
 * @return OK for ok
 * @return other for MEMORY or PARAMETER error.
 * @section Description
 * 		Related variable in \b pstSrchOpt \n
 *
 *		\b uwDebug debug value\n
 *			-256 for time logging, \n
 *			-4 for detailed log, \n
 *			-1 for normal log\n
 *		
 *		\b ubCoarseSrchOpt, coarse search option\n
 *			-ALIGN_SRCH_EXHAUSTIVE_COARSE_SRCH for normal exhausive search, \n
 *			-ALIGN_SRCH_EXHAUSTIVE_4DIR_COARSE_SRCH for search edge buffer split for 4 direction,
 *			not known by others, maybe slow, maybe hit fake object\n
 *		
 *		\b uwPhaseInv, phase inverse option\n
 *			-0 for normal\n
 *			-1 for phase inverse, treat hit and inversed hit as same effective\n
 *			-2 for normal->inverse, if normal failed, retry phase inverse\n
 *			-3 mirror, all feature reversed or none\n
 *			-4 normal->inverse, if normal failed, retry inversed search\n
 *		\b uwCompleteObj, 0 for incomplete object, 1 for complete object\n
 *		\b uwMultipleObj, 1 for nearest point, 2 for multiple object, 3 for highest score\n
 *		
 *		Related variable in \b pstSrchOpt  \n
 *
 *		\b stAdvPara.ubElasticity, elasticity \n
 *		\b stAdvPara.ubAngleMatchTolerance, relation of search edge angle and learned feature angle \n
 *		\b rAngOff, centroid of vote angle \n
 *		\b rAngRange, half of range of votangle \n
 * 		\b rcoMagFactor, x/y scale ratio of search buffer x and y direction
 * 		\b rCoarseAcceptLevel, acceptance level of candidate
 */
//lint -esym(550, _xmmW, _xmmWeight, wVoteWeight, bufX, prNewAngle, wLocalAngle, coDir, VALID_ANGLE_BIAS)
//lint -esym(529, ulReduction, VALID_ANGLE_BIAS, localmax)

IMG_WORD CVisAlignSearch::coarse_search_kernel(	IMG_UBBUF				*pubbEpbuf,
								//
								IMG_COORD				*pcoSoff,
								IMG_WBUF				*pwbDir,
								IMG_COORD				*pcoDiroff,
								IMG_SIZE				*pszOpsize,
								CVisAlignRecordTable	*pstEptable,
								ALIGN_SRCH_RESULT		*psrOptable,
								ALIGN_SEARCH_OPTION		*pstSrchOpt,
								ALIGN_INPUT_TYPE		InputType,			// 1 = buffer; 2 = BGA
								ALIGN_VOTING_INFORMATION	*pstVotingInfo,
								IMG_REAL				rScale,				 // search for the obj having this scale
								IMG_UWORD				uwScaleLoopIndex,
								IMG_UWORD				*puwNextObjID)
								//
								//
{
	IMG_WORD wState = OK;
	IMG_LWORD i,j,k, n, x,y, nx, ny, lwAngle=0;
	IMG_UWORD uwDebug = pstSrchOpt->uwDebug ;
	ALIGN_SRCH_MULTIOBJ MultiObj;
	IMG_ULWORD ulNumOfRotation, ulAngle, ulFeat, ulObj, ulLocalmaxNum, ulCoarseSearchAcceptValue, ulScale, ulMaxD;
	IMG_ULWORD ulReduction = pstSrchOpt ->ubRedFactor, ulMaxValue, ulPreviousObjNum = psrOptable->size;
	IMG_ULWORD ulMaxCoarSearchCandidate = 20*psrOptable->maxsize+1000, ulVoteFeatNum = pstEptable->uwNumOfVoteFeature;
	IMG_LWORD lwMinX, lwMinY, lwMaxX, lwMaxY, startx, endx, starty, endy;
	IMG_REAL rA, rMaxVectorLength = 0, cose, sine, rAngle, rScaleX, rScaleY, rScaleMax, rElasticity;
	IMG_REAL *prNewAngle, rStartAngle, rEndAngle, rRotationInterval, rMaxValAngle=0, rWeightSum;
	IMG_FEATUREPT *pstVote;
	CVisAlignRecordTable *pstRetTable;
#ifdef _OUTPUT_LOG
	IMG_LWORD localmax = 0;
#endif
	IMG_UBYTE ubKernel[] ={7,5,7,5};// {255,255,255,255};
	IMG_WORD *pD, *pS;
	IMG_ULWORD *pulPeakNum, ulNumMask=0, *pulVotingArea = NULL, ulVotingAreaPartitionX,  ulVotingAreaPartitionY, *pulPtr;
	IMG_WORD wVoteWeight, wLocalAngle, wVal, wMaxVoteVal=0;
	IMG_UWBUF *puwbCombined, *puwbDist;
	IMG_WBUF *pwbufVote, *pwbufCurrentVote=NULL;
	IMG_UBBUF *pubbResult, *pubbInversed;
	IMG_RCOORD *prcoNewCoord, rco, rcoFeatureVector;
	IMG_COORD coZero = {0}, coR, coDir, *pcoLocalMax, *pcoPreviousLocalMax=NULL, coS, *pco, coMax, coMaxVal={0};
	IMG_SIZE szOP;
	IMG_LWBUF *plwbufMask=NULL;
	char *buf=NULL, *bufX=NULL;
	IMG_BYTE *pbFeatureWeight;
	IMG_UBYTE *pubMaskflag = NULL, *pubMaskflagPreviousLevel = NULL, ubColor = pstSrchOpt ->ubNumChannel;
	const IMG_LWORD lwMargin = 4;
	IMG_UBYTE 	ubVoteState[3];
	IMG_REAL	rVoteAngle[3];


	IMG_OBJ *pstObj, *pstFirst;
	IMG_LWORD *plwMask;
	const IMG_ULWORD SEARCH_ANGLE_INTERVAL = 2;	 //search angle interval, if it is 3, means next rotation, the longest feature point changed 3 pixel
	IMG_ULWORD NEAREST_OBJ_DISTANCE;
	IMG_ULWORD VALID_ANGLE_BIAS;

	IMG_WORD wMaxValue, wMinValue;
	IMG_SIZE szImage;
	IMG_UBYTE *pubD;
	IMG_CHAR *pathname=NULL;

	IMG_UBBUF ubbImage[3], ubbImage2;
	IMG_UBYTE *pD1[3];
	char *pub;
	IMG_UWORD  *pS1;
	IMG_ULWORD ulLutSize, *pLut, *pLut1;


	CVisMemPool	mem_pool;
	IMG_UINT	tid = GetCurrentThreadId();

	__m128i *_xmmV, *_xmmW, *_xmmWeight;
	check_heap(__FILE__, __LINE__);
	rElasticity = pstSrchOpt ->rElasticity;
	if(rElasticity < pstEptable->rExpVotingElastic)	
		rElasticity = pstEptable->rExpVotingElastic;
	if(rElasticity > 4) rElasticity = 4;
	NEAREST_OBJ_DISTANCE = (IMG_ULWORD)(5*(3+(IMG_LREAL)rElasticity)+0.5);
	if(pstSrchOpt->uwPhaseInv == 0)
	{
		VALID_ANGLE_BIAS = (pstSrchOpt ->ubAngleMatchTolerance+1+20)*256/360;
	}
	else
	{
		VALID_ANGLE_BIAS = (pstSrchOpt ->ubAngleMatchTolerance)*256/360+1;
	}
	if(InputType == ALIGN_POINT)
		VALID_ANGLE_BIAS = 9;//20130607 poon ho shan//35;
	if (pstSrchOpt->MultiObj == 0)
	{
		if (InputType == ALIGN_POINT)
			MultiObj = SRCH_MO_NEAREST_OVERLAPREJ;
		else
			MultiObj = SRCH_MO_NEAREST;
	}
	else
	{
		MultiObj = pstSrchOpt->MultiObj;
		if(pstSrchOpt->MultiObj == SRCH_MO_NEAREST_OVERLAPREJ)
			MultiObj = SRCH_MO_NEAREST;
	}
	////////////////////////////////////
	//Initialization
	///////////////////////////////////
	//
	if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("coarse_start");

	// Stack reduction 20141201 by vincent
	if((pathname = (IMG_CHAR *)mem_pool.Malloc(FILENAME_MAX_LENGTH*sizeof(IMG_CHAR))) == NULL)
	{
		wState = MEM_ERR_MALLOC;
		goto end;
	}
	if((buf = (char *)mem_pool.Malloc(256*sizeof(char))) == NULL)
	{
		wState = MEM_ERR_MALLOC;
		goto end;
	}
	if((bufX = (char *)mem_pool.Malloc((48+15)*sizeof(char))) == NULL)
	{
		wState = MEM_ERR_MALLOC;
		goto end;
	}

	pstRetTable		= pstEptable;
	pstEptable		= (CVisAlignRecordTable *)mem_pool.Malloc(sizeof(CVisAlignRecordTable)); 
	if(pstEptable == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		wState = MEM_ERR_MALLOC;
		{SYS_Assert(0); goto end;}
	}
	memcpy(pstEptable, pstRetTable, sizeof(CVisAlignRecordTable));
	pstVote			= (IMG_FEATUREPT *)mem_pool.Malloc(sizeof(IMG_FEATUREPT)*ulVoteFeatNum);
	if(pstVote == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		{SYS_Assert(0); goto end;}
	}
	for(i = 0, rcoFeatureVector.x = rcoFeatureVector.y = 0, rWeightSum = 0, rMaxVectorLength = 0; i<ulVoteFeatNum; i++)
	{
		rcoFeatureVector.x += pstEptable->pstVote[i].rco.x*pstEptable->pstVote[i].rWeighting;
		rcoFeatureVector.y += pstEptable->pstVote[i].rco.y*pstEptable->pstVote[i].rWeighting;
		rWeightSum += pstEptable->pstVote[i].rWeighting;
		rA = pstEptable->pstVote[i].rco.x*pstEptable->pstVote[i].rco.x+
			pstEptable->pstVote[i].rco.y*pstEptable->pstVote[i].rco.y;
		if(rMaxVectorLength < rA)	rMaxVectorLength = rA;
	}
	rcoFeatureVector.x /= (rWeightSum+1e-5f);
	rcoFeatureVector.y /= (rWeightSum+1e-5f);
	if(pstVotingInfo!= NULL || ALIGN_HYPOT(rcoFeatureVector.x, rcoFeatureVector.y) < rMaxVectorLength/4)
	{
		rcoFeatureVector.x = rcoFeatureVector.y = 0;
	}
	for(i = 0; i<ulVoteFeatNum; i++)
	{
		pstVote[i] = pstEptable->pstVote[i];
		pstVote[i].rco.x -= rcoFeatureVector.x;
		pstVote[i].rco.y -= rcoFeatureVector.y;
	}
	pstEptable->pstVote = pstVote;

	puwbCombined = (IMG_UWBUF *)mem_pool.Malloc(4*sizeof(IMG_UWBUF));
	if(puwbCombined == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		{SYS_Assert(0); goto end;}
	}

	puwbDist = (IMG_UWBUF *)mem_pool.Malloc(4*sizeof(IMG_UWBUF));
	if(puwbDist == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		{SYS_Assert(0); goto end;}
	}

	pubbResult = (IMG_UBBUF *)mem_pool.Malloc(sizeof(IMG_UBBUF));
	if(pubbResult == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		{SYS_Assert(0); goto end;}
	}

	pubbInversed = (IMG_UBBUF *)mem_pool.Malloc(4*sizeof(IMG_UBBUF));
	if(pubbInversed == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		{SYS_Assert(0); goto end;}
	}

	pbFeatureWeight = (IMG_BYTE *)mem_pool.Malloc(ulVoteFeatNum);
	if(pbFeatureWeight == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		{SYS_Assert(0); goto end;}
	}
	for(i = 0; i<(IMG_LWORD)ulVoteFeatNum; i++)
	{
		pbFeatureWeight[i] = ((IMG_BYTE)(pstVote[i].rWeighting+0.5));
	}

	ulMaxD = NEAREST_OBJ_DISTANCE*NEAREST_OBJ_DISTANCE, ulScale = 0;
	for(i = 0, ulMaxValue = 0; i<(IMG_LWORD)ulVoteFeatNum; i++)
	{
		if(InputType == ALIGN_2DCode)
			ulMaxValue +=(IMG_ULWORD)(pbFeatureWeight[i] > 0 ? (IMG_LWORD)(pbFeatureWeight[i]):0 )*255;
		else
			ulMaxValue += (IMG_ULWORD)(pbFeatureWeight[i] > 0 ? (IMG_LWORD)(pbFeatureWeight[i]):0 )*ulMaxD;
	}
	while((ulMaxValue>>ulScale)>32767) ulScale++;
	while((ulMaxD>>ulScale)>255) ulScale++;
	if(ulMaxCoarSearchCandidate>5000)ulMaxCoarSearchCandidate = 5000;

	if(uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog,  "Start Coarse Search with Template matching\n");
	}

	for(i = 0, ulMaxValue = 0; i<(IMG_LWORD)ulVoteFeatNum; i++)
	{
		if(InputType == ALIGN_2DCode)
			ulMaxValue +=(pbFeatureWeight[i] > 0 ? pbFeatureWeight[i]:0 )*(255>>ulScale);
		else
			ulMaxValue +=(IMG_ULWORD)(pbFeatureWeight[i] > 0 ? (IMG_LWORD)pbFeatureWeight[i]:0)*(ulMaxD>>ulScale);
		if((pbFeatureWeight[i]>0 ? pbFeatureWeight[i]:0)*((IMG_LWORD)ulMaxD>>ulScale) > 32767)
		{
			if(uwDebug & 1)HL_Printf(m_pHtmlLog,  "Error, too large weigth(%d) of feature %d, at %s, line %d\n",pbFeatureWeight[i], i,__FILE__, __LINE__);
			THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
			wState = ALIGN_ERR_HS_NEIGH_SUM;
			goto end;
		}
	}
	if(ulMaxValue > 32767)
	{
		if(uwDebug & 1)HL_Printf(m_pHtmlLog,  "Error, too large summed weigth %d at %s, line %d\n",ulMaxValue, __FILE__, __LINE__);
		THROW_VIS_EXCEPTION(VIS_ERR_INVALID_ARG);
		wState = ALIGN_ERR_HS_NEIGH_SUM;
		goto end;
	}

	ulVotingAreaPartitionX = IMG_MAX((IMG_ULWORD)(pszOpsize->width/30.0+0.5), 1);
	ulVotingAreaPartitionY = IMG_MAX((IMG_ULWORD)(pszOpsize->height/30.0+0.5), 1);

	if(ulVotingAreaPartitionX > 10) ulVotingAreaPartitionX = 10;
	if(ulVotingAreaPartitionY > 10) ulVotingAreaPartitionY = 10;

	//rStartAngle= pstSrchOpt ->rStartAngLarge > pstSrchOpt ->rEndAngLarge ? pstSrchOpt ->rEndAngLarge : pstSrchOpt ->rStartAngLarge ;
	//rEndAngle	 = pstSrchOpt ->rStartAngLarge < pstSrchOpt ->rEndAngLarge ? pstSrchOpt ->rEndAngLarge : pstSrchOpt ->rStartAngLarge ;

	if(pstEptable->ubVoteRotationIndependent)
	{
		rStartAngle = (IMG_REAL)(pstSrchOpt ->rMaxAngle+pstSrchOpt->rMinAngle)/2.0f;
		rEndAngle= (IMG_REAL)(pstSrchOpt->rMaxAngle + pstSrchOpt->rMinAngle) / 2.0f;
	}
	else
	{
		if(pstSrchOpt ->rRepeatingAngle < 10)
		{
			rStartAngle = (IMG_REAL)(pstSrchOpt->rMinAngle);
			rEndAngle= (IMG_REAL)(pstSrchOpt->rMaxAngle);
		}
		else
		{
			rStartAngle = -180;
			rEndAngle = 180;
		}
	}
	rScaleX = rScale*pstSrchOpt ->rcoMagFactor.x; 
	rScaleY = rScale*pstSrchOpt ->rcoMagFactor.y;
	rScaleMax = rScaleX > rScaleY ? rScaleX : rScaleY;

	if(pcoDiroff==NULL) coDir.x = 0, coDir.y = 0;
	else coDir.x = pcoDiroff->x, coDir.y = pcoDiroff->y;
	if(pcoSoff == NULL)coS.x = 0, coS.y = 0;
	else coS.x = pcoSoff->x, coS.y = pcoSoff->y;


	//_xmmV = (__m128i *)Malloc_align(sizeof(__m128i)*3+15);
	_xmmV = (__m128i *)(ALIGN_ROUND_PTR16(bufX));
	_xmmW = _xmmV+1;
	_xmmWeight = _xmmV+2;
	prcoNewCoord = (IMG_RCOORD *)mem_pool.Malloc(ulVoteFeatNum*sizeof(IMG_RCOORD));
	//HL_Printf(m_pHtmlLog,  "prcoNewCoord = 0x%08X\n", (IMG_ULWORD)prcoNewCoord);
	prNewAngle = (IMG_REAL *)mem_pool.Malloc(ulVoteFeatNum*sizeof(IMG_REAL));
	//HL_Printf(m_pHtmlLog,  "prNewAngle = 0x%08X\n", (IMG_ULWORD)prNewAngle);
	if(prcoNewCoord == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		wState = MEM_ERR_MALLOC;
		goto end;
	}
	MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)pubbResult, sizeof(IMG_UBYTE));
	if(pubbResult->ptr == nullptr)	{SYS_Assert(0); goto end;}
	//HL_Printf(m_pHtmlLog,  "ubbResult.ptr = 0x%08X\n", (IMG_ULWORD)ubbResult.ptr);
	MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)pubbInversed, sizeof(IMG_UBYTE));
	if(pubbInversed->ptr == nullptr)	{SYS_Assert(0); goto end;}
	//HL_Printf(m_pHtmlLog,  "ubbInversed.ptr = 0x%08X\n", (IMG_ULWORD)ubbInversed.ptr);
	szOP.width = pszOpsize->width; szOP.height = pszOpsize->height+2;
	MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)&puwbDist[0], sizeof(IMG_UWORD));
	if(puwbDist[0].ptr == nullptr)	{SYS_Assert(0); goto end;}
	if(ubColor == IMG_CHANNEL_COLOR)
	{
		MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)&puwbDist[1], sizeof(IMG_UWORD));
		if(puwbDist[1].ptr == nullptr)	{SYS_Assert(0); goto end;}
		MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)&puwbDist[2], sizeof(IMG_UWORD));
		if(puwbDist[2].ptr == nullptr)	{SYS_Assert(0); goto end;}
		MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)&puwbDist[3], sizeof(IMG_UWORD));
		if(puwbDist[3].ptr == nullptr)	{SYS_Assert(0); goto end;}
		MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)pubbInversed+1, sizeof(IMG_UBYTE));
		if(pubbInversed[1].ptr == nullptr)	{SYS_Assert(0); goto end;}
		MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)pubbInversed+2, sizeof(IMG_UBYTE));
		if(pubbInversed[2].ptr == nullptr)	{SYS_Assert(0); goto end;}
		MEM_AllocBufAtBank_align((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)pubbInversed+3, sizeof(IMG_UBYTE));
		if(pubbInversed[3].ptr == nullptr)	{SYS_Assert(0); goto end;}
	}

	{
		IMG_ULWORD ulLinestep = (szOP.width+15) & (~0xF);
		//ALIGN_FreeCoarseSrchInfo();
		puwbCombined[0].ptr = (IMG_UWORD *) ALIGN_ROUND_PTR16(g_uwbufCoarseSrchCombined[0].ptr);
		puwbCombined[0].linestep = (IMG_LWORD)ulLinestep;					
		puwbCombined[0].size.width = szOP.width;							
		puwbCombined[0].size.height = szOP.height-2;
		SYS_Assert(ulLinestep == g_uwbufCoarseSrchCombined[0].linestep);
		SYS_Assert(g_uwbufCoarseSrchCombined[0].size.width == szOP.width);
		SYS_Assert(g_uwbufCoarseSrchCombined[0].size.height == szOP.height-2);
		if(g_uwbufCoarseSrchCombined[0].ptr == NULL) 
		{
			wState = MEM_ERR_MALLOC;
			THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
			goto end;
		}
		puwbCombined[0].ptr += ulLinestep;
	}
	//MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)&uwbCombined[0]);
	//if(wState != OK)	{SYS_Assert(0); goto end;}
	//uwbCombined[0].ptr += uwbCombined[0].linestep; uwbCombined[0].size.height -=2;
	//if((pstSrchOpt->ubCoarseSrchOpt & ALIGN_SRCH_EXHAUSTIVE_4DIR_COARSE_SRCH) && 
	//	(pstSrchOpt->uwPhaseInv==0 || pstSrchOpt->uwPhaseInv==3|| pstSrchOpt->uwPhaseInv==4))
	//{
	//	MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)&uwbCombined[1]);
	//	if(wState != OK)	{SYS_Assert(0); goto end;}
	//	MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)&uwbCombined[2]);
	//	if(wState != OK)	{SYS_Assert(0); goto end;}
	//	MEM_AllocBufAtBank_align(&szOP, (IMG_VVBUF *)&uwbCombined[3]);
	//	if(wState != OK)	{SYS_Assert(0); goto end;}
	//	uwbCombined[1].ptr += uwbCombined[1].linestep; uwbCombined[1].size.height -=2;
	//	uwbCombined[2].ptr += uwbCombined[2].linestep; uwbCombined[2].size.height -=2;
	//	uwbCombined[3].ptr += uwbCombined[3].linestep; uwbCombined[3].size.height -=2;
	//}
	//check_heap(__FILE__, __LINE__);



	//get the max vector length;
	for(i = 0, rMaxVectorLength = 0; i<(IMG_LWORD)ulVoteFeatNum; i++)
	{
		rA = pstVote[i].rco.x*pstVote[i].rco.x+
			pstVote[i].rco.y*pstVote[i].rco.y;
		if(rMaxVectorLength < rA)	rMaxVectorLength = rA;
	}
	rMaxVectorLength = (IMG_REAL)sqrt(rMaxVectorLength);


	//calculate propriate voting times according to rotation
	ulNumOfRotation = (IMG_UWORD)(rMaxVectorLength*rScaleMax *
		(rEndAngle - rStartAngle)*
		PI/180.0f/SEARCH_ANGLE_INTERVAL)+1;
	if((ulNumOfRotation+1)%2)ulNumOfRotation++;
	rRotationInterval = (rEndAngle-rStartAngle)/(ulNumOfRotation);
	if(rRotationInterval > 5.0f ) 
	{
		//if rotation interval larger than 5 degree, set max rotation length to 1
		//add this logic for small template
		ulNumOfRotation = (IMG_UWORD)((IMG_LREAL)(rEndAngle - rStartAngle)/5.0+0.5);
		if((ulNumOfRotation+1)%2)ulNumOfRotation++;
		rRotationInterval = (rEndAngle-rStartAngle)/(ulNumOfRotation);
	}
	pubMaskflag = (IMG_UBYTE *)mem_pool.Malloc(ulNumOfRotation);
	pubMaskflagPreviousLevel = (IMG_UBYTE *)mem_pool.Malloc(ulNumOfRotation);
	if(pubMaskflag == NULL || pubMaskflagPreviousLevel == NULL )
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		wState = MEM_ERR_MALLOC;
		goto end;
	}

	if(pstSrchOpt ->rCoarseAcceptLevel > 0)
	{
		if(pstSrchOpt ->rCoarseAcceptLevel > pstSrchOpt ->rVoteRejMargin)
			ulCoarseSearchAcceptValue = (IMG_ULWORD)((IMG_LREAL)pstSrchOpt ->rCoarseAcceptLevel*ulMaxValue+0.5);		//max value
		else
			ulCoarseSearchAcceptValue = (IMG_ULWORD)((IMG_LREAL)pstSrchOpt ->rVoteRejMargin*ulMaxValue+0.5);		//max value
	}
	else
	{
		psrOptable->size = 0;
		{SYS_Assert(0); goto end;}
	}
	if(uwDebug & 1)
	{
		_snprintf(buf, 256, "Coarse Search Acceptance Value: %lu\n", ulCoarseSearchAcceptValue);
		HL_Printf(m_pHtmlLog,  buf);
	}

	pcoLocalMax = (IMG_COORD *)mem_pool.Malloc(sizeof(IMG_COORD)*ulMaxCoarSearchCandidate*2);
	pulPeakNum = (IMG_ULWORD *)mem_pool.Malloc(sizeof(IMG_ULWORD)*ulNumOfRotation);
	if(pcoLocalMax == NULL || pulPeakNum == NULL)
	{
		THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
		wState = MEM_ERR_MALLOC;
		{goto end;}
	}


	if(pstVotingInfo == NULL)
	{
		pwbufVote	=	(IMG_WBUF *)mem_pool.Malloc(sizeof(IMG_WBUF)*(3));					
		//HL_Printf(m_pHtmlLog,  "pwbufVote = 0x%08X\n", (IMG_ULWORD)pwbufVote);
		if(pwbufVote == NULL)
		{
			THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
			wState = MEM_ERR_MALLOC; {goto end;}
		}
		for(i = 0 ; i<(IMG_LWORD)3; i++)
		{
			MEM_AllocBufAtBank_align((IMG_SIZE *)&szOP, (IMG_VVBUF *)(pwbufVote+i), sizeof(IMG_WORD));
			//HL_Printf(m_pHtmlLog,  "pwbufVote[i].ptr = 0x%08X\n", (IMG_ULWORD)pwbufVote[i].ptr);
			if(pwbufVote[i].ptr == nullptr)		{SYS_Assert(0); goto end;}
			//memset(pwbufVote[i].ptr, 0, pwbufVote[i].size.height*pwbufVote[i].linestep*sizeof(IMG_WORD));
			pwbufVote[i].ptr += pwbufVote[i].linestep;
			pwbufVote[i].size.height -= 2;
		}
	}
	else
	{
		nx = (szOP.width+0x10)&(~0xF);		//align of 16
		pwbufVote = pstVotingInfo->pwbVoting = (IMG_WBUF *)CVisMemPool::PMalloc(sizeof(IMG_WBUF)*ulNumOfRotation+
			(size_t)szOP.height*(IMG_ULWORD)nx*sizeof(IMG_WORD)*ulNumOfRotation+(IMG_ULWORD)16);
		VALIDATE_MALLOC(pwbufVote);

		pstVotingInfo->prAngle = (IMG_REAL *)CVisMemPool::PMalloc(sizeof(IMG_REAL)*ulNumOfRotation);
		VALIDATE_MALLOC(pstVotingInfo->prAngle);

//#ifdef _WIN64
//		pD = (IMG_WORD *)((((IMG_UXLWORD)pwbufVote+sizeof(IMG_WBUF)*ulNumOfRotation+0x10)&(~0xF)));
//		SYS_Assert(((IMG_UXLWORD)pD & 0xF) == 0 && (nx & 0xF) == 0);
//#else
//		pD = (IMG_WORD *)((((IMG_ULWORD)pwbufVote+sizeof(IMG_WBUF)*ulNumOfRotation+0x10)&(~0xF)));
//		SYS_Assert(((IMG_ULWORD)pD & 0xF) == 0 && (nx & 0xF) == 0);
//#endif
		pD = (IMG_WORD *)ALIGN_ROUND_PTR16(pwbufVote+ulNumOfRotation);
		//memset(pD, 0, sizeof(IMG_WORD)*ulNumOfRotation*szOp.height*nx);
		for(i = 0 ; i<(IMG_LWORD)ulNumOfRotation; i++)
		{
			//HL_Printf(m_pHtmlLog,  "pwbufVote[i].ptr = 0x%08X\n", (IMG_ULWORD)pwbufVote[i].ptr);
			pwbufVote[i].linestep = nx;
			pwbufVote[i].size.width = szOP.width;
			pwbufVote[i].ptr = pD+nx;	//one line margin
			pwbufVote[i].size.height = szOP.height-2;
			pD += nx*szOP.height;
			pstVotingInfo->prAngle[i] = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
						(i+0.5)/(ulNumOfRotation)));
		}
		pstVotingInfo->uwNumOfVoting = (IMG_UWORD)ulNumOfRotation;
		pstVotingInfo->ulMaxScore = ulMaxValue;
	}
	if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("init");
	//
	///////////////////////////////////////////
	//Prepare data for mask generation
	///////////////////////////////////////////

	//
	if(g_ptdebug)
	{
		FILE *fp;
		memset(&output_1, 0, sizeof(output_1));
		fp = fopen("position.txt", "rt");
		if(fp && pcoSoff)
		{
			fscanf(fp, "%f %f %f", &output_1.rX, &output_1.rY, &output_1.angle);
			fclose(fp);
			output_1.x = (output_1.rX+0.5);
			output_1.y = (output_1.rY+0.5);
			output_1.rX -= pcoSoff->x, output_1.rY -= pcoSoff->y;
			output_1.x -= pcoSoff->x, output_1.y -= pcoSoff->y;
		}
	}


	//get distance transform 
	if(uwScaleLoopIndex == 0)
	{
		//check_heap(__FILE__, __LINE__);
		if(InputType == ALIGN_2DCode)
		{
			combine_edge_and_direction((IMG_UBBUF *)pubbEpbuf, &coS, (IMG_UWBUF *)pwbDir, &coDir, puwbCombined, &coZero, ulScale, (IMG_SIZE *)pszOpsize);
		}
		else
		{
			wState = ALIGN_Compare_SSE((IMG_UBBUF *)pubbEpbuf, &coS, pubbInversed, &coZero, (IMG_UBYTE)235, (IMG_UBYTE)3, (IMG_SIZE *)pszOpsize);
			if(wState != OK)		{SYS_Assert(0); goto end;}
			//making composition buffer combine distance trans and direction
			//check_heap(__FILE__, __LINE__);
			combine_distance_and_direction(pubbInversed, &coZero, 
				(IMG_UWBUF *)pwbDir, &coDir, 
				puwbDist, &coZero,
				(IMG_SIZE *)pszOpsize, (IMG_UBYTE)NEAREST_OBJ_DISTANCE, (IMG_UBYTE)ulScale);
			if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("combination");
			//doing distance transform
			if(ubColor == IMG_CHANNEL_COLOR)
			{
				for(i = 0; i<ubColor; i++)
				{
					wState = ALIGN_Compare_SSE((IMG_UBBUF *)pubbEpbuf+i+1, &coS, pubbInversed+i+1, &coZero, (IMG_UBYTE)235, (IMG_UBYTE)3, (IMG_SIZE *)pszOpsize);
					if(wState != OK)		{SYS_Assert(0); goto end;}
					combine_distance_and_direction(pubbInversed+i+1, &coZero, 
						(IMG_UWBUF *)pwbDir+i+1, &coDir, 
						puwbDist+i+1, &coZero,
						(IMG_SIZE *)pszOpsize, (IMG_UBYTE)NEAREST_OBJ_DISTANCE, (IMG_UBYTE)ulScale);
					wState = ALIGN_DistanceTransform_d_SSE(puwbDist+i+1, &coZero, puwbCombined+i+1, &coZero, (IMG_SIZE *)pszOpsize, 3, ubKernel); 
					if(wState != OK)		{SYS_Assert(0); goto end;}
				}
			}
			//check_heap(__FILE__, __LINE__);
			wState = ALIGN_DistanceTransform_d_SSE(puwbDist, &coZero, puwbCombined, &coZero, (IMG_SIZE *)pszOpsize, 3, ubKernel); 
			if(wState != OK)		{SYS_Assert(0); goto end;}
#ifdef _OUTPUT_LOG
			HL_Printf(m_pHtmlLog,  "Edge percent %f%%\n", (IMG_REAL)ulNumEdge*100/(IMG_REAL)((size_t)pszOpsize->width*pszOpsize->height));
			imdebug("lum *180 b=16 w=%d h=%d t='edge direction' %p", pwbDir->linestep, pwbDir->size.height, pwbDir->ptr);
			imdebug("lum *auto b=8 w=%d h=%d t='edge reverse' %p", pubbInversed[0].linestep, pubbInversed[0].size.height, pubbInversed[0].ptr);
			imdebug("luma *auto rgba=_gb_ b=8 w=%d h=%d t='distance transed 1' %p", puwbCombined[0].linestep, puwbCombined[0].size.height, puwbCombined[0].ptr);

#endif
			//check_heap(__FILE__, __LINE__);
			distance_adjust(puwbCombined, &coZero, (IMG_SIZE *)pszOpsize, (IMG_UBYTE)NEAREST_OBJ_DISTANCE, (IMG_UBYTE)ulScale);
			if(ubColor == IMG_CHANNEL_COLOR)
			{
				distance_adjust(puwbCombined+1, &coZero, (IMG_SIZE *)pszOpsize, (IMG_UBYTE)NEAREST_OBJ_DISTANCE, (IMG_UBYTE)ulScale);
				distance_adjust(puwbCombined+2, &coZero, (IMG_SIZE *)pszOpsize, (IMG_UBYTE)NEAREST_OBJ_DISTANCE, (IMG_UBYTE)ulScale);
				distance_adjust(puwbCombined+3, &coZero, (IMG_SIZE *)pszOpsize, (IMG_UBYTE)NEAREST_OBJ_DISTANCE, (IMG_UBYTE)ulScale);
			}
		}
		
	}
	if(uwDebug & 2048)
	{
		//CVisAlignRecordTable stRep;
		//ALIGN_LrnInitTable(&stRep);
		FILE *fp;

		for(i = 0; i<3; i++)
		{
			MEM_AllocBufAtBank((IMG_SIZE *)pszOpsize, (IMG_VVBUF *)ubbImage+i, sizeof(IMG_UBYTE));
			if(ubbImage[i].ptr == nullptr) break;
		}
		if(wState == OK)
		{
			BUF_OFF(pD1[0], ubbImage+0, &coZero);
			BUF_OFF(pD1[1], ubbImage+1, &coZero);
			BUF_OFF(pD1[2], ubbImage+2, &coZero);
			BUF_OFF(pS1, &(puwbCombined[0]), &coZero);
			for(i = 0; i<pszOpsize->height; i++)
			{
				for(j = 0; j<pszOpsize->width; j++)
				{
					pD1[2][j] = pS1[j] & 0xFF;
					pD1[1][j] = pS1[j] >> 8;
					pD1[0][j] = pS1[j] >> 8;
				}
				pS1 += puwbCombined[0].linestep;
				pD1[0] += ubbImage[0].linestep;
				pD1[1] += ubbImage[1].linestep;
				pD1[2] += ubbImage[2].linestep;
			}
		}

		//create_filename((IMG_UBYTE *)buf,(IMG_UBYTE*)"gse",wAlignFileIndex,(IMG_UBYTE*)".bmp");
		//FILE_SaveImage((IMG_UBBUF *)pubbEpbuf,&coZero,(IMG_SIZE *)&pubbEpbuf->size,(IMG_UBYTE *)buf);

#ifdef WIN32
		//create_filename((IMG_UBYTE *)buf,(IMG_UBYTE*)"gsdir",wAlignFileIndex,(IMG_UBYTE*)".tif");
		//ALIGN_SaveImage_w((IMG_WBUF *)pwbDir,(IMG_UBYTE *) buf);
		//FILE_SaveImageTiff_w((IMG_WBUF *)pwbDir,&coZero,(IMG_SIZE *)&pubbEpbuf->size,(const IMG_CHAR *)buf);
#else
		//create_filename((IMG_UBYTE *)buf,(IMG_UBYTE*)"gsdir",wAlignFileIndex,(IMG_UBYTE*)".img");
		//FILE_SaveImage_w((IMG_WBUF *)pwbDir,&coZero,(IMG_SIZE *)&pubbEpbuf->size,(IMG_UBYTE *)buf);

#endif

		//create_filename((IMG_UBYTE *)buf,(IMG_UBYTE*)"gsdis",wAlignFileIndex,(IMG_UBYTE*)".bmp");
		//FILE_SaveColorImage(ubbImage,&coZero,&ubbImage[0].size,(IMG_UBYTE *)buf);
		IMG_CHAR *p;
		_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uCoarseDistSrc.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex);
		CVisImage img(ubbImage);
		img.WriteImage(pathname);
		p = strrchr(pathname, '\\')-10;
		writeLog("Distance image\n");
		HL_InsertImage(m_pHtmlLog, p);

		if(ubColor == IMG_CHANNEL_COLOR)
		{
			pub = buf+strlen(buf)-4;
			pub[0] = 'A';
			pub[1] = '.';
			pub[2] = 'b';
			pub[3] = 'm';
			pub[4] = 'p';
			pub[5] = '\0';
			for(k = 1; k<ubColor+1; k++)
			{
				BUF_OFF(pD1[0], ubbImage+0, &coZero);
				BUF_OFF(pD1[1], ubbImage+1, &coZero);
				BUF_OFF(pD1[2], ubbImage+2, &coZero);
				BUF_OFF(pS1, &(puwbCombined[k]), &coZero);
				for(i = 0; i<pszOpsize->height; i++)
				{
					for(j = 0; j<pszOpsize->width; j++)
					{
						pD1[2][j] = pS1[j] & 0xFF;
						pD1[1][j] = pS1[j] >> 8;
						pD1[0][j] = pS1[j] >> 8;
					}
					pS1 += puwbCombined[0].linestep;
					pD1[0] += ubbImage[0].linestep;
					pD1[1] += ubbImage[1].linestep;
					pD1[2] += ubbImage[2].linestep;
				}
				//FILE_SaveColorImage(ubbImage,&coZero,&ubbImage[0].size,(IMG_UBYTE *)buf);
				pub[0]++;
			}
		}


		//create_filename((IMG_UBYTE *)buf,(IMG_UBYTE*)"gslut",wAlignFileIndex,(IMG_UBYTE*)".ret");
		//ulLutSize = ALIGN_PackSizeOfRetable(&stRep);
		//ulLutSize = ALIGN_PackSizeOfRetable(pstEptable);
		//pLut1 = pLut = (IMG_ULWORD *)mem_pool.Malloc(ulLutSize, SYS_BANK1_32);
		//if(pLut != NULL)
		//{
		//	wState = ALIGN_PackRetable(pstEptable, &pLut1);
		//	fp = fopen((char *)buf, "wb");
		//	if(fp != NULL)
		//	{
		//		fwrite((char *)pLut, ulLutSize*sizeof(IMG_ULWORD), 1, fp);
		//		fclose(fp);
		//	}
		//	//pLut1 = pLut;
		//	//wState = ALIGN_UnpackRetable((const IMG_ULWORD **)&pLut1, pstEptable);
		//	//pLut1 = pLut;
		//	//wState = ALIGN_PackRetable(&stRep, &pLut1);
		//	//pLut1 = pLut;
		//	//wState = ALIGN_UnpackRetable((const IMG_ULWORD **)&pLut1, &stRep);
		//	//pLut1 = pLut;
		//}
	}
	if(uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog,  "Coarse Srch ROI = [ %d %d ]-[ %d %d ] \n", coS.x, coS.y, coS.x+pszOpsize->width, coS.y+pszOpsize->height);
		HL_Printf(m_pHtmlLog,  "Scale Set to %f \n", rScale);
		HL_Printf(m_pHtmlLog,  "VoteHalfAngle = %d \n", pstSrchOpt ->ubAngleMatchTolerance);
		HL_Printf(m_pHtmlLog,  "Vote Reject Margin = %.3f \n", pstSrchOpt ->rVoteRejMargin);
		HL_Printf(m_pHtmlLog,  "MaxVoteScore = %d \n", ulMaxValue);
		_snprintf(buf, 256, "Num of Rotation = %lu, rRotationInterval = % 2.2f\n", ulNumOfRotation, rRotationInterval);
		HL_Printf(m_pHtmlLog,  buf);
		HL_Printf(m_pHtmlLog,  "Learn Elastic = %f \n", pstEptable->rExpVotingElastic);
		HL_Printf(m_pHtmlLog,  "Learn PseudoReduction = %d \n", pstEptable->uwExpVotingReduction);

	}
#ifdef _OUTPUT_LOG
	imdebug("luma rgba=__ba b=8 w=%d h=%d *auto t='adjust' %p", puwbCombined[0].linestep, pszOpsize->height, puwbCombined[0].ptr);
#endif

	//#ifdef _OUTPUT_LOG
	//		imdebug("lum *auto b=8 w=%d h=%d t='distance transform' %p", ipplinestep, ippszImage.height, ipp8uBufResult);
	//#endif
	if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("dist_trans");
	check_heap(__FILE__, __LINE__);
	//

	///////////////////////////////////////////
	//Mask buffer generate
	//////////////////////////////////////////
	//
	wState = generate_mask_core(puwbCombined, NULL, NULL, (IMG_SIZE *)pszOpsize, pstEptable, 
		rScaleX, rScaleY, ulNumOfRotation, 
		pstSrchOpt ->rCoarseAcceptLevel, rMaxVectorLength, 
		pstSrchOpt->uwPhaseInv, rStartAngle, rEndAngle, pstSrchOpt->uwCompleteObj,uwScaleLoopIndex, 
		&plwbufMask, pubMaskflagPreviousLevel, &ulNumMask, MultiObj, pstSrchOpt, 0, InputType, pstSrchOpt->uwDebug);
	//wState = generate_mask(uwbCombined, NULL, (IMG_SIZE *)pszOpsize, pstVote, 
	//	ulVoteFeatNum, rScaleX, rScaleY, ulNumOfRotation, 
	//	pstSrchOpt ->stAdvPara.rCoarseAcceptLevel, rMaxVectorLength, 
	//	pstSrchOpt->uwPhaseInv, rStartAngle, rEndAngle, pstSrchOpt->uwCompleteObj, pstSrchOpt->ubCoarseSrchOpt,uwScaleLoopIndex, 
	//	&lwbufMask, pstSrchOpt->MultiObj, pstSrchOpt , pstSrchOpt, pstSrchOpt->uwDebug);

	if(wState != OK)		{goto end;}
	//
	///////////////////////////////////////////
	//Search buffer
	//////////////////////////////////////////
	//

	lwMinX = 0;
	lwMinY = 0;
	lwMaxX = pszOpsize->width-1;
	lwMaxY = pszOpsize->height-1;

	pulVotingArea = (IMG_ULWORD *)mem_pool.Malloc(sizeof(IMG_ULWORD)*ulNumOfRotation*ulVotingAreaPartitionX*ulVotingAreaPartitionY);
	if(pulVotingArea == NULL)
	{
		wState = MEM_ERR_MALLOC;
		goto end;
	}

	//check_heap(__FILE__, __LINE__);
	pwbufCurrentVote = pwbufVote;
	for(ulAngle = 0; ulAngle < ulNumOfRotation; ulAngle++)
	{
		ny = (IMG_LWORD)ulNumMask;	//num of rotation in mask
		pulPeakNum[ulAngle] = 0;

		if(pstVotingInfo != NULL)	pwbufCurrentVote = pwbufVote+ulAngle;
		else 						pwbufCurrentVote = pwbufVote+2;

		rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
			(ulAngle+0.5)/(ulNumOfRotation))*PI/180.0f);
		cose = (IMG_REAL)cos(rAngle), sine = (IMG_REAL)sin(rAngle);

		for(nx = 0, rA= 1e5; nx < ny; nx++)
		{
			if(rA > fabs(rAngle - (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
				(nx+0.5f)/(ny))*(IMG_REAL)PI/180.0f)))
			{
				rA = (IMG_REAL)fabs(rAngle - (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
					(nx+0.5f)/(ny))*(IMG_REAL)PI/180.0f));
				lwAngle = nx;				//corresponding angle
			}
		}
		pulPtr = pulVotingArea+ulAngle*ulVotingAreaPartitionX*ulVotingAreaPartitionY;
		memset(pulPtr, 0, ulVotingAreaPartitionX*ulVotingAreaPartitionY*sizeof(pulPtr[0]));
		if(pubMaskflagPreviousLevel[lwAngle] == IMG_FALSE)
		{
			pubMaskflag[ulAngle] = IMG_FALSE;
		}
		else
			pubMaskflag[ulAngle] = IMG_TRUE;
		//generate voting area mask
		if(pubMaskflag[ulAngle])
		{
			for(ny = 0; ny<plwbufMask[lwAngle].size.height; ny++)
			{
				plwMask = plwbufMask[lwAngle].ptr+ny*(size_t)plwbufMask[lwAngle].linestep;
				y = ny*(IMG_LWORD)ulVotingAreaPartitionY/pszOpsize->height;
				while(plwMask[0])
				{
					for(nx = plwMask[0]*(IMG_LWORD)ulVotingAreaPartitionX/pszOpsize->width; 
							nx <= plwMask[1]*(IMG_LWORD)ulVotingAreaPartitionX/pszOpsize->width; nx++)
					{
						pulPtr[y*(IMG_LWORD)ulVotingAreaPartitionX+nx] = 1;
					}
					plwMask+=2;
				}
			}
			//initial voting area
			if(pstSrchOpt->uwDebug & 4 && pstVotingInfo == NULL)	memset(pwbufCurrentVote->ptr, 0x3f, sizeof(IMG_WORD)*(size_t)pwbufCurrentVote->linestep*pwbufCurrentVote->size.height);
			if(pstVotingInfo != NULL)memset(pwbufCurrentVote->ptr, 0, sizeof(IMG_WORD)*(size_t)pwbufCurrentVote->linestep*pwbufCurrentVote->size.height);
			for(ny = 0; ny<(IMG_LWORD)ulVotingAreaPartitionY; ny++)
			{
				if(ny != 0)			coR.y = ((size_t)pwbufCurrentVote->size.height*ny/(IMG_LWORD)ulVotingAreaPartitionY-lwMargin);
				else				coR.y = 0;
				if(ny != (IMG_LWORD)ulVotingAreaPartitionY-1)
									szOP.height = (pwbufCurrentVote->size.height/(IMG_LWORD)ulVotingAreaPartitionY+lwMargin+1);
				else				szOP.height = (pwbufCurrentVote->size.height-coR.y-lwMargin);
				if(coR.y != 0 || ny == (IMG_LWORD)ulVotingAreaPartitionY-1)		szOP.height += lwMargin;
				for(nx = 0; nx<(IMG_LWORD)ulVotingAreaPartitionX; nx++)
				{
					if(nx != 0) coR.x = ((size_t)pwbufCurrentVote->size.width*nx/(IMG_LWORD)ulVotingAreaPartitionX-lwMargin); 
					else		coR.x = 0;
					if(nx != (IMG_LWORD)ulVotingAreaPartitionX-1)
								szOP.width = (pwbufCurrentVote->size.width/(IMG_LWORD)ulVotingAreaPartitionX+lwMargin+1);
					else		szOP.width = (pwbufCurrentVote->size.width-coR.x-lwMargin);
					if(coR.x != 0 || nx == (IMG_LWORD)ulVotingAreaPartitionX-1)	szOP.width += lwMargin;
					if(pulPtr[ny*(IMG_LWORD)ulVotingAreaPartitionX+nx])
					{
						SYS_Assert(ny*(IMG_LWORD)ulVotingAreaPartitionX+nx < (IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY);
						SYS_Assert(coR.x >= 0 && coR.x+szOP.width <= pwbufCurrentVote->size.width);
						SYS_Assert(coR.y >= 0 && coR.y+szOP.height <= pwbufCurrentVote->size.height);
						wState = VIS_FillBuffer_w(0, pwbufCurrentVote, &coR, &szOP);
						SYS_Assert(wState == OK);
					}
				}
			}
			memset(pwbufCurrentVote->ptr, 0, sizeof(IMG_WORD)*(size_t)pwbufCurrentVote->linestep*pwbufCurrentVote->size.height);
		}
		else
		{
			if(pstVotingInfo != NULL)memset(pwbufCurrentVote->ptr, 0, sizeof(IMG_WORD)*(size_t)pwbufCurrentVote->linestep*pwbufCurrentVote->size.height);
		}
		//voting by feature
		for(ulFeat = 0; pubMaskflag[ulAngle] && ulFeat<ulVoteFeatNum ; ulFeat++)
		{
			rco.x = (cose*pstVote[ulFeat].rco.x - sine*pstVote[ulFeat].rco.y)*rScaleX;
			rco.y = (sine*pstVote[ulFeat].rco.x + cose*pstVote[ulFeat].rco.y)*rScaleY;

			//if((pstVote[ulFeat].ubVoteHalfAngle & 0x7f) && (pstSrchOpt ->wAdvLrnOpt & 1))	//have local angle
			//{
			//	if(pstVote[ulFeat].ubVoteHalfAngle & 0x80) //have local phaseinv
			//	{
			//		VALID_ANGLE_BIAS = (pstVote[ulFeat].ubVoteHalfAngle & 0x7f)*256/360+1;
			//	}
			//	else
			//	{
			//		VALID_ANGLE_BIAS = (pstVote[ulFeat].ubVoteHalfAngle+1+20)*256/360;;
			//	}
			//}
			//else
			{
				if(pstSrchOpt->uwPhaseInv == 0 || pstSrchOpt->uwPhaseInv == 3 || pstSrchOpt->uwPhaseInv == 4)
				{
					//if((pstVote[ulFeat].ubVoteHalfAngle & 0x80) && (pstSrchOpt ->wAdvLrnOpt & 1))
					//{
					//	VALID_ANGLE_BIAS = (pstSrchOpt ->ubAngleMatchTolerance)*256/360+1;
					//}
					//else
					{
						VALID_ANGLE_BIAS = (pstSrchOpt ->ubAngleMatchTolerance+1+20)*256/360;
					}
				}
				else
				{
					VALID_ANGLE_BIAS = (pstSrchOpt ->ubAngleMatchTolerance)*256/360+1;
				}
			}
			if(InputType == ALIGN_POINT) VALID_ANGLE_BIAS = 9;//20130607 poon ho shan//35;

			//if(rco.x > 0)coR.x = (IMG_WORD) (rco.x+0.5);
			//else		coR.x = (IMG_WORD) (rco.x-0.5);
			//if(rco.y > 0)coR.y = (IMG_WORD) (rco.y+0.5);
			//else		coR.y = (IMG_WORD) (rco.y-0.5);
			coR.x = ((((IMG_LWORD)((IMG_LREAL)rco.x+65536+0.5)))-(IMG_LWORD)(65536));
			coR.y = ((((IMG_LWORD)((IMG_LREAL)rco.y+65536+0.5)))-(IMG_LWORD)(65536));


			if(coR.x < lwMinX)					startx = -coR.x > lwMinX ? -coR.x : lwMinX;
			else								startx = lwMinX;
			if(coR.y < lwMinX)					starty = -coR.y > lwMinY ? -coR.y : lwMinY;
			else								starty = lwMinY;
			if(coR.x >= pszOpsize->width-lwMaxX)	endx = pszOpsize->width-coR.x-1;
			else								endx = pszOpsize->width-1;
			if(coR.y >= pszOpsize->height-lwMaxY)	endy = pszOpsize->height-coR.y-1;
			else								endy = pszOpsize->height-1;

			if(InputType == ALIGN_POINT)
				wLocalAngle = (IMG_WORD)(ALIGN_NORMAL_DIR_NCOLOR( (IMG_WORD)(pstVote[ulFeat].angle))*256.0/360+0.5);
			else
				wLocalAngle = (IMG_WORD)(rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( (IMG_WORD)pstVote[ulFeat].angle)*256.0/360+0.5);
			wVoteWeight = pbFeatureWeight[ulFeat];

			i = ((wLocalAngle+32)&0xff)>>6;
			if(ubColor == IMG_CHANNEL_COLOR)
			{
				if(ALIGN_IS_NCOLOR_NORMAL((IMG_WORD)pstVote[ulFeat].angle) && pstSrchOpt->ubColorMatchOpt != ALIGN_NCOLOR_DIR_MATCH_SEARCHMAX)
					i = ALIGN_INDEX_NCOLOR((IMG_WORD)(pstVote[ulFeat].angle))+1;
				else
					i = 0;
				pS = (IMG_WORD*)puwbCombined[i].ptr+(coR.y+starty)*((size_t)puwbCombined[i].linestep)+coR.x;
			}
			else
			{
				pS = (IMG_WORD*)puwbCombined[0].ptr+(coR.y+starty)*((size_t)puwbCombined[0].linestep)+coR.x;
			}
			BUF_OFF(pD, pwbufCurrentVote, &coZero);
			pD += (size_t)pwbufCurrentVote->linestep*starty;
			if((pstSrchOpt->uwPhaseInv==0 || pstSrchOpt->uwPhaseInv==3|| pstSrchOpt->uwPhaseInv==4))		//check 
			{
				__asm
				{
					//_xmmV = _mm_set1_epi16(VALID_ANGLE_BIAS);
					mov			eax, VALID_ANGLE_BIAS
					mov			_EDX, _xmmV
					movd		xmm0, eax
					movdqa		xmm1, xmm0
					punpcklwd	xmm1, xmm0
					pshufd		xmm1, xmm1, 0
					movdqa		[_EDX], xmm1									 
					// _xmmW = _mm_set1_epi16(wLocalAngle<<8);
					xor			eax, eax
					mov			ax, wLocalAngle
					shl			eax, 8
					movd		xmm0, eax
					movdqa		xmm1, xmm0
					punpcklwd	xmm1, xmm0
					pshufd		xmm1, xmm1, 0
					movdqa		[_EDX+16], xmm1									 
					//_xmmWeight = _mm_set1_epi16(wVoteWeight);
					xor			eax, eax
					mov			ax, wVoteWeight
					movd		xmm0, eax
					movdqa		xmm1, xmm0
					punpcklwd	xmm1, xmm0
					pshufd		xmm1, xmm1, 0
					movdqa		[_EDX+32], xmm1										
				}
			}
			else	//phase inverse
			{
				__asm
				{
					//_xmmV = _mm_set1_epi16(VALID_ANGLE_BIAS);
					mov			eax, VALID_ANGLE_BIAS
					mov			_EDX, _xmmV
					movd		xmm0, eax
					movdqa		xmm1, xmm0
					punpcklwd	xmm1, xmm0
					pshufd		xmm1, xmm1, 0
					movdqa		[_EDX], xmm1									 
					// _xmmW = _mm_set1_epi16(wLocalAngle<<8);
					xor			eax, eax
					mov			ax, wLocalAngle
					shl			eax, 9
					movd		xmm0, eax
					movdqa		xmm1, xmm0
					punpcklwd	xmm1, xmm0
					pshufd		xmm1, xmm1, 0
					movdqa		[_EDX+16], xmm1									 
					//_xmmWeight = _mm_set1_epi16(wVoteWeight);
					xor			eax, eax
					mov			ax, wVoteWeight
					movd		xmm0, eax
					movdqa		xmm1, xmm0
					punpcklwd	xmm1, xmm0
					pshufd		xmm1, xmm1, 0
					movdqa		[_EDX+32], xmm1										
				}
			}
			if(pstSrchOpt->uwPhaseInv==0 || pstSrchOpt->uwPhaseInv==3|| pstSrchOpt->uwPhaseInv==4)		//check 
			{
				wLocalAngle &= 0xFF;
				for(y = starty; y<=endy; y++)
				{
					plwMask = plwbufMask[lwAngle].ptr +(y)*(size_t)plwbufMask[lwAngle].linestep;
					while(plwMask[0])		//have data
					{
						/*for(x = (plwMask[0]-1)<<1; x<=((plwMask[1]-1)<<1)+1; x++)
						{
						i = labs((char)((pS[x]&0xFF)-wLocalAngle));
						i = (-((IMG_LWORD)(i<VALID_ANGLE_BIAS)))&0xFFFF ; 
						j = (pS[x]&0xFF00)>>(8);
						pD[x] += (IMG_WORD)(i & ( j*wVoteWeight ));
						}
						*/
						x = ((plwMask[0]))-1 > startx ? ((plwMask[0]))-1 : startx;
						nx = ((plwMask[1]))+1 < endx ? ((plwMask[1]))+1 : endx;
						if(x > nx)
						{
							plwMask+=2;
							continue;
						}
						__asm
						{
							//for(; x<endx-7; x+=8)
							mov			_ECX, _xmmV
							xor			_EAX, _EAX
							mov			eax, x
							mov			edx, nx
							shl			eax, 1
							shl			edx, 1
							mov			_ESI, pS
							mov			_EDI, pD
							movdqa		xmm5, [_ECX+32]		//_xmmWeight
							movdqa		xmm6, [_ECX+16]		//_xmmW
							movdqa		xmm7, [_ECX]			//_xmmV
start1:
							movdqu		xmm0, [_ESI+_EAX]
							movdqa		xmm2, xmm0
							movdqa		xmm3, xmm0
							psrlw		xmm2, 8
							psllw		xmm3, 8
							pmullw		xmm2, xmm5
							movdqa		xmm1, xmm6
							psubw		xmm1, xmm3
							movdqa		xmm3, xmm7
							pxor		xmm4, xmm4
							pcmpgtw		xmm4, xmm1
							pxor		xmm1, xmm4
							psubw		xmm1, xmm4
							psrlw		xmm1, 8	
							pcmpgtw		xmm3, xmm1
							pand		xmm3, xmm2
							movdqu		xmm2, [_EDI+_EAX]
							paddsw		xmm3, xmm2
							movdqu		[_EDI+_EAX], xmm3														 
							add			eax, 16
							cmp			eax, edx
							jl			start1
							mov			x, eax
						}

						plwMask+=2;
					}
					pS +=puwbCombined[0].linestep;
					pD += pwbufCurrentVote->linestep;
				}
			}
			else if(pstSrchOpt->uwPhaseInv == 2 ||pstSrchOpt->uwPhaseInv==1)		//phase inverse ignore
			{
				wLocalAngle &= 0x7F;
				for(y = starty; y<=endy; y++)
				{
					plwMask = plwbufMask[lwAngle].ptr+(y)*(size_t)plwbufMask[lwAngle].linestep; 
					while(plwMask[0])		//have data
					{
						x = ((plwMask[0]))-1 > startx ? ((plwMask[0]))-1 : startx;
						nx = ((plwMask[1]))+1 < endx ? ((plwMask[1]))+1 : endx;
						if(x > nx)
						{
							plwMask+=2;
							continue;
						}
						__asm
						{
							//for(; x<endx-7; x+=8)
							mov			_ECX, _xmmV
							xor			_EAX, _EAX
							mov			eax, x
							mov			edx, nx
							shl			eax, 1
							shl			edx, 1
							mov			_ESI, pS
							mov			_EDI, pD
							movdqa		xmm5, [_ECX+32]		//_xmmWeight
							movdqa		xmm6, [_ECX+16]		//_xmmW
							movdqa		xmm7, [_ECX]			//_xmmV
start2:
							movdqu		xmm0, [_ESI+_EAX]
							movdqa		xmm2, xmm0
							movdqa		xmm3, xmm0
							psrlw		xmm2, 8
							psllw		xmm3, 9
							pmullw		xmm2, xmm5
							movdqa		xmm1, xmm6
							psubw		xmm1, xmm3
							movdqa		xmm3, xmm7
							pxor		xmm4, xmm4
							pcmpgtw		xmm4, xmm1
							pxor		xmm1, xmm4
							psubw		xmm1, xmm4
							psrlw		xmm1, 9
							pcmpgtw		xmm3, xmm1
							pand		xmm3, xmm2
							movdqu		xmm2, [_EDI+_EAX]
							paddsw		xmm3, xmm2
							movdqu		[_EDI+_EAX], xmm3														 
							add			eax, 16
							cmp			eax, edx
							jl			start2
							mov			x, eax
						}
						plwMask+=2;
					}
					pS +=puwbCombined[0].linestep;
					pD += pwbufCurrentVote->linestep;
				}
			}
		}
		//
		////////////////////////////////////////////////////
		//Local maximum
		////////////////////////////////////////////////////
		//
		//if(ulAngle > 0 || ulNumOfRotation == 1)
		//{{{
		{
			ulLocalmaxNum = 0;
			pulPtr = pulVotingArea+(IMG_LWORD)ulAngle*(IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY;
			if(pubMaskflag[ulAngle])
			{
				for(ny = 0; ny < (IMG_LWORD)ulVotingAreaPartitionY; ny++)
				{
					for(nx = 0; nx<(IMG_LWORD)ulVotingAreaPartitionX; nx++)
					{
						if(pulPtr[ny*(IMG_LWORD)ulVotingAreaPartitionX+nx])
						{
							if(nx == 0)			coR.x = 0;
							else				coR.x = ((size_t)pwbufCurrentVote->size.width*nx/(IMG_LWORD)ulVotingAreaPartitionX-lwMargin);
							if(ny == 0)			coR.y = 0;
							else				coR.y = ((size_t)pwbufCurrentVote->size.height*ny/(IMG_LWORD)ulVotingAreaPartitionY-lwMargin);
							if(nx == (IMG_LWORD)ulVotingAreaPartitionX-1)
								szOP.width = (pwbufCurrentVote->size.width-coR.x-lwMargin);	
							else			szOP.width = (pwbufCurrentVote->size.width/(IMG_LWORD)ulVotingAreaPartitionX+lwMargin+1);
							if(ny == (IMG_LWORD)ulVotingAreaPartitionY-1)
								szOP.height = (pwbufCurrentVote->size.height-coR.y-lwMargin);
							else			szOP.height = (pwbufCurrentVote->size.height/(IMG_LWORD)ulVotingAreaPartitionY+lwMargin+1);
							if(coR.x != 0 || nx == (IMG_LWORD)ulVotingAreaPartitionX-1)	szOP.width +=lwMargin;
							if(coR.y != 0 || ny == (IMG_LWORD)ulVotingAreaPartitionY-1)	szOP.height +=lwMargin;
							SYS_Assert(coR.x >= 0 && coR.x+szOP.width <= pwbufCurrentVote->size.width);
							SYS_Assert(coR.y >= 0 && coR.y+szOP.height <= pwbufCurrentVote->size.height);

							j = (IMG_LWORD)(ulMaxCoarSearchCandidate-ulLocalmaxNum);
							wState = VIS_Local_Max_w(pwbufCurrentVote, &coR, &szOP, (IMG_WORD)ulCoarseSearchAcceptValue, 5, pcoLocalMax+ulLocalmaxNum, (IMG_ULWORD *)&j);
							if(wState != OK) {SYS_Assert(0); goto end;}
							while(ulLocalmaxNum+(IMG_ULWORD)j >= ulMaxCoarSearchCandidate-1) 
							{
								ulMaxCoarSearchCandidate *= 2;
								pco = (IMG_COORD *)mem_pool.Malloc(ulMaxCoarSearchCandidate*sizeof(IMG_COORD));
								if( pco == NULL)
								{
									THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
									wState = MEM_ERR_MALLOC;
									{goto end;}
								}
								memcpy(pco, pcoLocalMax, sizeof(IMG_COORD)*ulLocalmaxNum);
								pcoLocalMax = pco;
								j = (IMG_LWORD)(ulMaxCoarSearchCandidate-ulLocalmaxNum);
								wState = VIS_Local_Max_w(pwbufCurrentVote, &coR, &szOP, (IMG_WORD)ulCoarseSearchAcceptValue, 5, pcoLocalMax+ulLocalmaxNum, (IMG_ULWORD *)&j);
								if(wState != OK) {SYS_Assert(0); goto end;}
							}
							ulLocalmaxNum += (IMG_ULWORD)j;
							pulPeakNum[ulAngle] += (IMG_ULWORD)j;
						}
					}
				}
				if(ulLocalmaxNum == 0 && 
						pstSrchOpt ->rVoteRejMargin < pstSrchOpt ->rCoarseAcceptLevel-1e-5f)
				{
					for(i = 0; i<(IMG_LWORD)ulAngle; i++)
						if(pulPeakNum[i]>0) break;
					if(i == (IMG_LWORD)ulAngle) //all direction have no peak
					{
						for(ny = 0; ny < (IMG_LWORD)ulVotingAreaPartitionY; ny++)
						{
							for(nx = 0; nx<(IMG_LWORD)ulVotingAreaPartitionX; nx++)
							{
								if(pulPtr[ny*(IMG_LWORD)ulVotingAreaPartitionX+nx])
								{
									if(nx == 0)			coR.x = 0;
									else				coR.x = ((size_t)pwbufCurrentVote->size.width*nx/(IMG_LWORD)ulVotingAreaPartitionX);
									if(ny == 0)			coR.y = 0;
									else				coR.y = ((size_t)pwbufCurrentVote->size.height*ny/(IMG_LWORD)ulVotingAreaPartitionY);
									if(nx == (IMG_LWORD)ulVotingAreaPartitionX-1)
										szOP.width = (pwbufCurrentVote->size.width-coR.x);	
									else			szOP.width = (pwbufCurrentVote->size.width/(IMG_LWORD)ulVotingAreaPartitionX+1);
									if(ny == (IMG_LWORD)ulVotingAreaPartitionY-1)
										szOP.height = (pwbufCurrentVote->size.height-coR.y);
									else			szOP.height = (pwbufCurrentVote->size.height/(IMG_LWORD)ulVotingAreaPartitionY+1);
									wState = ALIGN_FindMax_w(pwbufCurrentVote, &coR, &szOP, &coMax, &wVal);
									if(wState != OK) {SYS_Assert(0); goto end;}
									if(wVal > wMaxVoteVal)
									{
										coMaxVal = coMax;
										wMaxVoteVal = wVal;
										rMaxValAngle = (IMG_REAL)(rAngle*180/PI);
									}
								}
							}
						}
					}
				}
#ifdef _OUTPUT_LOG
				sprintf((char *)buf, "lum b=16 *%d w=%d h=%d t='%d/%d' %%p", (IMG_ULWORD)((65536)/(ulMaxValue+1e-7)), pwbufCurrentVote->linestep, pwbufCurrentVote->size.height,ulAngle,ulNumOfRotation);
				imdebug(buf, pwbufCurrentVote->ptr);
				HL_Printf(m_pHtmlLog,  "Find %d Local maximums at %d rotation\n", pulPeakNum[ulAngle], ulAngle);
#endif
				if(uwDebug & 2048)
				{
					rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
								(ulAngle+0.5)/(ulNumOfRotation)));
					_snprintf(buf, 256, "Find % 4u Local maximums at No.%02u ( % 4.2f ) rotation\n", (IMG_UWORD)pulPeakNum[ulAngle], (IMG_UWORD)ulAngle, rAngle);
					HL_Printf(m_pHtmlLog,  (char*)buf);
				}
				//check_heap(__FILE__, __LINE__);
			}
			//add object of PREVIOUS voting space
			if(ulAngle >= 1 && pulPeakNum[(IMG_LWORD)ulAngle-1] > 0)
			{
				SYS_Assert(pcoPreviousLocalMax!=NULL);
				for(i = 0; i<3; i++)
					rVoteAngle[i] = (IMG_REAL)((IMG_LREAL)rStartAngle + 
						((IMG_LREAL)rEndAngle-(IMG_LREAL)rStartAngle)*(IMG_LREAL)((IMG_LWORD)ulAngle+i-1.5)/(IMG_LREAL)(ulNumOfRotation));
				if(ulAngle == 1)
				{
					ubVoteState[0] = IMG_FALSE;
					ubVoteState[1] = pubMaskflag[(IMG_LWORD)ulAngle-1];
					ubVoteState[2] = pubMaskflag[ulAngle];
				}
				else
				{
					ubVoteState[0] = pubMaskflag[(IMG_LWORD)ulAngle-2];
					ubVoteState[1] = pubMaskflag[(IMG_LWORD)ulAngle-1];
					ubVoteState[2] = pubMaskflag[ulAngle];
				}
				wState = add_object_to_table(pcoPreviousLocalMax, pulPeakNum[(IMG_LWORD)ulAngle-1], &coS, pwbufCurrentVote-2, 
											ubVoteState, rVoteAngle, rScale, pulVotingArea+((IMG_LWORD)ulAngle-2)*(IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY, 
											ulVotingAreaPartitionX, ulVotingAreaPartitionY, pstSrchOpt ,
											psrOptable, puwNextObjID, ulMaxValue);
				if(wState != OK) goto end;					
				//check_heap(__FILE__, __LINE__);
										
			}
			if(ulLocalmaxNum)
			{
				pcoPreviousLocalMax = (IMG_COORD *)mem_pool.Malloc(sizeof(IMG_COORD)*ulLocalmaxNum);
				if(pcoPreviousLocalMax == NULL)
				{
					THROW_VIS_EXCEPTION(MEM_ERR_MALLOC);
					wState = MEM_ERR_MALLOC;
					goto end;
				}
				memcpy(pcoPreviousLocalMax, pcoLocalMax, sizeof(IMG_COORD)*ulLocalmaxNum);

			}
			else
			{
				pcoPreviousLocalMax = NULL;
			}
		}
		//}}}
		//{{{
		if(uwDebug & 2048)
		{
			mem_pool.Push();
			szImage.width = (pwbufCurrentVote->size.width);
			szImage.height = (pwbufCurrentVote->size.height);
			MEM_AllocBufAtBank(&szImage, (IMG_VVBUF *)&ubbImage2, sizeof(IMG_UBYTE));
			if(ubbImage2.ptr)
			{
				memset(ubbImage2.ptr, 64, (size_t)ubbImage2.size.height*(size_t)ubbImage2.linestep);
				j = 0, k = 65535;
				{
					pulPtr = pulVotingArea+ulAngle*ulVotingAreaPartitionX*ulVotingAreaPartitionY;
					if(pubMaskflag[ulAngle])
					{
						for(nx = 0; nx<(IMG_LWORD)ulVotingAreaPartitionX; nx++)
						{
							for(ny = 0; ny<(IMG_LWORD)ulVotingAreaPartitionY; ny++)
							{
								if(pulPtr[nx+ny*(IMG_LWORD)ulVotingAreaPartitionX])
								{
									coR.x = ((size_t)pwbufCurrentVote->size.width*nx/(IMG_LWORD)ulVotingAreaPartitionX);
									coR.y = ((size_t)pwbufCurrentVote->size.height*ny/(IMG_LWORD)ulVotingAreaPartitionY);
									szOP.width = (pwbufCurrentVote->size.width/(IMG_LWORD)ulVotingAreaPartitionX);
									szOP.height = (pwbufCurrentVote->size.height/(IMG_LWORD)ulVotingAreaPartitionY);
									wState = ALIGN_FindMax_w(pwbufCurrentVote, &coR, &szOP, &coMax, &wMaxValue);
									//if(wState != OK)	goto end;
									wState = ALIGN_FindMin_w(pwbufCurrentVote, &coR, &szOP, &coMax, &wMinValue);
									//if(wState != OK)	goto end;
									if(wMaxValue > j) j = wMaxValue;
									if(wMinValue < k) k = wMinValue;
								}
							}
						}
					}
				}
				if(j > k)
					wMaxValue = (IMG_WORD)j, wMinValue = (IMG_WORD)k;
				else
					wMaxValue = 1000, wMinValue = 0;
				HL_Printf(m_pHtmlLog,  "%02d:Max/Min voting score: %d/%d\n", ulAngle, wMaxValue, wMinValue);
				pubD = ubbImage2.ptr;
				if(pubMaskflag[ulAngle])
				{
					pS = pwbufCurrentVote->ptr;
					for(y = 0; y<pwbufCurrentVote->size.height; y++)
					{
						for(x = 0; x<pwbufCurrentVote->size.width; x++)
						{
							//SYS_Assert(pS[x] <= wMaxValue);
							pubD[x] = (IMG_UBYTE)((pS[x]-wMinValue)*256/(wMaxValue-wMinValue+1));
						}
						pubD += ubbImage2.linestep;
						pS += pwbufCurrentVote->linestep;
					}
				}
				else
				{
					for(y = 0; y<pwbufCurrentVote->size.height; y++)
					{
						for(x = 0; x<pwbufCurrentVote->size.width; x++)
						{
							pubD[x] = 0;
						}
						pubD += ubbImage2.linestep;
					}
				}
				if (uwDebug & 2048)
				{
					IMG_CHAR *p;
					_snprintf(pathname, FILENAME_MAX_LENGTH, "%s\\LOG%05uSL\\LOG%05uCoarseVote%02d_%03lu.png", m_SearchOption.GetDebugPath(), g_SearchLogIndex, g_SearchLogIndex, uwScaleLoopIndex, ulAngle);
					CVisImage img(ubbImage2);
					img.WriteImage(pathname);
					p = strrchr(pathname, '\\')-10;
					writeLog("Coarse Vote result at scale index %d, angle %d\n", uwScaleLoopIndex, ulAngle);
					HL_InsertImage(m_pHtmlLog, p);
				}
			}
			mem_pool.Pop();
		}
#ifdef _OUTPUT_LOG
		HL_Printf(m_pHtmlLog,  "Coarse Search threshold %d, max vote value %d\n", ulCoarseSearchAcceptValue, ulMaxValue);
#endif
		//}}}
		//
		////////////////////////////////////////////////////
		//Switch Voting space
		////////////////////////////////////////////////////
		//
		if(pstVotingInfo == NULL)
		{
			pD = pwbufVote[0].ptr;
			pwbufVote[0].ptr = pwbufVote[1].ptr;
			pwbufVote[1].ptr = pwbufVote[2].ptr;
			pwbufVote[2].ptr = pD; //pwbufVote[0].ptr
		}
		else
		{
			pwbufCurrentVote = pwbufVote+ulAngle+1;
		}
		//check_heap(__FILE__, __LINE__);
	}
	//last voting space
	if(ulNumOfRotation == 1)
	{
		for(i = 0; i<3; i++)
			rVoteAngle[i] = (IMG_REAL)((IMG_LREAL)rStartAngle + 
					((IMG_LREAL)rEndAngle-(IMG_LREAL)rStartAngle)*(IMG_LREAL)((IMG_LWORD)ulAngle+i-1.5)/(IMG_LREAL)(ulNumOfRotation));
		ubVoteState[0] = (IMG_UBYTE)IMG_FALSE;
		ubVoteState[1] = pubMaskflag[(IMG_LWORD)ulAngle-1];
		ubVoteState[2] = (IMG_UBYTE)IMG_FALSE;
		wState = add_object_to_table(pcoLocalMax, pulPeakNum[(IMG_LWORD)ulAngle-1], &coS, pwbufCurrentVote-2, 
				ubVoteState, rVoteAngle, rScale, pulVotingArea+((IMG_LWORD)ulAngle-2)*(IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY, 
				ulVotingAreaPartitionX, ulVotingAreaPartitionY, pstSrchOpt ,
				psrOptable, puwNextObjID, ulMaxValue);
		if(wState != OK) goto end;					
	}
	else
	{
		for(i = 0; i<3; i++)
			rVoteAngle[i] = (IMG_REAL)((IMG_LREAL)rStartAngle + 
				((IMG_LREAL)rEndAngle-(IMG_LREAL)rStartAngle)*(IMG_LREAL)((IMG_LWORD)ulAngle+i-1.5)/(IMG_LREAL)(ulNumOfRotation));
		ubVoteState[0] = pubMaskflag[(IMG_LWORD)ulAngle-2];
		ubVoteState[1] = pubMaskflag[(IMG_LWORD)ulAngle-1];
		ubVoteState[2] = (IMG_UBYTE)IMG_FALSE;
		wState = add_object_to_table(pcoLocalMax, pulPeakNum[(IMG_LWORD)ulAngle-1], &coS, pwbufCurrentVote-2, 
				ubVoteState, rVoteAngle, rScale, pulVotingArea+((IMG_LWORD)ulAngle-2)*(IMG_LWORD)ulVotingAreaPartitionX*(IMG_LWORD)ulVotingAreaPartitionY, 
				ulVotingAreaPartitionX, ulVotingAreaPartitionY, pstSrchOpt ,
				psrOptable, puwNextObjID, ulMaxValue);
		if(wState != OK) goto end;					
	}
	if(psrOptable->size == ulPreviousObjNum)	// no object added
	{
		if(wMaxVoteVal > pstSrchOpt ->rVoteRejMargin*ulMaxValue && wMaxVoteVal > 10)
		{
			for(i = 0, rA = 0.0f; i<psrOptable->size; i++)
			{
				if(psrOptable->ptr[i].rMatched > rA) rA = psrOptable->ptr[i].rMatched;
			}
			if(wMaxVoteVal*100.0f/(ulMaxValue+1e-7) > rA)
			{
				if(psrOptable->size==psrOptable->maxsize-1)
				{
					IMG_REAL rMin = 100;
					rA = wMaxVoteVal*100.0f/(ulMaxValue+1e-7f);
					for(j = 0, n = 0; i<psrOptable->size; j++)
					{
						if(rMin > psrOptable->ptr[i].rMatched)
						{
							rMin = psrOptable->ptr[i].rMatched;
							n = j;
						}
					}
					if(rMin < rA)
					{
						i = (IMG_LWORD)psrOptable->ptr[n].uwID;
						ALIGN_InitOBJ(psrOptable->ptr+n); 
						psrOptable->ptr[n].uwID = (IMG_UWORD)i;
						psrOptable->ptr[n].rco.x = (IMG_REAL)(coMaxVal.x);
						psrOptable->ptr[n].rco.y = (IMG_REAL)(coMaxVal.y);
						psrOptable->ptr[n].rotation = rMaxValAngle;
						psrOptable->ptr[n].scale = rScale;
						while(psrOptable->ptr[n].rotation > 180)psrOptable->ptr[n].rotation -= 360;
						while(psrOptable->ptr[n].rotation <-180)psrOptable->ptr[n].rotation += 360;
						psrOptable->ptr[n].rVoteScore = (IMG_UWORD)(wMaxVoteVal*100.0/(ulMaxValue+1e-7f));
						psrOptable->ptr[n].rMatched = wMaxVoteVal*100.0f/(ulMaxValue+1e-7f);
					}
				}
				else
				{
					ALIGN_InitOBJ(psrOptable->ptr+psrOptable->size); 
					psrOptable->ptr[psrOptable->size].uwID = (*puwNextObjID)++;
					if (*puwNextObjID == 65534)*puwNextObjID = 0;
					psrOptable->ptr[psrOptable->size].rco.x = (IMG_REAL)(coMaxVal.x);
					psrOptable->ptr[psrOptable->size].rco.y = (IMG_REAL)(coMaxVal.y);
					psrOptable->ptr[psrOptable->size].rotation = rMaxValAngle;
					psrOptable->ptr[psrOptable->size].scale = rScale;
					while(psrOptable->ptr[psrOptable->size].rotation > 180)psrOptable->ptr[psrOptable->size].rotation -= 360;
					while(psrOptable->ptr[psrOptable->size].rotation <-180)psrOptable->ptr[psrOptable->size].rotation += 360;
					psrOptable->ptr[psrOptable->size].rVoteScore = (IMG_UWORD)(wMaxVoteVal*100.0f/(ulMaxValue+1e-7f));
					psrOptable->ptr[psrOptable->size].rMatched = wMaxVoteVal*100.0f/(ulMaxValue+1e-7f);
					psrOptable->size++;
				}
			}
		}
	}
	check_heap(__FILE__, __LINE__);
	if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("search");
	//{{{
	if(g_ptdebug)
	{
		for(ulFeat = 0; ulFeat<ulVoteFeatNum ; ulFeat++)
		{
			IMG_REAL startangle, endangle;
			if(output_1.x < 0 || output_1.y < 0|| output_1.x >= pszOpsize->width || output_1.y >= pszOpsize->height)
			{
				HL_Printf(m_pHtmlLog,  "output out of range\n");
				break;
			}
			wVoteWeight = pbFeatureWeight[ulFeat];

			if(output_1.angle < rStartAngle)output_1.angle += 360;
			for(ulAngle = 0, rA = 1e5f, rAngle = 0; ulAngle < ulNumOfRotation; ulAngle++)
			{
				startangle = rStartAngle+(rEndAngle-rStartAngle)*
					(IMG_REAL)ulAngle/(ulNumOfRotation);
				endangle = rStartAngle+(rEndAngle-rStartAngle)*
					(ulAngle+1.0f)/(ulNumOfRotation);
				rAngle = (IMG_REAL)((rStartAngle+(rEndAngle-rStartAngle)*
					(ulAngle+0.5f)/(ulNumOfRotation))*PI/180);

			if(startangle < output_1.angle && endangle > output_1.angle) break;
			}
			cose = (IMG_REAL)cos(rAngle), sine = (IMG_REAL)sin(rAngle);
			if(InputType == ALIGN_POINT)
				wLocalAngle = (IMG_WORD)(ALIGN_NORMAL_DIR_NCOLOR( (IMG_WORD)pstVote[ulFeat].angle)*256.0/360+0.5);
			else
				wLocalAngle = (IMG_WORD)(rAngle*128/PI+ALIGN_NORMAL_DIR_NCOLOR( (IMG_WORD)pstVote[ulFeat].angle)*256.0/360+0.5);
			i = ((wLocalAngle+32)&0xff)>>6;
			if(pstSrchOpt->uwPhaseInv==0 )//check phase
			{
				while(wLocalAngle<0)wLocalAngle+=256;
				while(wLocalAngle>256)wLocalAngle-=256;
			}
			else if(pstSrchOpt->uwPhaseInv==3 || pstSrchOpt->uwPhaseInv==4) //phase mirror
			{
				while(wLocalAngle<0)wLocalAngle+=256;
				while(wLocalAngle>256)wLocalAngle-=256;
				if(wLocalAngle>128)wLocalAngle-=128;
				else	wLocalAngle+=128;
			}
			else if(pstSrchOpt->uwPhaseInv==2|| pstSrchOpt->uwPhaseInv==1)//phase inverse ignore
			{
				while(wLocalAngle<0)wLocalAngle+=128;
				while(wLocalAngle>128)wLocalAngle-=128;
			}
			rco.x = (cose*pstVote[ulFeat].rco.x - sine*pstVote[ulFeat].rco.y)*rScaleX;
			rco.y = (sine*pstVote[ulFeat].rco.x + cose*pstVote[ulFeat].rco.y)*rScaleY;
			//if(rco.x > 0)coR.x = (IMG_WORD) (rco.x+0.5);
			//else		coR.x = (IMG_WORD) (rco.x-0.5);
			//if(rco.y > 0)coR.y = (IMG_WORD) (rco.y+0.5);
			//else		coR.y = (IMG_WORD) (rco.y-0.5);
			coR.x = ((((IMG_LWORD)((IMG_LREAL)rco.x+65536+0.5)))-(65536));
			coR.y = ((((IMG_LWORD)((IMG_LREAL)rco.y+65536+0.5)))-(65536));

			if(coR.x < 0)							startx = -coR.x > lwMinX ? -coR.x : lwMinX;
			else									startx = lwMinX;
			if(coR.y < 0)							starty = -coR.y > lwMinY ? -coR.y : lwMinY;
			else									starty = lwMinY;
			if(coR.x >= pszOpsize->width-lwMaxX)		endx = pszOpsize->width-coR.x-1;
			else									endx = lwMaxX;
			if(coR.y >= pszOpsize->height-lwMaxY)		endy = pszOpsize->height-coR.y-1;
			else									endy = lwMaxY;

			if(ubColor == IMG_CHANNEL_COLOR)
			{
				if(ALIGN_IS_NCOLOR_NORMAL((IMG_WORD)pstVote[ulFeat].angle) && pstSrchOpt->ubColorMatchOpt != ALIGN_NCOLOR_DIR_MATCH_SEARCHMAX)
					i = ALIGN_INDEX_NCOLOR((IMG_WORD)(pstVote[ulFeat].angle))+1;
				else
					i = 0;
				pS = (IMG_WORD*)puwbCombined[i].ptr+(coR.y+starty)*((size_t)puwbCombined[i].linestep)+coR.x;
			}
			else
			{
				pS = (IMG_WORD*)puwbCombined[0].ptr+(starty+coR.y)*((size_t)puwbCombined[0].linestep)+coR.x;
			}
			BUF_OFF(pD, pwbufCurrentVote, &coZero);
			pD += (size_t)pwbufCurrentVote->linestep*starty;
			x = output_1.x, y = output_1.y;
			ny = y+coR.y;
			nx = x+coR.x;
			if(nx > 0 && ny > 0 && nx < pszOpsize->width && ny < pszOpsize->height)
			{
				pS += (y-starty)*((size_t)puwbCombined[0].linestep);
				pD += (y-starty)*(size_t)pwbufCurrentVote->linestep;
				startangle = rStartAngle+(rEndAngle-rStartAngle)*
					(IMG_REAL)ulAngle/(ulNumOfRotation);
				endangle = rStartAngle+(rEndAngle-rStartAngle)*
					(ulAngle+1.0f)/(ulNumOfRotation);
				if(pstSrchOpt->uwPhaseInv == 1 ||pstSrchOpt->uwPhaseInv == 2)
				{
					//angle difference 
					lwAngle = labs((char)((((IMG_UWORD)(pS[x])&0x7F)-wLocalAngle)<<1))>>1;
					i = (-((IMG_LWORD)(lwAngle<(IMG_LWORD)VALID_ANGLE_BIAS)))&0xFFFF ; 
					j = (((IMG_UWORD)(pS[x])&0xFF00)>>(8))*wVoteWeight;
				}
				else
				{
					//angle difference 
					lwAngle = labs((char)(((IMG_UWORD)(pS[x])&0xFF)-wLocalAngle));
					i = (-((IMG_LWORD)(lwAngle<(IMG_LWORD)VALID_ANGLE_BIAS)))&0xFFFF ; 
					j = (((IMG_UWORD)(pS[x])&0xFF00)>>(8))*wVoteWeight;
				}
				{
					if(ulFeat==0)
					{
						HL_Printf(m_pHtmlLog,  "\nPosition [%d %d], angle %d(%3.2f), angle threshold %d\n", x, y, ulAngle, rAngle*180/PI, VALID_ANGLE_BIAS);
					}
					if(ulFeat == 0)
					{
						HL_Printf(m_pHtmlLog,  "Srch Angle = %.2f-%.2f, at %.2f\n", startangle, endangle, rAngle*180/PI);
					}
					HL_Printf(m_pHtmlLog,  "No.% 3d(w % 2d): [% 3d % 3d ], dir(dif/lrn/srch) = % 2d % 3d % 3d edge = % 4d % 4d\n", 
						ulFeat, pbFeatureWeight[ulFeat], nx, ny, lwAngle, wLocalAngle, 0xFF&((IMG_UWORD)(pS[x])), j, i&j);
				}
			}
			else
			{
				HL_Printf(m_pHtmlLog,  "No.% 3d(w % 2d): [% 3d % 3d ],out of range\n", ulFeat, pbFeatureWeight[ulFeat], nx, ny );
			}


		}
	}
	//}}}
	//check_heap(__FILE__, __LINE__);

	if(ulPreviousObjNum < psrOptable->size)
	{
		ulObj = (IMG_ULWORD)psrOptable->size-ulPreviousObjNum;
		for(i = 0; i<(IMG_LWORD)(psrOptable->size-ulPreviousObjNum); i++)
		{
			IMG_FEATUREPT	optr;
			IMG_RCOORD	rcoObj;
			pstObj = psrOptable->ptr+ulPreviousObjNum+i;;
			memset(&optr, 0, sizeof(IMG_FEATUREPT));
			optr.rco.x = -rcoFeatureVector.x;
			optr.rco.y = -rcoFeatureVector.y;
			ALIGN_ND_RTS(&optr, 0, 0, (IMG_REAL)cos(pstObj->rotation*D2R), 
				(IMG_REAL)sin(pstObj->rotation*D2R), 
				pstObj->rco.x,  pstObj->rco.y, 
				pstObj->scale, pstObj->scale, 
				&rcoObj);
			pstObj->rco = rcoObj;

		}
		//if incomplete object, add half score to the feature out side
		if(pstSrchOpt->uwCompleteObj == 0 && MultiObj == SRCH_MO_HIGHEST) //incomplete object && SHI turned on && highest score
		{
			pstObj = psrOptable->ptr+ulPreviousObjNum;
		}
		if(MultiObj == SRCH_MO_HIGHEST)
		{
			pstObj = psrOptable->ptr+ulPreviousObjNum;
			if(ulObj > 1 )
			{
				qsort(pstObj, ulObj, sizeof(IMG_OBJ), ALIGN_Comp_OBJ_By_Score_A);  //lint !e64
				//rA = pstObj[0].rVoteScore*0.7;
				ALIGN_GetScoreThresholdByDistribution(pstObj, ulObj, &rA);
				if(rA < pstSrchOpt ->rVoteRejMargin*100.0f)
					rA = pstSrchOpt ->rVoteRejMargin*100.0f;
				else
					pstSrchOpt ->rVoteRejMargin = rA/100.0f;
				if(uwDebug & 2048)
				{
					HL_Printf(m_pHtmlLog,  "Margined Score Threshold is %f\n", rA);
				}
				for(i = 0; i<(IMG_LWORD)(psrOptable->size-ulPreviousObjNum); i++)
				{
					if(pstObj[i].rVoteScore < rA) break;
				}
				psrOptable->size = (IMG_UWORD)(ulPreviousObjNum+(IMG_ULWORD)i);
			}
			else
			{
				if(pstObj->rMatched*.8f/100.0f > pstSrchOpt ->rVoteRejMargin)
					pstSrchOpt ->rVoteRejMargin = pstObj->rMatched*.8f/100.0f;
			}
			if(uwDebug & 2048)
			{
				/*ALIGN_Save_Obj_Table*/(psrOptable,(IMG_UBYTE*)"Exhaustive Coarse Search Result After Self-rejection",(IMG_UBYTE*)"gsd",wAlignFileIndex,(IMG_UBYTE*)".log");
			}
		}
		else
		{
			pstObj = psrOptable->ptr+ulPreviousObjNum;
			for(i = 0; i<(IMG_LWORD)ulObj; i++)
			{
				if(pstObj->rMatched/100.0f > pstSrchOpt ->rVoteRejMargin)
					pstSrchOpt ->rVoteRejMargin = pstObj->rMatched/100.0f;
				pstObj++;
			}
			if(pstSrchOpt ->rCoarseAcceptLevel < pstSrchOpt ->rVoteRejMargin)
				pstSrchOpt ->rVoteRejMargin = pstSrchOpt ->rCoarseAcceptLevel;
		}
	}

	if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("peak_search");
#ifdef _OUTPUT_LOG
	//ulFeat = 0;
	lwMaxX = lwMaxY = 0;
	HL_Printf(m_pHtmlLog,  "peak num %d\n", ulLocalmaxNum);
	for(i = 0; i<psrOptable->size; i++)
	{
		HL_Printf(m_pHtmlLog,  "obj % 3d: pos x = % 4.2f, y= % 4.2f, rotation = % 4.2f, scale = % 4.2f, score = % 4.2f\n", i, psrOptable->ptr[i].rco.x,
			psrOptable->ptr[i].rco.y, psrOptable->ptr[i].rotation, psrOptable->ptr[i].scale, psrOptable->ptr[i].rMatched);

	}
	ulFeat = 0;

	for(i = 0; i<(IMG_LWORD)ulNumOfRotation; i++)
	{
		if(pubMaskflag[i])
		{
			rAngle = (IMG_REAL)((rStartAngle + (rEndAngle-rStartAngle)*
						(i+0.5)/(ulNumOfRotation)));
			localmax = 0;
			for(nx = 0; nx<(IMG_LWORD)ulVotingAreaPartitionX; nx++)
			{
				for(ny = 0; ny<(IMG_LWORD)ulVotingAreaPartitionY; ny++)
				{
					if(pulPtr[nx+ny*(IMG_LWORD)ulVotingAreaPartitionX])
					{
						coR.x = (size_t)pwbufVote[i].size.width*nx/(IMG_LWORD)ulVotingAreaPartitionX;
						coR.y = (size_t)pwbufVote[i].size.height*ny/(IMG_LWORD)ulVotingAreaPartitionY;
						szOp.width = (size_t)pwbufVote[i].size.width*(nx+1)/(IMG_LWORD)ulVotingAreaPartitionX-coR.x;
						szOp.height = (size_t)pwbufVote[i].size.height*(ny+1)/(IMG_LWORD)ulVotingAreaPartitionY-coR.y;
						for(y = coR.y; y<coR.y+szOp.height; y++)
						{
							pD = pwbufVote[i].ptr+y*(size_t)pwbufVote[i].linestep;
							for(x = coR.x; x<coR.x+szOp.width; x++)
							{
								if(ulFeat < pD[x])
								{
									lwMaxX = x;
									lwMaxY = y;
									ulFeat = pD[x];
									lwAngle = i;
								}
								if(localmax < pD[x])localmax = pD[x];
							}
						}
					}
				}
			}
#if defined _OUTPUT_LOG 
			HL_Printf(m_pHtmlLog,  "local max in %02d(% 3.2f) is % 3d at [%3d %3d]\n", i, rAngle, localmax, nx, ny);
#endif
		}
	}
	HL_Printf(m_pHtmlLog,  "max likewise obj lies in x = %d, y = %d, angle = %d, score = %d\n", nx, ny, lwAngle, ulFeat);
#endif

	//psrOptable->ptr[0].rco.x = nx;
	//psrOptable->ptr[0].rco.y = ny;
	//psrOptable->ptr[0].rotation = (IMG_REAL)(((pstSrchOpt ->rStartAngLarge> pstSrchOpt ->rEndAngLarge? pstSrchOpt ->rEndAngLarge: pstSrchOpt ->rStartAngLarge) +
	//									fabs(pstSrchOpt ->rStartAngLarge-pstSrchOpt ->rEndAngLarge)*
	//									lwAngle*SEARCH_ANGLE_INTERVAL/ulNumOfRotation)*PI/180.0f);
	//psrOptable->ptr[0].rVoteScore = ulFeat;
	//check_heap(__FILE__, __LINE__);
	pstFirst = psrOptable->ptr+ulPreviousObjNum;
	if(psrOptable->size > ulPreviousObjNum)
		qsort(pstFirst, (IMG_ULWORD)(psrOptable->size-ulPreviousObjNum), sizeof(IMG_OBJ), ALIGN_Comp_OBJ_By_RTS);  //lint !e64
	//check_heap(__FILE__, __LINE__);
	//
end:
	/////////////////////////////////////////
	//END
	/////////////////////////////////////////
	if(wState == ALIGN_ERR_NO_OBJECT_FOUND)
	{
		wState = OK;
	}
	if(uwDebug & 1)
	{
		HL_Printf(m_pHtmlLog,  (char*)"Coarse Search Finished with status %d\n", wState);
	}
	if(wState != OK && uwDebug & 1)HL_Printf(m_pHtmlLog,  "error status %d returned at file %s, line %d\n", wState, __FILE__, __LINE__);
	if (pstSrchOpt->uwDebug & 256) g_pstClock->Click("coarse_over");
	if(plwbufMask)
	{
		for(i = 0; i<(IMG_LWORD)ulNumMask; i++)
			if(plwbufMask[i].ptr)CVisMemPool::PFree(plwbufMask[i].ptr);
		CVisMemPool::PFree(plwbufMask);	
	}
	check_heap(__FILE__, __LINE__);
	return wState;
}





















//IMG_WORD	ALIGN_GetMaxPsuedoReductionLevel(IMG_UBBUF		*pubbSbuf,
//									   //{{{
//									   IMG_COORD			*pcoSoff,
//									   IMG_SIZE				*pszOpsize,
//									   CVisAlignRecordTable			*pstEptable,
//									   IMG_UBYTE			ubNumChannel)
//{
//	IMG_WORD	wState = OK, wThrd, wNumLabel;
//	IMG_LWORD	i,j;
//	ALIGN_VOTING_INFORMATION	stVoteInformation = {0};
//	IMG_UWORD	uwChannel = ubNumChannel == IMG_CHANNEL_COLOR? 4:1;
//	IMG_UWORD	uwID = 0, uwLabelID, uwRed1=0, uwRed2=0, uwShortSize;
//	IMG_ULWORD	ulOff, ulArea, ulEdgeNum;
//	RCX_EDGE	*pstEdge;
//	RCX_EPD_PARA stEdgePar;
//	IMG_WORD	*pwPtr, wMaxVal;
//	IMG_UWORD	*puwPtr;
//
//	IMG_ALIGN_SRCH_ARG 		stSrchArg;
//	ALIGN_SEARCH_OPTION 		stSrchOpt;
//	ALIGN_SRCH_RESULT 		stObjTable;
//
//	IMG_REAL	rTrueObjScore, rElastic = -.99f, rScale;
//	IMG_WBUF	*pwbVote, wbufDir[4];
//	IMG_UBBUF	ubbThrd, ubbEdge[4];
//	IMG_UWBUF	uwbLabel, uwbMag[4];
//	IMG_COORD	coZero={0}, coPos, coMax, coUL, coBR, coOff;
//	IMG_SIZE	szOp;
//	IMG_RCOORD	rcoUL, rcoBR;
//	
//
//	//Init
//	wState = MEM_PushAllHeapStatus();
//	if(wState!=OK) return wState;
//
//	rcoUL.x = pubbSbuf->size.width;
//	rcoUL.y = pubbSbuf->size.height;
//	rcoBR.x = 0.0f;
//	rcoBR.y = 0.0f;
//	for(i = 0; i<pstEptable->uwNumOfVoteFeature; i++)
//	{
//		rcoUL.x = rcoUL.x > pstEptable->pstVote[i].rco.x ? pstEptable->pstVote[i].rco.x : rcoUL.x;
//		rcoUL.y = rcoUL.y > pstEptable->pstVote[i].rco.y ? pstEptable->pstVote[i].rco.y : rcoUL.y;
//		rcoBR.x = rcoBR.x < pstEptable->pstVote[i].rco.x ? pstEptable->pstVote[i].rco.x : rcoBR.x;
//		rcoBR.y = rcoBR.y < pstEptable->pstVote[i].rco.y ? pstEptable->pstVote[i].rco.y : rcoBR.y;
//	}
//	rcoUL.x += pstEptable->rcoRef.x;
//	rcoBR.x += pstEptable->rcoRef.x;
//	rcoUL.y += pstEptable->rcoRef.y;
//	rcoBR.y += pstEptable->rcoRef.y;
//
//	coOff.x = pcoSoff->x;// < rcoUL.x-10 ? (rcoUL.x-10) : pcoSoff->x;
//	coOff.y = pcoSoff->y;// < rcoUL.y-10 ? (rcoUL.y-10) : pcoSoff->y;
//	szOp.width  = pszOpsize->width;//+pcoSoff->x > rcoBR.x+10.0f ? (rcoBR.x-rcoUL.x+20.0f):pszOpsize->width;
//	szOp.height  = pszOpsize->height;//+pcoSoff->y > rcoBR.y+10.0f ? (rcoBR.y-rcoUL.y+20.0f):pszOpsize->height;
//
//	/*
//	if(pstEptable->rcoRef.x-coOff.x < 30 )
//	{
//		if(pstEptable->rcoRef.x > 30)
//		{
//			szOp.width += (coOff.x-pstEptable->rcoRef.x+30);
//			coOff.x = (pstEptable->rcoRef.x-30);
//		}
//		else
//		{
//			szOp.width += coOff.x;
//			coOff.x = 0;
//		}
//	}
//	if(pstEptable->rcoRef.y-coOff.y < 30 )
//	{
//		if(pstEptable->rcoRef.y > 30)
//		{
//			szOp.height += (coOff.y-pstEptable->rcoRef.y+30);
//			coOff.y = (pstEptable->rcoRef.y-30);
//		}
//		else
//		{
//			szOp.height += coOff.y;
//			coOff.y = 0;
//		}
//	}
//	if(coOff.x+szOp.width-pstEptable->rcoRef.x < 30)
//	{
//		if(pstEptable->rcoRef.x+30<pcoSoff->x+pszOpsize->width)
//		{
//			szOp.width = (pstEptable->rcoRef.x+30-coOff.x);
//		}
//		else
//		{
//			szOp.width = (pcoSoff->x+pszOpsize->width-coOff.x);
//		}
//	}
//	if(coOff.y+szOp.height-pstEptable->rcoRef.y < 30)
//	{
//		if(pstEptable->rcoRef.y+30<pcoSoff->y+pszOpsize->height)
//		{
//			szOp.height = (pstEptable->rcoRef.y+30-coOff.y);
//		}
//		else
//		{
//			szOp.height = (pcoSoff->y+pszOpsize->height-coOff.y);
//		}
//	}
//	*/
//
//
//	ALIGN_InitSrchArg(&stSrchArg);
//	stSrchArg.ubRedFactor = (IMG_UBYTE)0;
//	stSrchArg.stAdvPara.ubAngleMatchTolerance = 30;
//	stSrchArg.stAdvPara.ubElasticity = 0;
//	stSrchArg.rAngOff = 0;
//	stSrchArg.rAngRange= 0;
//	stSrchArg.rcoMagFactor.x = \
//	stSrchArg.rcoMagFactor.y = 1.0;
//	stSrchArg.stAdvPara.rCoarseAcceptLevel = 0.5;
//	stSrchArg.ubNumChannel = ubNumChannel;
//
//	ALIGN_InitSrchOpt(&stSrchOpt);
//	stSrchOpt.ubCoarseSrchOpt = ALIGN_SRCH_EXHAUSTIVE_COARSE_SRCH;
//	stSrchOpt.uwPhaseInv = 0;
//	stSrchOpt.uwCompleteObj = 0;	//incomplete
//	stSrchOpt.MultiObj = ALIGN_SRCH_MULTIOBJ_MULTIPLE;		//multiple object
//	stSrchOpt.ubColorMatchOpt = ALIGN_NCOLOR_DIR_MATCH_LEARN;
//	
//
//	stEdgePar.rSigma = 0.0;
//	stEdgePar.ubEdgeThd = 6;
//	stEdgePar.uwScale = 1;
//
//	wState = ALIGN_CreateObjectTableByMEM(&stObjTable, 1000);
//	if(wState!=OK) goto end;
//
//	wState = MEM_AllocBufAtBank(&szOp, (IMG_VVBUF *)&ubbThrd);
//	if(wState!=OK) goto end;
//
//	wState = MEM_AllocBufAtBank(&szOp, (IMG_VVBUF *)&uwbLabel);
//	if(wState!=OK) goto end;
//
//
//	for(i = 0; i<uwChannel; i++)
//	{
//		wState = MEM_AllocBufAtBank(&szOp, (IMG_VVBUF *)ubbEdge+i);
//		if(wState!=OK) goto end;
//		wState = MEM_AllocBufAtBank(&szOp, (IMG_VVBUF *)uwbMag+i);
//		if(wState!=OK) goto end;
//		wState = MEM_AllocBufAtBank(&szOp, (IMG_VVBUF *)wbufDir+i);
//		if(wState!=OK) goto end;
//	}
//
//	wState = ALIGN_MallocForCoarseSearchVoting(&szOp, &stSrchOpt, &stSrchArg);
//	if(wState!=OK) goto end;
//
//	wState = RCX_EdgePtDetect_R88_SSE_Color(pubbSbuf, ubbEdge, NULL, wbufDir, uwbMag, NULL, 
//			&coOff, &coZero, &coZero, &coZero, &coZero, &coZero, &szOp, 
//			&ulEdgeNum, NULL, &stEdgePar, &rScale, ubNumChannel);
//	if(wState!=OK) goto end;
//	pstEdge = (RCX_EDGE *)mem_pool.Malloc(((IMG_ULWORD)(ulEdgeNum*1.2)+500)*sizeof(RCX_EDGE));
//	if(pstEdge == NULL)
//	{
//		wState = MEM_ERR_MALLOC;
//		goto end;
//	}
//	wState = RCX_EdgePtDetect_R88_SSE_Color(pubbSbuf, ubbEdge, NULL, wbufDir, uwbMag, NULL, 
//			&coOff, &coZero, &coZero, &coZero, &coZero, &coZero, &szOp, 
//			&ulEdgeNum, pstEdge, &stEdgePar, &rScale, ubNumChannel);
//	if(wState!=OK) goto end;
//
//	//if(ubNumChannel == IMG_CHANNEL_COLOR)
//	//{
//	//	for(i = 0; i<IMG_CHANNEL_COLOR; i++)
//	//	{
//	//		wState = RCX_EdgePtDetect_R88_SSE(pubbSbuf+i, ubbEdge+i+1, NULL, wbufDir+i+1, uwbMag+i+1, NULL, 
//	//				&coOff, &coZero, &coZero, &coZero, &coZero, &coZero, &szOp, 
//	//				&ulEdgeNum, NULL, &stEdgePar, &rScale);
//	//		if(wState!=OK) goto end;
//	//		pstEdge = (RCX_EDGE *)mem_pool.Malloc(((IMG_ULWORD)(ulEdgeNum*1.2)+500)*sizeof(RCX_EDGE));
//	//		if(pstEdge == NULL)
//	//		{
//	//			wState = MEM_ERR_MALLOC;
//	//			goto end;
//	//		}
//	//		wState = RCX_EdgePtDetect_R88_SSE(pubbSbuf+i, ubbEdge+i+1, NULL, wbufDir+i+1, uwbMag+i+1, NULL, 
//	//				&coOff, &coZero, &coZero, &coZero, &coZero, &coZero, &szOp, 
//	//				&ulEdgeNum, pstEdge, &stEdgePar, &rScale);
//	//		if(wState!=OK) goto end;
//	//	}
//	//}
//
//
//	
//	stSrchArg.ulSrchTimestamp = 0;
//	while(uwRed1 == 0 && rElastic < 5)
//	{
//		rElastic += 1;
//		stSrchArg.stAdvPara.ubElasticity = (IMG_UBYTE)(rElastic+0.5f);
//		stSrchArg.stAdvPara.rElasticity = rElastic;
//		stSrchArg.ulSrchTimestamp ++;
//		//get voting information
//		wState = img_sha_pixel_search_template_with_voting_output((IMG_UBBUF *)ubbEdge, (IMG_COORD *)&coZero, (IMG_WBUF *)wbufDir, (IMG_COORD *)&coZero, 
//				NULL, (IMG_SIZE *)&szOp, pstEptable, &stObjTable, 
//				&stSrchArg, &stSrchOpt, NULL, 0, NULL, 
//				0, ALIGN_BUFFER, NULL, NULL, &stVoteInformation, 
//				NULL, NULL, NULL, 0, 1.0f, 0, &uwID);
//		//
//		if(wState != OK) goto end;
//		//start analysis
//		SYS_Assert(stVoteInformation.uwNumOfVoting == 1);
//		coPos.x = (pstEptable->rcoRef.x-coOff.x);
//		coPos.y = (pstEptable->rcoRef.y-coOff.y);
//		pwbVote = stVoteInformation.pwbVoting;
//		BUF_OFF(pwPtr, pwbVote, &coPos);
//		rTrueObjScore = 0.0f;
//		for(i = -1; i<=1; i++)
//		{
//			for(j = -1; j<=1; j++)
//			{
//				if(coPos.x+j >= 0 && coPos.y+i >= 0 && coPos.x+j < pwbVote->size.width && coPos.y+i<pwbVote->size.height)
//				{
//					if(rTrueObjScore < *(pwPtr+j+i*pwbVote->linestep)/(stVoteInformation.ulMaxScore+1e-5f))
//					{
//						rTrueObjScore = (IMG_REAL)(*(pwPtr+j+i*pwbVote->linestep))/(stVoteInformation.ulMaxScore+1e-5f);
//					}
//				}
//			}
//		}
//		//rTrueObjScore = (IMG_REAL)pwPtr[0]/(stVoteInformation.ulMaxScore+1e-5f);
//		wState = ALIGN_FindMax_w(pwbVote, &coZero, &szOp, &coMax, &wMaxVal);
//		if(wState != OK) goto end;
//		//rMaxScore = (IMG_REAL)wMaxVal / (stVoteInformation.ulMaxScore+1e-5f);
//		if(wMaxVal < 10)
//		{
//			CVisMemPool::PFree(&stVoteInformation);
//			continue;
//		}
//		//SYS_Assert(rTrueObjScore > rMaxScore*0.9 || ALIGN_DIST(coPos, coMax) < 10);
//		//threshold
//		wThrd = (IMG_WORD)(pwPtr[0] * 0.6 + 0.5);
//		wState = ALIGN_Compare_SSE_wub(pwbVote, &coZero, &ubbThrd, &coZero, wThrd, 1, 1, &szOp); 
//		if(wState != OK) goto end;
//		//label
//		wState = DSP_Label8_ubuw(&ubbThrd, &coZero, 1, 100, &uwbLabel, &coZero, &szOp, &wNumLabel);
//		if(wState != OK) goto end;
//		//count
//		ulOff = (IMG_ULWORD)IMG_OFF(&uwbLabel, &coPos);
//		uwLabelID = uwbLabel.ptr[ulOff];
//		SYS_Assert(uwLabelID >= 100);
//		coUL.x = szOp.width, coUL.y = szOp.height;
//		coBR.x = coBR.y = 0;
//		puwPtr = uwbLabel.ptr;
//		for(i = 0, ulArea = 0; i<szOp.height; i++)
//		{
//			for(j = 0; j<szOp.width; j++)
//			{
//				if(puwPtr[j] == uwLabelID)
//				{
//					if(coUL.x > j)coUL.x = j;
//					if(coUL.y > i)coUL.y = i;
//					if(coBR.x < j)coBR.x = j;
//					if(coBR.y < i)coBR.y = i;
//					ulArea ++;
//					ubbThrd.ptr[i*ubbThrd.linestep+j] = 255;
//				}
//				else
//					ubbThrd.ptr[i*ubbThrd.linestep+j] = 0;
//			}
//			puwPtr += uwbLabel.linestep;
//		}
//		//
//		uwRed1 = (IMG_UWORD)(log((IMG_LREAL)ulArea/5.0)/log(2.0));
//		uwShortSize = (IMG_UWORD)IMG_MIN(coBR.x-coUL.x, coBR.y-coUL.y);
//		uwRed2 = (IMG_UWORD)(log((IMG_LREAL)uwShortSize*2.0)/log(2.0));
//		uwRed1 = uwRed1 < uwRed2 ? uwRed1 : uwRed2;
//		CVisMemPool::PFree(&stVoteInformation);
//	}
//	pstEptable->rExpVotingElastic = rElastic;
//	pstEptable->uwExpVotingReduction = uwRed1;
//end:
//	CVisMemPool::PFree(&stVoteInformation);
//	//ALIGN_FreeCoarseSrchInfo();
//	i = MEM_PopAllHeapStatus();
//	if(i != OK) return (IMG_WORD)i;
//	return wState;
//}
//}}}
/*lint -restore*/
	
// vim:fdm=marker:ts=4
